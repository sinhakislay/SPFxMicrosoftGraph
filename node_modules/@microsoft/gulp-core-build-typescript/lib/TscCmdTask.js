"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const node_core_library_1 = require("@microsoft/node-core-library");
const glob = require("glob");
const globEscape = require("glob-escape");
const decomment = require("decomment");
const RSCTask_1 = require("./RSCTask");
const TsParseConfigHost_1 = require("./TsParseConfigHost");
/**
 * @beta
 */
class TscCmdTask extends RSCTask_1.RSCTask {
    constructor() {
        super('tsc', {
            staticMatch: [
                'src/**/*.js',
                'src/**/*.json',
                'src/**/*.jsx'
            ],
            removeCommentsFromJavaScript: false
        });
    }
    loadSchema() {
        return node_core_library_1.JsonFile.load(path.resolve(__dirname, 'schemas', 'tsc-cmd.schema.json'));
    }
    executeTask() {
        this.initializeRushStackCompiler();
        // Static passthrough files.
        const srcPath = path.join(this.buildConfig.rootPath, this.buildConfig.srcFolder);
        const libFolders = [this.buildConfig.libFolder];
        if (this.buildConfig.libAMDFolder) {
            libFolders.push(this.buildConfig.libAMDFolder);
        }
        if (this.buildConfig.libES6Folder) {
            libFolders.push(this.buildConfig.libES6Folder);
        }
        if (this.buildConfig.libESNextFolder) {
            libFolders.push(this.buildConfig.libESNextFolder);
        }
        const resolvedLibFolders = libFolders.map((libFolder) => path.join(this.buildConfig.rootPath, libFolder));
        const promises = (this.taskConfig.staticMatch || []).map((pattern) => node_core_library_1.LegacyAdapters.convertCallbackToPromise(glob, path.join(globEscape(this.buildConfig.rootPath), pattern)).then((matchPaths) => {
            for (const matchPath of matchPaths) {
                const fileContents = node_core_library_1.FileSystem.readFile(matchPath);
                const relativePath = path.relative(srcPath, matchPath);
                for (const resolvedLibFolder of resolvedLibFolders) {
                    const destPath = path.join(resolvedLibFolder, relativePath);
                    node_core_library_1.FileSystem.writeFile(destPath, fileContents, { ensureFolderExists: true });
                }
            }
        }));
        const typescriptCompiler = new this._rushStackCompiler.TypescriptCompiler({
            customArgs: this.taskConfig.customArgs,
            fileError: this.fileError.bind(this),
            fileWarning: this.fileWarning.bind(this)
        }, this.buildFolder, this._terminalProvider);
        const basePromise = typescriptCompiler.invoke();
        if (basePromise) {
            promises.push(basePromise);
        }
        let buildPromise = Promise.all(promises).then(() => { });
        if (this.taskConfig.removeCommentsFromJavaScript === true) {
            buildPromise = buildPromise.then(() => this._removeComments(this._rushStackCompiler.ToolPackages.typescript));
        }
        return buildPromise;
    }
    _onData(data) {
        // Log lines separately
        const dataLines = data.toString().split('\n');
        for (const dataLine of dataLines) {
            const trimmedLine = (dataLine || '').trim();
            if (!!trimmedLine) {
                if (trimmedLine.match(/\serror\s/i)) {
                    // If the line looks like an error, log it as an error
                    this.logError(trimmedLine);
                }
                else {
                    this.log(trimmedLine);
                }
            }
        }
    }
    _removeComments(typescript) {
        const configFilePath = typescript.findConfigFile(this.buildConfig.rootPath, node_core_library_1.FileSystem.exists);
        if (!configFilePath) {
            return Promise.reject(new Error('Unable to resolve tsconfig file to determine outDir.'));
        }
        // tslint:disable-next-line:typedef
        const tsConfig = typescript.parseJsonConfigFileContent(node_core_library_1.JsonFile.load(configFilePath), new TsParseConfigHost_1.TsParseConfigHost(), path.dirname(configFilePath));
        if (!tsConfig || !tsConfig.options.outDir) {
            return Promise.reject('Unable to determine outDir from TypesScript configuration.');
        }
        return node_core_library_1.LegacyAdapters.convertCallbackToPromise(glob, path.join(globEscape(tsConfig.options.outDir), '**', '*.js')).then((matches) => {
            for (const match of matches) {
                const sourceText = node_core_library_1.FileSystem.readFile(match);
                const decommentedText = decomment(sourceText, {
                    // This option preserves comments that start with /*!, /**! or //! - typically copyright comments
                    safe: true
                });
                node_core_library_1.FileSystem.writeFile(match, decommentedText);
            }
        });
    }
}
exports.TscCmdTask = TscCmdTask;
//# sourceMappingURL=TscCmdTask.js.map