"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const resolve = require("resolve");
const node_core_library_1 = require("@microsoft/node-core-library");
const gulp_core_build_1 = require("@microsoft/gulp-core-build");
const GCBTerminalProvider_1 = require("./GCBTerminalProvider");
class RSCTask extends gulp_core_build_1.GulpTask {
    constructor(taskName, defaultConfig) {
        super(taskName, Object.assign({ allowBuiltinCompiler: false }, defaultConfig // tslint:disable-line:no-any (the spread operator isn't working here for some reason)
        ));
        this._terminalProvider = new GCBTerminalProvider_1.GCBTerminalProvider(this);
        this._terminal = new node_core_library_1.Terminal(this._terminalProvider);
    }
    static get _packageJsonLookup() {
        if (!RSCTask.__packageJsonLookup) {
            RSCTask.__packageJsonLookup = new node_core_library_1.PackageJsonLookup();
        }
        return RSCTask.__packageJsonLookup;
    }
    get _rushStackCompilerPackagePath() {
        if (!RSCTask._rushStackCompilerPackagePathCache.has(this.buildFolder)) {
            const projectTsconfigPath = path.join(this.buildFolder, 'tsconfig.json');
            const visitedTsconfigPaths = new Set();
            let compilerPath;
            try {
                compilerPath = this._resolveRushStackCompilerFromTsconfig(projectTsconfigPath, visitedTsconfigPaths);
            }
            catch (e) {
                if (this.taskConfig.allowBuiltinCompiler) {
                    this._terminal.writeVerboseLine('Unable to resolve rush-stack-compiler from tsconfig.json. Using built-in compiler');
                    const builtInCompilerPath = RSCTask._packageJsonLookup.tryGetPackageFolderFor(require.resolve('@microsoft/rush-stack-compiler-3.2'));
                    if (!builtInCompilerPath) {
                        throw new Error('Unable to resolve built-in compiler. Ensure @microsoft/gulp-core-build-typescript is correctly installed');
                    }
                    compilerPath = builtInCompilerPath;
                }
                else {
                    throw e;
                }
            }
            RSCTask._rushStackCompilerPackagePathCache.set(this.buildFolder, compilerPath);
        }
        return RSCTask._rushStackCompilerPackagePathCache.get(this.buildFolder);
    }
    get buildFolder() {
        return this.taskConfig.buildDirectory || this.buildConfig.rootPath;
    }
    initializeRushStackCompiler() {
        const compilerPackageJson = node_core_library_1.JsonFile.load(path.join(this._rushStackCompilerPackagePath, 'package.json'));
        const main = compilerPackageJson.main;
        if (!main) {
            throw new Error('Compiler package does not have a "main" entry.');
        }
        this._rushStackCompiler = require(path.join(this._rushStackCompilerPackagePath, main));
    }
    /**
     * Determine which compiler should be used to compile a given project.
     *
     * @remarks
     * We load the tsconfig.json file, and follow its "extends" field until we reach the end of the chain.
     * We expect the last extended file to be under an installed @microsoft/rush-stack-compiler-* package,
     * which determines which typescript/tslint/api-extractor versions should be invoked.
     *
     * @param tsconfigPath - The path of a tsconfig.json file to analyze
     * @returns The absolute path of the folder containing "@microsoft/rush-stack-compiler-*" which should be used
     * to compile this tsconfig.json project
     */
    _resolveRushStackCompilerFromTsconfig(tsconfigPath, visitedTsconfigPaths) {
        this._terminal.writeVerboseLine(`Examining ${tsconfigPath}`);
        visitedTsconfigPaths.add(tsconfigPath);
        if (!node_core_library_1.FileSystem.exists(tsconfigPath)) {
            throw new Error(`tsconfig.json file (${tsconfigPath}) does not exist.`);
        }
        let tsconfig;
        try {
            tsconfig = node_core_library_1.JsonFile.load(tsconfigPath);
        }
        catch (e) {
            throw new Error(`Error parsing tsconfig.json ${tsconfigPath}: ${e}`);
        }
        if (!tsconfig.extends) {
            // Does the chain end with a file in the rush-stack-compiler package?
            const packageJsonPath = RSCTask._packageJsonLookup.tryGetPackageJsonFilePathFor(tsconfigPath);
            if (packageJsonPath) {
                const packageJson = node_core_library_1.JsonFile.load(packageJsonPath);
                if (packageJson.name.match(/^@microsoft\/rush-stack-compiler-[0-9\.]+$/)) {
                    const packagePath = path.dirname(packageJsonPath);
                    this._terminal.writeVerboseLine(`Found rush-stack compiler at ${packagePath}/`);
                    return packagePath;
                }
            }
            throw new Error('Rush Stack determines your TypeScript compiler by following the "extends" field in your tsconfig.json ' +
                'file, until it reaches a package folder that depends on a variant of @microsoft/rush-stack-compiler-*. ' +
                `This lookup failed when it reached this file: ${tsconfigPath}`);
        }
        // Follow the tsconfig.extends field:
        let baseTsconfigPath;
        let extendsPathKind;
        if (path.isAbsolute(tsconfig.extends)) {
            // Absolute path
            baseTsconfigPath = tsconfig.extends;
            extendsPathKind = 'an absolute path';
        }
        else if (tsconfig.extends.match(/^\./)) {
            // Relative path
            baseTsconfigPath = path.resolve(path.dirname(tsconfigPath), tsconfig.extends);
            extendsPathKind = 'a relative path';
        }
        else {
            // Package path
            baseTsconfigPath = resolve.sync(tsconfig.extends, {
                basedir: this.buildConfig.rootPath,
                packageFilter: (pkg) => {
                    return Object.assign({}, pkg, { main: 'package.json' });
                }
            });
            extendsPathKind = 'a package path';
        }
        this._terminal.writeVerboseLine(`Found tsconfig.extends property ${tsconfig.extends}. It appears ` +
            `to be ${extendsPathKind}. Resolved to ${baseTsconfigPath}`);
        if (visitedTsconfigPaths.has(baseTsconfigPath)) {
            throw new Error(`The file "${baseTsconfigPath}" has an "extends" field that creates a circular reference`);
        }
        return this._resolveRushStackCompilerFromTsconfig(baseTsconfigPath, visitedTsconfigPaths);
    }
}
// For a given folder that contains a tsconfig.json file, return the absolute path of the folder
// containing "@microsoft/rush-stack-compiler-*"
RSCTask._rushStackCompilerPackagePathCache = new Map();
exports.RSCTask = RSCTask;
//# sourceMappingURL=RSCTask.js.map