"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const gulp_core_build_1 = require("@microsoft/gulp-core-build");
const os_1 = require("os");
/**
 * @public
 */
class WebpackTask extends gulp_core_build_1.GulpTask {
    constructor(extendedName, extendedConfig) {
        super(extendedName || 'webpack', Object.assign({ configPath: './webpack.config.js', suppressWarnings: [], printStats: true }, extendedConfig) // tslint:disable-line:no-any
        );
    }
    get resources() {
        if (!this._resources) {
            this._resources = {
                webpack: this.taskConfig.webpack || require('webpack')
            };
        }
        return this._resources;
    }
    isEnabled(buildConfig) {
        return (super.isEnabled(buildConfig) &&
            this.taskConfig.configPath !== null // tslint:disable-line:no-null-keyword
        );
    }
    loadSchema() {
        return require('./webpack.schema.json');
    }
    executeTask(gulp, completeCallback) {
        const shouldInitWebpack = (process.argv.indexOf('--initwebpack') > -1);
        /* tslint:disable:typedef */
        const path = require('path');
        /* tslint:enabled:typedef */
        if (shouldInitWebpack) {
            this.log('Initializing a webpack.config.js, which bundles lib/index.js ' +
                'into dist/packagename.js into a UMD module.');
            this.copyFile(path.resolve(__dirname, 'webpack.config.js'));
            completeCallback();
        }
        else {
            let webpackConfig;
            if (this.taskConfig.configPath && this.fileExists(this.taskConfig.configPath)) {
                try {
                    webpackConfig = require(this.resolvePath(this.taskConfig.configPath));
                }
                catch (err) {
                    completeCallback(`Error parsing webpack config: ${this.taskConfig.configPath}: ${err}`);
                    return;
                }
            }
            else if (this.taskConfig.config) {
                webpackConfig = this.taskConfig.config;
            }
            else {
                this._logMissingConfigWarning();
                completeCallback();
                return;
            }
            if (webpackConfig) {
                const webpack = this.taskConfig.webpack || require('webpack');
                const startTime = new Date().getTime();
                const outputDir = this.buildConfig.distFolder;
                webpack(webpackConfig, (error, stats) => {
                    if (!this.buildConfig.properties) {
                        this.buildConfig.properties = {};
                    }
                    /* tslint:disable:no-string-literal */
                    this.buildConfig.properties['webpackStats'] = stats;
                    /* tslint:enable:no-string-literal */
                    const statsResult = stats.toJson({
                        hash: false,
                        source: false
                    });
                    if (statsResult.errors && statsResult.errors.length) {
                        this.logError(`'${outputDir}':` + os_1.EOL + statsResult.errors.join(os_1.EOL) + os_1.EOL);
                    }
                    if (statsResult.warnings && statsResult.warnings.length) {
                        const unsuppressedWarnings = [];
                        const warningSuppressionRegexes = (this.taskConfig.suppressWarnings || []).map((regex) => {
                            return new RegExp(regex);
                        });
                        statsResult.warnings.forEach((warning) => {
                            let suppressed = false;
                            for (let i = 0; i < warningSuppressionRegexes.length; i++) {
                                const suppressionRegex = warningSuppressionRegexes[i];
                                if (warning.match(suppressionRegex)) {
                                    suppressed = true;
                                    break;
                                }
                            }
                            if (!suppressed) {
                                unsuppressedWarnings.push(warning);
                            }
                        });
                        if (unsuppressedWarnings.length > 0) {
                            this.logWarning(`'${outputDir}':` + os_1.EOL + unsuppressedWarnings.join(os_1.EOL) + os_1.EOL);
                        }
                    }
                    const duration = (new Date().getTime() - startTime);
                    const statsResultChildren = statsResult.children ? statsResult.children : [statsResult];
                    statsResultChildren.forEach(child => {
                        if (child.chunks) {
                            child.chunks.forEach(chunk => {
                                if (chunk.files && this.taskConfig.printStats) {
                                    chunk.files.forEach(file => (this.log(`Bundled: '${colors.cyan(path.basename(file))}', ` +
                                        `size: ${colors.magenta(chunk.size.toString())} bytes, ` +
                                        `took ${colors.magenta(duration.toString(10))} ms.`))); // end file
                                }
                            }); // end chunk
                        }
                    }); // end child
                    completeCallback();
                }); // endwebpack callback
            }
        }
    }
    _logMissingConfigWarning() {
        this.logWarning('No webpack config has been provided. ' +
            'Run again using --initwebpack to create a default config, ' +
            `or call webpack.setConfig({ configPath: null }) in your gulpfile.`);
    }
}
exports.WebpackTask = WebpackTask;
//# sourceMappingURL=WebpackTask.js.map