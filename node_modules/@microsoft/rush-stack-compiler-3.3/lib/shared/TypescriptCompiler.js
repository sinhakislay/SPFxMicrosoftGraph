"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const CmdRunner_1 = require("./CmdRunner");
const ToolPaths_1 = require("./ToolPaths");
const RushStackCompilerBase_1 = require("./RushStackCompilerBase");
const LoggingUtilities_1 = require("./LoggingUtilities");
/**
 * @beta
 */
class TypescriptCompiler extends RushStackCompilerBase_1.RushStackCompilerBase {
    constructor(arg1, arg2, arg3) {
        let taskOptions = undefined;
        let rootPath;
        let terminalProvider;
        if (typeof arg1 === 'string') {
            rootPath = arg1;
            terminalProvider = arg2;
        }
        else {
            taskOptions = arg1;
            rootPath = arg2;
            terminalProvider = arg3;
        }
        const loggingUtilities = new LoggingUtilities_1.LoggingUtilities(terminalProvider);
        if (taskOptions) {
            if (!taskOptions.fileError) {
                taskOptions.fileError = loggingUtilities.fileError;
            }
            if (!taskOptions.fileWarning) {
                taskOptions.fileWarning = loggingUtilities.fileWarning;
            }
        }
        else {
            taskOptions = loggingUtilities.getDefaultRushStackCompilerBaseOptions();
        }
        super(taskOptions, rootPath, terminalProvider);
        this._cmdRunner = new CmdRunner_1.CmdRunner(this._standardBuildFolders, this._terminal, {
            packagePath: ToolPaths_1.ToolPaths.typescriptPackagePath,
            packageJson: ToolPaths_1.ToolPaths.typescriptPackageJson,
            packageBinPath: path.join('bin', 'tsc')
        });
    }
    invoke() {
        return this._cmdRunner.runCmd({
            args: this._taskOptions.customArgs || [],
            onData: (data) => {
                // Log lines separately
                const dataLines = data.toString().split('\n');
                for (const dataLine of dataLines) {
                    const trimmedLine = (dataLine || '').trim();
                    if (!!trimmedLine) {
                        if (trimmedLine.match(/\serror\s/i)) {
                            // If the line looks like an error, log it as an error
                            this._terminal.writeErrorLine(trimmedLine);
                        }
                        else {
                            this._terminal.writeLine(trimmedLine);
                        }
                    }
                }
            }
        });
    }
}
exports.TypescriptCompiler = TypescriptCompiler;
//# sourceMappingURL=TypescriptCompiler.js.map