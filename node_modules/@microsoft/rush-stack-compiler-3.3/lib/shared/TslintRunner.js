"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const CmdRunner_1 = require("./CmdRunner");
const ToolPaths_1 = require("./ToolPaths");
const RushStackCompilerBase_1 = require("./RushStackCompilerBase");
/**
 * @beta
 */
class TslintRunner extends RushStackCompilerBase_1.RushStackCompilerBase {
    constructor(taskOptions, rootPath, terminalProvider) {
        super(taskOptions, rootPath, terminalProvider);
        this._cmdRunner = new CmdRunner_1.CmdRunner(this._standardBuildFolders, this._terminal, {
            packagePath: ToolPaths_1.ToolPaths.tslintPackagePath,
            packageJson: ToolPaths_1.ToolPaths.tslintPackageJson,
            packageBinPath: path.join('bin', 'tslint')
        });
    }
    invoke() {
        const args = [
            '--format', 'json',
            '--project', this._standardBuildFolders.projectFolderPath
        ];
        return this._cmdRunner.runCmd({
            args: args,
            onData: (data) => {
                const dataStr = data.toString().trim();
                const tslintErrorLogFn = this._taskOptions.displayAsError
                    ? this._taskOptions.fileError
                    : this._taskOptions.fileWarning;
                // TSLint errors are logged to stdout
                try {
                    const errors = JSON.parse(dataStr);
                    for (const error of errors) {
                        const pathFromRoot = path.relative(this._standardBuildFolders.projectFolderPath, error.name);
                        tslintErrorLogFn(pathFromRoot, error.startPosition.line + 1, error.startPosition.character + 1, error.ruleName, error.failure);
                    }
                }
                catch (e) {
                    // If we fail to parse the JSON, it's likely TSLint encountered an error parsing the config file,
                    // or it experienced an inner error. In this case, log the output as an error regardless of the
                    // displayAsError value
                    this._terminal.writeErrorLine(dataStr);
                }
            },
            onClose: (code, hasErrors, resolve, reject) => {
                if (this._taskOptions.displayAsError && (code !== 0 || hasErrors)) {
                    reject(new Error(`exited with code ${code}`));
                }
                else {
                    resolve();
                }
            }
        });
    }
}
exports.TslintRunner = TslintRunner;
//# sourceMappingURL=TslintRunner.js.map