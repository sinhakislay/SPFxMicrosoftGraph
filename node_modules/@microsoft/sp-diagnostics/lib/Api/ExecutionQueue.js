/**
 * @copyright Microsoft Corporation. All rights reserved.
 */
/**
 * ExecutionQueue allows multiple handlers to be processed in real time or deferred.
 * @internal
 */
var ExecutionQueue = /** @class */ (function () {
    function ExecutionQueue() {
        this._shouldExecuteInRealTime = false;
        this._handlers = {}; // tslint:disable-line:typedef
        this._executionEntries = [];
    }
    Object.defineProperty(ExecutionQueue.prototype, "shouldExecuteInRealTime", {
        /**
         * Determines if the added execution entries should be processed in real time.
         * If this is set to true, a stack with entries will not be saved.
         */
        get: function () {
            return this._shouldExecuteInRealTime;
        },
        /**
         * Sets the behavior for this execution stack.
         * When set to true, all entries on stack will be processed and future entries
         * will be executed in real time.
         * When set to false, future entries will be saved in the execution stack for
         * later processing.
         */
        set: function (executeInRealTime) {
            this._shouldExecuteInRealTime = executeInRealTime;
            if (this._shouldExecuteInRealTime) {
                this.flush();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Registers an external handler to collection for delayed asyncronous processing.
     * Handlers are registered once. If handler is already registered, it does nothing.
     */
    ExecutionQueue.prototype.addHandler = function (key, handler) {
        if (this._containsHandler(key, handler)) {
            return;
        }
        this._initializeHandlerArrayForKey(key);
        var handlers = this._handlers[key]; // tslint:disable-line:no-any
        if (handlers.indexOf(handler) === -1) {
            handlers.push(handler);
        }
    };
    /**
     * Execution Entry registration for delayed asyncronous processing.
     */
    ExecutionQueue.prototype.addExecutionEntry = function (key) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        Object.freeze(args);
        if (this._shouldExecuteInRealTime) {
            this._processExecutionEntry(key, args);
        }
        else {
            this._executionEntries.push({ key: key, args: args });
        }
    };
    /**
     * Removes an external executionEntry handler from collection for asyncronous event logging.
     * Logger is registered once.
     */
    ExecutionQueue.prototype.removeHandler = function (key, handler) {
        var index = this._handlers[key].indexOf(handler);
        if (index > -1) {
            this._handlers[key].splice(index, 1);
        }
    };
    /**
     * Reset function clears executionEntry handler collection for asyncronous event logging.
     * All recorded execution entries and handlers are purged.
     */
    ExecutionQueue.prototype.reset = function () {
        this._handlers = {};
        this._executionEntries = [];
    };
    /**
     * Flushes all the buffered execution entries.
     * All recorded execution entries are purged.
     */
    ExecutionQueue.prototype.flush = function () {
        this._processAllExecutionEntries();
        this._executionEntries = [];
    };
    ExecutionQueue.prototype._containsHandler = function (key, handler) {
        if (this._handlers[key] !== null && this._handlers[key] !== undefined) {
            return this._handlers[key].indexOf(handler) > -1;
        }
        return false;
    };
    ExecutionQueue.prototype._initializeHandlerArrayForKey = function (key) {
        if (this._handlers[key] === null || this._handlers[key] === undefined) {
            this._handlers[key] = [];
        }
    };
    ExecutionQueue.prototype._processAllExecutionEntries = function () {
        var _this = this;
        this._executionEntries.forEach(function (entry) {
            if (entry && _this._handlers[entry.key]) {
                try {
                    _this._handlers[entry.key].forEach(function (handler) {
                        handler.apply(_this, entry.args);
                    });
                }
                catch (e) {
                    console.error('failed to process execution entry:' + e.toString());
                }
            }
        });
    };
    ExecutionQueue.prototype._processExecutionEntry = function (key, args) {
        for (var i = 0; i < this._handlers[key].length; i++) {
            try {
                this._handlers[key][i].apply(this, args);
            }
            catch (e) {
                console.error('failed to process execution entry:' + e.toString());
            }
        }
    };
    return ExecutionQueue;
}());
export default ExecutionQueue;
//# sourceMappingURL=ExecutionQueue.js.map