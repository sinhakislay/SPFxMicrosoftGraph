import ILogEntry from '../ILogEntry';
import ILogSource from '../ILogSource';
import ILogErrorData from '../ILogErrorData';
import ILogVerboseData from '../ILogVerboseData';
import { ITraceHandler, ITraceLogEvent, IVerboseTraceLogEvent } from './ITraceHandler';
import LogManager from './../LogManager/LogManager';
/**
 * This is used to log traces of failed operations and debugging information.
 * @internal
 */
export default class TraceLogger {
    /**
     * Allows process trace log events.
     */
    static _logManager: LogManager<ITraceLogEvent>;
    /**
     * Allows process verbose trace log events.
     */
    static _verboseLogManager: LogManager<IVerboseTraceLogEvent>;
    private static _defaultLogger;
    private static _shouldWriteToConsole;
    /**
     * Init function for the passed logger object
     *
     * @internal
     */
    static _addHandler(logger: ITraceHandler): void;
    /**
     * Exception logging
     * This shoule be used whenever you want to log something that might in future help to debug failures.
     * The error parameter is the only required one and basically will be just converted to string and
     * logged to Debug stream (RealibilityLogs in SLAPI).
     * It will also be uploaded to the server immediately and not wait for next batch log upload.
     * If you don't specify second parameter:eventName
     * the event name for all errors logged that way will be same "CaughtError" with
     * appropriate prefix ("ModernPublish.CaughtError" etc.)
     * These two parameters "eventName and resultCode" are there to be used from Qos.
     * It is not encouraged to use them directly from ErrorHelper but if you do,
     * the log will be written with custom event name of following format:
     * <Workload>.<eventName>.<resultCode>.Failure, Workload is set in Telemetry settings.
     **/
    static logError(source: ILogSource, error: Error, eventName?: string, resultCode?: string): void;
    /**
     * Exception logging intended to replace to logError.
     *
     * @remarks
     * Uses the `ILogErrorData` interface to prevent excessive undefined parameters
     * when calling this function.
     * This should be used whenever you want to log something that might in future help to
     * debug failures.
     * It will also be uploaded to the server immediately and not wait for next batch log upload.
     */
    static logErrorData(data: ILogErrorData): void;
    /**
     * Trace logging
     * The idea here is that verbose logs don't get uploaded to the server unless
     * a failure is logged using ErrorHelper.log method.
     * There is a circular buffer that holds last 50 verbose logs from all scenarios and
     * it is only flushed and uploaded in case a failure is logged.
     * That way whenever you get a failure event with message you also have all supportive verbose messages
     * you logged throughout your scenario execution (or other scenarios).
     * And hopefully that would help you get to the bottom of what exactly went wrong.
     * If no failure happens and your scenario succeeds, verbose logs will be just left in the buffer
     * and most likely overriden by next scenario that logs something verbose.
    **/
    static logVerbose(source: ILogSource, message: string, eventName?: string): void;
    /**
     * Verbose logging intended to replace to logVerbose.
     * The idea here is that verbose logs don't get uploaded to the server unless
     * a failure is logged using ErrorHelper.log method.
     * There is a circular buffer that holds last 50 verbose logs from all scenarios and
     * it is only flushed and uploaded in case a failure is logged.
     * That way whenever you get a failure event with message you also have all supportive verbose messages
     * you logged throughout your scenario execution (or other scenarios).
     * And hopefully that would help you get to the bottom of what exactly went wrong.
     * If no failure happens and your scenario succeeds, verbose logs will be just left in the buffer
     * and most likely overriden by next scenario that logs something verbose.
     */
    static logVerboseData(data: ILogVerboseData): void;
    /**
     * Exception logging With LogEntry
     * error message should be packed into logProperties
     * LogType should be LogType.Error and LogProperties should have `{error:errorMessage}`
     * Do NOT add PII data!
     **/
    static logErrorWithLogEntry(source: ILogSource, logEntry: ILogEntry, eventName?: string, resultCode?: string): void;
    /**
     * Indicates if the log entries should be output to the console.
     * This flag is set to true by default.
     */
    /**
    * Toggles console output functionality.
    * Property can be chaged by remote caller.
    */
    static shouldWriteToConsole: boolean;
    static logVerboseWithLogEntry(source: ILogSource, logEntry: ILogEntry, eventName?: string): void;
    private static _log;
    private static _addEventPrefix;
    private static _writeToConsole;
}
//# sourceMappingURL=TraceLogger.d.ts.map