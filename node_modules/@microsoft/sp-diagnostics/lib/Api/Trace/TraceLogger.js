import { Validate } from '@microsoft/sp-core-library';
import LogEvent from './LogEvent';
import { LogLevel } from '../LogLevel';
import DefaultTraceHandler from './DefaultTraceHandler';
import LogManager from './../LogManager/LogManager';
/**
 * This is used to log traces of failed operations and debugging information.
 * @internal
 */
var TraceLogger = /** @class */ (function () {
    function TraceLogger() {
    }
    /**
     * Init function for the passed logger object
     *
     * @internal
     */
    TraceLogger._addHandler = function (logger) {
        TraceLogger._logManager.addHandler(logger.log);
        TraceLogger._logManager.processAll(logger.log);
        TraceLogger._verboseLogManager.addHandler(logger.verbose);
        TraceLogger._verboseLogManager.processAll(logger.verbose);
    };
    /**
     * Exception logging
     * This shoule be used whenever you want to log something that might in future help to debug failures.
     * The error parameter is the only required one and basically will be just converted to string and
     * logged to Debug stream (RealibilityLogs in SLAPI).
     * It will also be uploaded to the server immediately and not wait for next batch log upload.
     * If you don't specify second parameter:eventName
     * the event name for all errors logged that way will be same "CaughtError" with
     * appropriate prefix ("ModernPublish.CaughtError" etc.)
     * These two parameters "eventName and resultCode" are there to be used from Qos.
     * It is not encouraged to use them directly from ErrorHelper but if you do,
     * the log will be written with custom event name of following format:
     * <Workload>.<eventName>.<resultCode>.Failure, Workload is set in Telemetry settings.
     **/
    TraceLogger.logError = function (source, error, eventName, resultCode) {
        Validate.isNotNullOrUndefined(error, 'error');
        this._log(source, error, eventName, true, resultCode);
    };
    /**
     * Exception logging intended to replace to logError.
     *
     * @remarks
     * Uses the `ILogErrorData` interface to prevent excessive undefined parameters
     * when calling this function.
     * This should be used whenever you want to log something that might in future help to
     * debug failures.
     * It will also be uploaded to the server immediately and not wait for next batch log upload.
     */
    TraceLogger.logErrorData = function (data) {
        Validate.isNotNullOrUndefined(data.error, 'error');
        var errorInfo = data.logEntry ? data.logEntry.toString() : data.error;
        this._log(data.source, errorInfo, data.eventName, true, data.resultCode, data.serviceScope);
    };
    /**
     * Trace logging
     * The idea here is that verbose logs don't get uploaded to the server unless
     * a failure is logged using ErrorHelper.log method.
     * There is a circular buffer that holds last 50 verbose logs from all scenarios and
     * it is only flushed and uploaded in case a failure is logged.
     * That way whenever you get a failure event with message you also have all supportive verbose messages
     * you logged throughout your scenario execution (or other scenarios).
     * And hopefully that would help you get to the bottom of what exactly went wrong.
     * If no failure happens and your scenario succeeds, verbose logs will be just left in the buffer
     * and most likely overriden by next scenario that logs something verbose.
    **/
    TraceLogger.logVerbose = function (source, message, eventName) {
        Validate.isNonemptyString(message, 'message');
        this._log(source, message, eventName, false, undefined);
    };
    /**
     * Verbose logging intended to replace to logVerbose.
     * The idea here is that verbose logs don't get uploaded to the server unless
     * a failure is logged using ErrorHelper.log method.
     * There is a circular buffer that holds last 50 verbose logs from all scenarios and
     * it is only flushed and uploaded in case a failure is logged.
     * That way whenever you get a failure event with message you also have all supportive verbose messages
     * you logged throughout your scenario execution (or other scenarios).
     * And hopefully that would help you get to the bottom of what exactly went wrong.
     * If no failure happens and your scenario succeeds, verbose logs will be just left in the buffer
     * and most likely overriden by next scenario that logs something verbose.
     */
    TraceLogger.logVerboseData = function (data) {
        var message = data.logEntry ? data.logEntry.toString() : data.message;
        this._log(data.source, message, data.eventName, false, undefined, data.serviceScope);
    };
    /**
     * Exception logging With LogEntry
     * error message should be packed into logProperties
     * LogType should be LogType.Error and LogProperties should have `{error:errorMessage}`
     * Do NOT add PII data!
     **/
    TraceLogger.logErrorWithLogEntry = function (source, logEntry, eventName, resultCode) {
        Validate.isNotNullOrUndefined(source, 'source');
        Validate.isNotNullOrUndefined(logEntry, 'logEntry');
        this._log(source, logEntry.toString(), eventName, true, resultCode);
    };
    Object.defineProperty(TraceLogger, "shouldWriteToConsole", {
        /**
         * Indicates if the log entries should be output to the console.
         * This flag is set to true by default.
         */
        get: function () { return TraceLogger._shouldWriteToConsole; },
        /**
         * Toggles console output functionality.
         * Property can be chaged by remote caller.
         */
        set: function (shouldWrite) {
            if (TraceLogger._shouldWriteToConsole && !shouldWrite) {
                TraceLogger._logManager.removeHandler(TraceLogger._defaultLogger.log);
                TraceLogger._verboseLogManager.removeHandler(TraceLogger._defaultLogger.verbose);
            }
            else if (!TraceLogger._shouldWriteToConsole && shouldWrite) {
                TraceLogger._logManager.addHandler(TraceLogger._defaultLogger.log);
                TraceLogger._verboseLogManager.addHandler(TraceLogger._defaultLogger.verbose);
            }
            TraceLogger._shouldWriteToConsole = shouldWrite;
        },
        enumerable: true,
        configurable: true
    });
    /*
    * Trace logging with `LogEntry`
    * The same with above other than wrapped log into `logEntry`
    * Trace message should be packed into `logProperties`
    * `LogType` should be `LogType.Trace` and LogProperties should have something like `{errors:errorMessage}`
    * Do NOT add PII data!
    **/
    TraceLogger.logVerboseWithLogEntry = function (source, logEntry, eventName) {
        Validate.isNotNullOrUndefined(logEntry, 'LogEntry');
        this._log(source, logEntry.toString(), eventName, false, undefined);
    };
    TraceLogger._log = function (source, data, eventName, isError, resultCode, serviceScope) {
        var enhancedEventName = this._addEventPrefix(source, eventName);
        var logEvent;
        if (isError) {
            logEvent = LogEvent.log(enhancedEventName, data, LogLevel.Error, serviceScope);
            TraceLogger._logManager.log({ data: data, eventName: logEvent.prefix, resultCode: resultCode });
        }
        else {
            logEvent = LogEvent.log(enhancedEventName, data.toString(), LogLevel.Verbose, serviceScope);
            TraceLogger._verboseLogManager.log({ data: data, eventName: logEvent.prefix });
        }
        if (TraceLogger.shouldWriteToConsole || (DEBUG && !DEPRECATED_UNIT_TEST)) {
            this._writeToConsole(logEvent, isError, resultCode);
        }
    };
    /*
    * EventName is:
    * sourceId.eventName or sourceId if eventName is not provided.
    */
    TraceLogger._addEventPrefix = function (source, eventName) {
        if (!eventName) {
            return source.id;
        }
        else {
            return source.id + "." + eventName;
        }
    };
    /*
    * The log message in console is:
    * `[eventName]: data`.
    */
    TraceLogger._writeToConsole = function (logEvent, isError, resultCode) {
        // @todo (SPPPLAT VSO#250083): This date should be a part of the logEvent.
        var errorString = logEvent.toString();
        if (resultCode) {
            errorString += ". resultCode: " + resultCode;
        }
        // Task 191596: only write to console when a condition is satisfied (e.g., a query parameter provided).
        if (isError) {
            console.error(errorString);
        }
        else {
            console.log(errorString);
        }
    };
    /**
     * Allows process trace log events.
     */
    TraceLogger._logManager = new LogManager();
    /**
     * Allows process verbose trace log events.
     */
    TraceLogger._verboseLogManager = new LogManager();
    TraceLogger._defaultLogger = new DefaultTraceHandler();
    TraceLogger._shouldWriteToConsole = false;
    return TraceLogger;
}());
export default TraceLogger;
//# sourceMappingURL=TraceLogger.js.map