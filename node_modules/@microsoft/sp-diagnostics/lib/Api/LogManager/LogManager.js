/**
 * @copyright Microsoft Corporation. All rights reserved.
 */
import CircularBuffer from './CircularBuffer';
/**
 * LogManager allows multiple handlers to process log events.
 * It caches the latest 5000 log events. If a handler is just added, the
 * handler is able to get access to the cached events and all incoming events.
 * Dev-dashboard and potentially third-party can use it to get access to events.
 * @internal
 */
var LogManager = /** @class */ (function () {
    function LogManager(initialHandler) {
        this._shouldLogInRealTime = [];
        this._handlers = [];
        this._events = new CircularBuffer(LogManager._maxVerboseLog);
        if (initialHandler) {
            this.addHandler(initialHandler);
        }
    }
    Object.defineProperty(LogManager, "_maxVerboseLog", {
        get: function () {
            return 5000;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogManager.prototype, "events", {
        /**
         * Event list for delayed asynchronous processing.
         * Events are accumulated in CircularBuffer for processing later.
         */
        get: function () {
            return this._events;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Registers an external logger to logger collection for asynchronous event logging.
     * Logger is registered once.
     */
    LogManager.prototype.addHandler = function (handler) {
        if (!this._containsHandler(handler)) {
            this._handlers.push(handler);
            this._shouldLogInRealTime.push(false);
        }
    };
    /**
     * Event logging operation for delayed asynchronous processing.
     */
    LogManager.prototype.log = function (event) {
        Object.freeze(event);
        this._events.push(event);
        this._processLogEvent(event);
    };
    /**
     * Removes an external logger from logger collection for asynchronous event logging.
     * Logger is registered once.
     */
    LogManager.prototype.removeHandler = function (handler) {
        var index = this._handlers.indexOf(handler);
        if (index > -1) {
            this._handlers.splice(index, 1);
            this._shouldLogInRealTime.splice(index, 1);
        }
    };
    /**
     * Reset function clears logger collection for asynchronous event logging.
     * All recorded events are purged.
     */
    LogManager.prototype.reset = function () {
        this._handlers = [];
        this._shouldLogInRealTime = [];
        this._events.removeAll();
    };
    /**
     * Processes all the buffered events using the registered handler.
     */
    LogManager.prototype.processAll = function (handler) {
        if (this._handlers.indexOf(handler) > -1) {
            this._processAllEvents(handler);
        }
    };
    LogManager.prototype._containsHandler = function (handler) {
        for (var _i = 0, _a = this._handlers; _i < _a.length; _i++) {
            var existingHandler = _a[_i];
            if (existingHandler === handler) {
                return true;
            }
        }
        return false;
    };
    LogManager.prototype._processAllEvents = function (handler) {
        this._events.forEach(function (event) {
            if (event) {
                try {
                    handler(event);
                }
                catch (e) {
                    console.error('failed to handle event:' + e.toString());
                }
            }
        });
        this._shouldLogInRealTime[this._handlers.indexOf(handler)] = true;
    };
    LogManager.prototype._processLogEvent = function (event) {
        for (var i = 0; i < this._handlers.length; i++) {
            if (this._shouldLogInRealTime[i] && event) {
                try {
                    this._handlers[i](event);
                }
                catch (e) {
                    console.error('failed to handle event:' + e.toString());
                }
            }
        }
    };
    return LogManager;
}());
export default LogManager;
//# sourceMappingURL=LogManager.js.map