import { ServiceScope, ISPEventObserver } from '@microsoft/sp-core-library';
import { IClientSideComponentManifest } from '@microsoft/sp-module-interfaces';
import BaseComponentContext from './BaseComponentContext';
/**
 * The base class for client-side components such as BaseClientSideWebPart or BaseExtension.
 *
 * @public
 */
export default abstract class BaseComponent implements ISPEventObserver {
    /**
     * Use the context object to access common services and state associated with the component.
     *
     * @remarks
     *
     * Child classes are expected to override this field by redeclaring it with a specialized type.
     * It is meant to be a read-only property; the type cannot be declared as read-only in the base class
     * (because it is initialized outside the constructor), but child classes should redeclare
     * it as readonly.
     *
     * @privateRemarks
     *
     * This is a workaround for a missing compiler feature.  If the compiler issue is resolved,
     * then we can convert "context" to an ordinary property getter.
     * https://github.com/Microsoft/TypeScript/issues/338
     */
    protected context: BaseComponentContext;
    private _isDisposed;
    /**
     * Returns the dynamic data source id for the current instance of the component.
     *
     * @internal
     */
    readonly _dynamicDataSourceId: string;
    /** @internal */
    constructor();
    /**
     * Disposes the component.
     *
     * @remarks
     * Third-party code generally does not need to call this method; it's invoked
     * automatically when the lifecycle ends for a web part or extension.  To perform
     * custom cleanup when your component is disposed, override the {@link BaseComponent.onDispose}
     * method.
     */
    dispose(): void;
    /**
     * Returns true if the component has been already disposed.
     */
    readonly isDisposed: boolean;
    /**
     * Provides access to the manifest for the client-side component.
     * @remarks
     * Child classes can override this with more specialized manifest types.
     */
    readonly manifest: IClientSideComponentManifest;
    /**
     * This event method is called at the end of the component's lifecycle.
     * It provides an opportunity to release any associated resources, cancel any
     * outstanding requests, etc.
     */
    protected onDispose(): void;
    /**
     * A unique identifier for the instance of the component.
     *
     * @remarks
     * A component implementation can be loaded multiple times on the page.
     * For example, if the component is a charting web part, multiple instances of this web part
     * could be added to the SharePoint canvas.  The instanceId uniquely identifies each
     * of these instances.
     */
    readonly instanceId: string;
    /**
     * Returns the component identifier as defined in the componentâ€™s associated manifest.
     *
     * @remarks
     * Each client-side component has an associated manifest that is used by the sp-loader to load its scripts,
     * and which may include additional metadata about the component.  The manifest is uniquely identified using
     * a text string containing a lower case GUID value.
     */
    readonly componentId: string;
    /**
     * @internal
     */
    protected _initializeContext(context: BaseComponentContext): void;
    /**
     * This event method allows a component to add custom services to its
     * {@link @microsoft/sp-core-library#ServiceScope}.
     *
     * @remarks
     * This event method is fired before {@link @microsoft/sp-core-library#ServiceScope | ServiceScope.finish()}
     * is called, allowing the component to provide custom services.
     *
     * @alpha
     */
    protected onProvideServices(serviceScope: ServiceScope): void;
}
//# sourceMappingURL=BaseComponent.d.ts.map