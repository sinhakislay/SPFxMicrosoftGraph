var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { virtual } from '@microsoft/decorators';
import Killswitches from './common/KillSwitches';
/**
 * The base class for client-side components such as BaseClientSideWebPart or BaseExtension.
 *
 * @public
 */
var BaseComponent = /** @class */ (function () {
    /** @internal */
    function BaseComponent() {
        this._isDisposed = false;
        // empty block
    }
    Object.defineProperty(BaseComponent.prototype, "_dynamicDataSourceId", {
        /**
         * Returns the dynamic data source id for the current instance of the component.
         *
         * @internal
         */
        get: function () {
            return this.manifest.componentType + "." + this.manifest.id + "." + this.instanceId;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes the component.
     *
     * @remarks
     * Third-party code generally does not need to call this method; it's invoked
     * automatically when the lifecycle ends for a web part or extension.  To perform
     * custom cleanup when your component is disposed, override the {@link BaseComponent.onDispose}
     * method.
     */
    BaseComponent.prototype.dispose = function () {
        if (!this._isDisposed) {
            this.onDispose();
            this.context.dispose();
            delete this.context;
            this._isDisposed = true;
        }
    };
    Object.defineProperty(BaseComponent.prototype, "isDisposed", {
        /**
         * Returns true if the component has been already disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseComponent.prototype, "manifest", {
        /**
         * Provides access to the manifest for the client-side component.
         * @remarks
         * Child classes can override this with more specialized manifest types.
         */
        get: function () {
            return this.context.manifest;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * This event method is called at the end of the component's lifecycle.
     * It provides an opportunity to release any associated resources, cancel any
     * outstanding requests, etc.
     */
    BaseComponent.prototype.onDispose = function () {
        // (empty block)
    };
    Object.defineProperty(BaseComponent.prototype, "instanceId", {
        /**
         * A unique identifier for the instance of the component.
         *
         * @remarks
         * A component implementation can be loaded multiple times on the page.
         * For example, if the component is a charting web part, multiple instances of this web part
         * could be added to the SharePoint canvas.  The instanceId uniquely identifies each
         * of these instances.
         */
        get: function () { return this.context.instanceId; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseComponent.prototype, "componentId", {
        /**
         * Returns the component identifier as defined in the componentâ€™s associated manifest.
         *
         * @remarks
         * Each client-side component has an associated manifest that is used by the sp-loader to load its scripts,
         * and which may include additional metadata about the component.  The manifest is uniquely identified using
         * a text string containing a lower case GUID value.
         */
        get: function () { return this.context.manifest.id; },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal
     */
    BaseComponent.prototype._initializeContext = function (context) {
        this.context = context;
        this.onProvideServices(context.serviceScope);
        if (!Killswitches.isPreallocatedPlaceholdersforApplicationCustomizersKSActive()) {
            /*
             * Calling finish on an already finished servicescope will throw.
             * Hence, checking it before finishing the servicescope.
             *
             * In the case of ApplicationCustomizers, it's context is calling 'finish'
             * on the service scope. Hence, it is required to have the below check.
             */
            if (!context.serviceScope._isFinished) {
                context.serviceScope.finish();
            }
        }
        else {
            context.serviceScope.finish();
        }
        this.context._initializeDynamicData(this, context.serviceScope);
    };
    /**
     * This event method allows a component to add custom services to its
     * {@link @microsoft/sp-core-library#ServiceScope}.
     *
     * @remarks
     * This event method is fired before {@link @microsoft/sp-core-library#ServiceScope | ServiceScope.finish()}
     * is called, allowing the component to provide custom services.
     *
     * @alpha
     */
    BaseComponent.prototype.onProvideServices = function (serviceScope) {
        // empty block
    };
    __decorate([
        virtual
    ], BaseComponent.prototype, "manifest", null);
    __decorate([
        virtual
    ], BaseComponent.prototype, "onDispose", null);
    __decorate([
        virtual
    ], BaseComponent.prototype, "onProvideServices", null);
    return BaseComponent;
}());
export default BaseComponent;
//# sourceMappingURL=BaseComponent.js.map