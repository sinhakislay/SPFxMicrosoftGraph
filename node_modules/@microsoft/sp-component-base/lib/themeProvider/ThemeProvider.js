var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { ServiceKey, SPEvent, SPEventArgs, _SPEventManager, Validate } from '@microsoft/sp-core-library';
/**
 * The object passed when the IThemeProvider.themeChangedEvent is raised.
 *
 * @public
 */
var ThemeChangedEventArgs = /** @class */ (function (_super) {
    __extends(ThemeChangedEventArgs, _super);
    function ThemeChangedEventArgs() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ThemeChangedEventArgs;
}(SPEventArgs));
export { ThemeChangedEventArgs };
/**
 * The ThemeProvider class provides the capability to get different themes from the Framework. Themes can be provided
 * in different contexts, e.g. Canvas sections may provide a variant of the global theme in some contexts.
 *
 * @public
 */
var ThemeProvider = /** @class */ (function () {
    /**
     * Construct a new instance of the ThemeProvider class.
     *
     * @param serviceScope - The current service scope.
     * @param theme - Theme to provide.
     */
    function ThemeProvider(serviceScope, theme) {
        this._id = ThemeProvider._instanceCount++;
        this.themeChangedEvent = new SPEvent(this._themeChangedEventName);
        if (theme) {
            this._theme = Object.freeze(theme);
        }
    }
    Object.defineProperty(ThemeProvider.prototype, "_themeChangedEventName", {
        get: function () {
            return ThemeProvider._themeChangedEventNameLiteral + this._id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clear the currently set theme and raise the themeChangedEvent.
     *
     * @internal
     */
    ThemeProvider.prototype._clearTheme = function () {
        this._theme = undefined;
        this._raiseEvent();
    };
    /**
     * Change the theme and raise the themeChangedEvent.
     *
     * @param theme - The new theme.
     *
     * @internal
     */
    ThemeProvider.prototype._setTheme = function (theme) {
        Validate.isNotNullOrUndefined(theme, 'theme');
        this._theme = Object.freeze(theme);
        this._raiseEvent();
    };
    /**
     * If set, get the current scoped theme.
     */
    ThemeProvider.prototype.tryGetTheme = function () {
        return this._theme;
    };
    ThemeProvider.prototype._raiseEvent = function () {
        _SPEventManager.instance.raiseEvent(this._themeChangedEventName, { theme: this._theme });
    };
    /**
     * The service key for ThemeProvider.
     */
    ThemeProvider.serviceKey = ServiceKey.create('sp-component-base.ThemeProvider', ThemeProvider);
    ThemeProvider._themeChangedEventNameLiteral = 'ThemeProvider.themeChangedEvent';
    /**
     * Used to register a unique event for each ThemeProvider instance by appending
     * the instance count to themeChangedEventNameLiteral.
     */
    ThemeProvider._instanceCount = 0;
    return ThemeProvider;
}());
export { ThemeProvider };
//# sourceMappingURL=ThemeProvider.js.map