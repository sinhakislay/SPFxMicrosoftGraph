/**
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * @file  This file contains code to help control the property pane interactions with its consumers.
 */
'use strict';
import { Environment, EnvironmentType, Text, Validate } from '@microsoft/sp-core-library';
import { _EngagementLogger, _LogEntry, _LogSource, _LogType, _QosMonitor, _TraceLogger } from '@microsoft/sp-diagnostics';
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import strings from '../loc/Strings.resx';
import styles from './PropertyPaneController.module.scss';
/**
 * Class which manages all the interactions between property pane and the property pane consumers, such as web parts.
 *
 * @internal
 */
var PropertyPaneController = /** @class */ (function () {
    /**
     * Instantiates the PropertyPaneController object.
     *
     * NOTE: [TODO] When the killswitch 'ConsumePropertyPaneControllerFromServiceScope'
     * is graduated remove this constructor and make the _constructor as the constructor
     * and still keep it as private.
     *
     * @param callback - callback to be called when a configuration event happens.
     */
    function PropertyPaneController(callback) {
        /*
         * Property pane controller log source
         */
        this._logSource = _LogSource.create('PropertyPaneController');
        /**
         * Dictionary of all the registered property pane consumers.
         */
        this._consumers = new Map();
        this._lifeCycleEventCallback = callback;
        this._constructor();
    }
    /**
     * Registers a property pane consumer with the property pane controller.
     *
     * @param instanceId - Instance id of the consumer.
     * @param consumer - Property pane consume to be registered.
     */
    PropertyPaneController.prototype.registerConsumer = function (instanceId, consumer) {
        Validate.isNonemptyString(instanceId, 'instanceId');
        Validate.isNotNullOrUndefined(consumer, 'consumer');
        this._consumers.set(instanceId, consumer);
    };
    /**
     * Returns true if the passed in instance Id, is a registered consumer.
     * @param instanceId - Instance id of the consumer.
     */
    PropertyPaneController.prototype.isConsumerRegistered = function (instanceId) {
        return this._consumers.has(instanceId);
    };
    Object.defineProperty(PropertyPaneController.prototype, "currentlyConfiguredConsumerId", {
        /**
         * Get the currently configured consumer's instance Id
         */
        get: function () { return this._currentlyConfiguredConsumerId; },
        enumerable: true,
        configurable: true
    });
    /**
     * API to request an action to be performed on the property pane. This helps in configuring a SharePoint component.
     * The inbuilt property pane is used for the configuration, with the below conditions:
     *
     *   - propertyPaneAction is Open and then open the property pane.
     *   - propertyPaneAction is Close and then close the property pane.
     *   - propertyPaneAction is Toggle and the property pane is closed: in this case we open the property pane and
     *       start the configuration process.
     *       Example - This happens when web part configure button is clicked.
     *   - propertyPaneAction is Toggle and the property pane is open: in this case, if the incoming consumer id
     *       is different than the one being currently configured, we keep the property pane open
     *       and change the active consumer being configured.
     *   - propertyPaneAction is Default and the property pane is closed: do nothing
     *   - propertyPaneAction is Default and the property pane is opened: change the property pane to display the
     *       settings of the newly selected consumer.
     *       Example - This happens when the user navigates between property pane consumers (ex: web parts).
     *
     * @param toBeConfiguredConsumerId - instance id of the consumer.
     * @param propertyPaneAction - indicates in what state the property pane should be.
     * @param renderedByWebPart - is the property pane rendered by a web part and not by Canvas or any other source.
     * @param context - additional data passed by the consumer, to be sent back to the same webpart
     */
    PropertyPaneController.prototype.requestAction = function (toBeConfiguredConsumerId, propertyPaneAction, renderedByWebPart, context // tslint:disable-line:no-any
    ) {
        if (propertyPaneAction === void 0) { propertyPaneAction = 4 /* Default */; }
        /**
         * It's a no operation scenario if a consumer is asking to refresh the property pane contents by invoking
         * refreshPropertyPane api, while some other consumer is being configured.
         */
        var noOp = renderedByWebPart &&
            propertyPaneAction === 5 /* Refresh */ &&
            toBeConfiguredConsumerId !== this._currentlyConfiguredConsumerId;
        if (!noOp) {
            // 'id' can be 'undefined'. It happens when user selects RTE.
            // When 'id' is 'undefined' then 'wp' will be 'undefined'. In that case we render the empty property pane.
            var toBeConfiguredConsumer = this._tryGetConsumer(toBeConfiguredConsumerId);
            this._setPropertyPaneDOMElements();
            /**
             * A variable indicating, if the property pane will open or not. The flag is set to true when the pane is NOT
             * open and the requested propertyPaneAction is either Open or Toggle.
             */
            var paneWillOpen = !this._isOpen &&
                (propertyPaneAction === 1 /* Open */ || propertyPaneAction === 3 /* Toggle */);
            var activeComponentChanged = false;
            /**
             * Fire the 'ActiveWebPartChanged' event when the configuring consumer changes on the property pane.
             */
            if (toBeConfiguredConsumerId &&
                this._currentlyConfiguredConsumerId &&
                (toBeConfiguredConsumerId !== this._currentlyConfiguredConsumerId || paneWillOpen)) {
                activeComponentChanged = true;
                /**
                 * Premptively asking consumer(if exists, consumer can be undefined for canvas toolbox hint.)
                 * to load async resources for its property pane before the data
                 * is requested via _getPropertyPaneData call.
                 * We make this call when the active webpart has changed and the property pane is shown.
                 */
                if (toBeConfiguredConsumer && (this._isOpen || paneWillOpen)) {
                    toBeConfiguredConsumer._loadPropertyPaneResources();
                }
                this._fireConfigurationEvent(toBeConfiguredConsumerId, 7 /* ActiveWebPartChanged */);
            }
            if (propertyPaneAction !== 5 /* Refresh */) {
                /**
                 * When shifting from internal item edit to the overall component edit, canvas sends in Toggle
                 * as the propertypaneaction. However, to keep the property pane open and shift to the overall
                 * component configuration we will ignore the incoming propertypanestate and just refreshes it.
                 */
                if (propertyPaneAction === 3 /* Toggle */) {
                    var internalToOverallComponentEdit = !!this._isPaneRenderedByWebPart !== !!renderedByWebPart;
                    if (!activeComponentChanged && internalToOverallComponentEdit) {
                        propertyPaneAction = 5 /* Refresh */;
                    }
                }
                /**
                 * Update the '_isPaneRenderedByWebPart' variable only in the NON 'Refresh' scenarios.
                 * On 'Refresh' we have decided NOT to update the '_isPaneRenderedByWebPart'.
                 */
                this._isPaneRenderedByWebPart = !!renderedByWebPart;
            }
            this._executeAction(toBeConfiguredConsumer, toBeConfiguredConsumerId, propertyPaneAction, context);
            this._currentlyConfiguredConsumerId = toBeConfiguredConsumerId;
        }
        else {
            _TraceLogger.logVerbose(this._logSource, Text.format(strings.NoOpOnRefreshPropertyPaneText, toBeConfiguredConsumerId));
        }
    };
    /**
     * Returns true if the property pane is rendered by a consumer,example web part, RTE etc.,
     * and not by the host, example canvas.
     * A component becomes consumer if it implements IPropertyPaneConsumer.
     */
    PropertyPaneController.prototype.isRenderedByConsumer = function () {
        return this._isPaneRenderedByWebPart;
    };
    /**
     * Returns true if the property pane is open.
     */
    PropertyPaneController.prototype.isOpen = function () {
        return this._isOpen;
    };
    /**
     * Empty out the property pane when the web part being configured is deleted from the page.
     *
     * @param id - Instance id of the consumer.
     */
    PropertyPaneController.prototype.onConsumerDelete = function (id) {
        Validate.isNonemptyString(id, 'id');
        if (id === this._currentlyConfiguredConsumerId) {
            if (this._isOpen) {
                this._renderPropertyPane(undefined, true);
            }
            this._currentlyConfiguredConsumerId = undefined;
        }
    };
    /**
     * Allows the property panes title to be overriden.
     *
     * @param title - Title of the property pane.
     *
     * @internal
     */
    PropertyPaneController.prototype._setAppPagePropertyPaneTopData = function (topControl, title) {
        this._topControl = topControl;
        this._title = title;
    };
    /**
     * Causes the property pane to be rendered narrowly (320px vs 340px).
     *
     * @internal
     */
    PropertyPaneController.prototype._setPropertyPaneToNarrowRender = function (narrow) {
        this._narrowRender = narrow;
    };
    /**
     * Instantiates the PropertyPaneController object.
     *
     * The constructor is private since this service should always be constructed
     * via the ServiceScope key.
     *
     * NOTE: When the killswitch 'ConsumePropertyPaneControllerFromServiceScope'
     * is graduated, this method will become the actual constructor.
     */
    PropertyPaneController.prototype._constructor = function () {
        this._propertyPaneContainerId = Environment.type !== EnvironmentType.ClassicSharePoint ?
            PropertyPaneController.PROPERTY_PANE_CONTAINER_ID :
            PropertyPaneController.PROPERTY_PANE_CONTAINER_NOFLEXBOX_ID;
        // method bindings
        this._onPropertyPaneFieldChanged = this._onPropertyPaneFieldChanged.bind(this);
        this._onConfigurationEvent = this._onConfigurationEvent.bind(this);
        this._fireConfigurationEvent = this._fireConfigurationEvent.bind(this);
    };
    /**
     * Executes the request action on the property pane if appropriate.
     *
     * @param toBeConfiguredConsumer - component to be configured.
     * @param toBeConfiguredConsumerInstanceId - Instance id of the component to be configured.
     * @param propertyPaneAction - Action to be executed on the property pane.
     */
    PropertyPaneController.prototype._executeAction = function (toBeConfiguredConsumer, toBeConfiguredConsumerInstanceId, propertyPaneAction, context /* tslint:disable-line:no-any */) {
        switch (propertyPaneAction) {
            case 1 /* Open */:
            case 6 /* OpenDetails */:
                /**
                 * Inside the '_renderPropertyPane' the value of the variable '_isOpen' could be modified.
                 * Hence, to keep the before state of it, introducing 'paneOpenBeforeRender'.
                 */
                var paneOpenBeforeRender = this._isOpen;
                this._renderPropertyPane(toBeConfiguredConsumer, true, true, propertyPaneAction === 6 /* OpenDetails */, context);
                this._showPropertyPane();
                /**
                 * If pane is 'open' before '_renderPropertyPane' is called that means property pane did not toggle.
                 * Hence no events were fired. So fire the events explicitly.
                 */
                if (paneOpenBeforeRender) {
                    this._fireNoToggleConfigurationEvents(toBeConfiguredConsumerInstanceId);
                }
                else {
                    this._firePostToggleConfigurationEvents();
                }
                break;
            // Property pane should close.
            case 2 /* Close */:
                if (this._isOpen) {
                    this._hidePropertyPane();
                    this._firePostToggleConfigurationEvents();
                }
                break;
            // Property pane should toggle i.e., if it's open, close it else open it.
            case 3 /* Toggle */:
                if (this._isOpen) {
                    this._hidePropertyPane();
                }
                else {
                    this._renderPropertyPane(toBeConfiguredConsumer, true, true);
                    this._showPropertyPane();
                }
                // Fire the post toggle events.
                this._firePostToggleConfigurationEvents();
                break;
            // Keep the property pane open if it's already open, else no-op.
            case 4 /* Default */:
                if (this._isOpen) {
                    // New component triggered the 'openPropertyPane' and the property pane is open, so will keep it open.
                    // This results in NO toggle. So fire the events specific to this condition.
                    this._fireNoToggleConfigurationEvents(toBeConfiguredConsumerInstanceId);
                    // If current opened property pane is the right property pane, no need to force reset.
                    // Otherwise, the componentDidUpdate in PropertyPane.tsx will have never been entered, which will lead to
                    // _isPropertyPaneReplaced in PropertyPane.tsx keeping true.
                    // The logic inside PropertyPane.tsx is strong enough to decide whether it need to reset whole property pane.
                    if (this._isCurrentlyConfiguredPropertyPaneReactive) {
                        this._renderPropertyPane(toBeConfiguredConsumer, true, false);
                    }
                    else {
                        // @todo: (SPPPLAT VSO# Task 236141:Implement Non-Reactive property pane in full).
                        // For now we are rendering the property pane, but ideally we have to check if the
                        // property pane is in dirty state and act accordingly.
                        this._renderPropertyPane(toBeConfiguredConsumer, true, false);
                    }
                }
                break;
            /**
             * Refresh the contents of the property pane if the property pane is open for the requesting component.
             *  - This condition is prechecked in 'requestPropertyPaneAction' method.
             */
            case 5 /* Refresh */:
                if (this._isOpen) {
                    this._renderPropertyPane(toBeConfiguredConsumer, true, false);
                }
                break;
        }
        if (this._isOpen !== false && toBeConfiguredConsumer) {
            // todo(@ManishGa) 282500 - avoid use of any here
            var wpContext = toBeConfiguredConsumer.context; /* tslint:disable-line:no-any */
            var wpAlias = wpContext && wpContext._manifest && wpContext._manifest.alias;
            var isInternal = wpContext && wpContext._manifest && wpContext._manifest.isInternal || false;
            var logEntry = new _LogEntry(this._logSource.id, 'PropertyPaneOpened', _LogType.Event, {
                'alias': wpAlias,
                'isInternal': isInternal.toString()
            });
            _EngagementLogger.logEventWithLogEntry(logEntry);
        }
    };
    /**
     * A private method to show the property pane.
     *
     * This method will also set the value of the '_isOpen' value appropriately.
     */
    PropertyPaneController.prototype._showPropertyPane = function () {
        if (this._pageContentElement) {
            this._pageContentElement.classList.add(styles.shrinkContent);
        }
        else {
            /**
             * This is a temporary fix.
             * @todo: (SPPPLAT VSO: Bug 237945:Fix the property pane rendering on the classic page)
             */
            this._propertyPaneContainer.style.top = '50px';
            this._propertyPaneContainer.style.zIndex = '999';
        }
        if (this._workbenchCommandBarElement) {
            this._workbenchCommandBarElement.classList.add(styles.shrinkContent);
        }
        this._propertyPaneContainer.classList.add(this._narrowRender ?
            styles.showPaneNarrow :
            styles.showPane);
        this._isOpen = true;
    };
    /**
     * A private method to hide the property pane.
     *
     * This method will also set the value of the '_isOpen' value appropriately.
     */
    PropertyPaneController.prototype._hidePropertyPane = function () {
        var clearPropertyPaneReference = false;
        if (this._pageContentElement) {
            this._pageContentElement.classList.remove(styles.shrinkContent);
            if (this._propertyPaneElement) {
                ReactDOM.unmountComponentAtNode(this._propertyPaneElement);
                clearPropertyPaneReference = true;
            }
        }
        else if (this._propertyPaneElement) {
            /**
             * If there is no page content element, then it means that it is a classic page. So unmounting
             * the property pane node, because for some reason property pane is not respecting PropertyPaneContainer
             * styles.
             *
             * This is a temporary fix.
             * @todo: (SPPPLAT VSO: Bug 237945:Fix the property pane rendering on the classic page)
             */
            ReactDOM.unmountComponentAtNode(this._propertyPaneElement);
            clearPropertyPaneReference = true;
        }
        if (clearPropertyPaneReference) {
            this._propertyPaneElement = undefined;
        }
        if (this._workbenchCommandBarElement) {
            this._workbenchCommandBarElement.classList.remove(styles.shrinkContent);
        }
        this._propertyPaneContainer.classList.remove(this._narrowRender ?
            styles.showPaneNarrow :
            styles.showPane);
        this._isOpen = false;
    };
    /**
     * Renders the property pane.
     *
     * @param currentConsumer - Current component for which the property pane is to be displayed.
     * @param recreatePropertyPane - Indicates whether property pane should be recreated or not.
     * @param reset - Indicating whether property pane state should be reset or not.
     * @param isDetails - Indicating whether this is rendered in openDetails scenario
     * @param context - additional data passed by the consumer, to be sent back to the same webpart
     */
    PropertyPaneController.prototype._renderPropertyPane = function (currentConsumer, recreatePropertyPane, reset, isDetails, context /* tslint:disable-line:no-any */) {
        var _this = this;
        var qosMonitor = new _QosMonitor('PropertyPaneController.renderPropertyPane');
        if (currentConsumer) {
            currentConsumer._getPropertyPaneData(isDetails, context).then(function (data) {
                // load the property pane only when the resolved promise is of the current webpart.
                // else no-op
                if (_this._currentlyConfiguredConsumerId === data.webPartId) {
                    /**
                     * Posting a message to the current window indicating that the property pane will open.
                     * This is used by the clientsidewebpartmanager to close isolated property pane, if open.
                     *
                     * @todo(SPPPLAT Bug #299413): Implement missing schema for property pane post messages
                     * @todo(SPPPLAT PBI #687467): Refactor IframedWebPartContoller
                     */
                    window.postMessage('Property pane will open', window.location.origin);
                    _this._buildAndLoadPropertyPane(data, reset);
                }
            }).catch(function (error) {
                _TraceLogger.logErrorData({
                    source: _this._logSource,
                    error: error
                });
                qosMonitor.writeUnexpectedFailure('UnhandledError', error);
                throw error;
            });
        }
        else {
            // if !currentWebpart
            this._currentPropertyPaneData = this._getEmptyPropertyPaneData();
            this._loadPropertyPaneComponent(recreatePropertyPane);
        }
    };
    /**
     * Builds the data required to load the property pane and then loads the property pane component.
     *
     * @param propertyPaneData - property pane data for currently active consumer.
     * @param reset - Indicating whether property pane state should be reset or not.
     */
    PropertyPaneController.prototype._buildAndLoadPropertyPane = function (propertyPaneData, reset) {
        var _this = this;
        this._currentPropertyPaneData = propertyPaneData;
        propertyPaneData.onPropertyPaneFieldChanged = this._onPropertyPaneFieldChanged;
        propertyPaneData.onConfigurationEvent = this._onConfigurationEvent;
        propertyPaneData.render = function () { _this._reRender(); };
        propertyPaneData.shouldResetState = reset;
        if (propertyPaneData.configuration &&
            propertyPaneData.configuration.showLoadingIndicator) {
            // Reason behind calculating delay like this is, we want to respect
            // the value provided by the consumer's author, including 0(otherwise its a falsy value.)
            var delay = propertyPaneData.configuration.loadingIndicatorDelayTime === undefined ?
                500 : propertyPaneData.configuration.loadingIndicatorDelayTime;
            setTimeout(function () {
                if (propertyPaneData.configuration.showLoadingIndicator) {
                    /**
                     * Reloading the property pane component if showOverlaySpinner is true after the
                     * overlaySpinnerDelayTime (if specified) or 500 ms.
                     */
                    _this._loadPropertyPaneComponent(true);
                }
            }, delay);
        }
        else {
            this._loadPropertyPaneComponent(true);
        }
    };
    /**
     * Method to load the property pane component into the propertypanecontainer element using the
     * currentPropertyPaneData.
     *
     * @param recreatePropertyPane - Indicating whether property pane should be recreated or not.
     */
    PropertyPaneController.prototype._loadPropertyPaneComponent = function (recreatePropertyPane) {
        var _this = this;
        var qosMonitor = new _QosMonitor('PropertyPaneController.loadPropertyPaneComponent');
        // Load the property pane asynchronously in a separate bundle.
        import(/* webpackChunkName: 'property-pane-component' */ '../propertyPane/PropertyPane')
            .then(function (propertyPane) {
            // Only if this flag is true, re-insert the property pane element into the DOM.
            var insertIntoDom = false;
            if (recreatePropertyPane) {
                // Recreating the property pane. This will enable the property pane to be in a valid state.
                if (!_this._propertyPaneElement) {
                    _this._propertyPaneElement = document.createElement('div');
                    insertIntoDom = true;
                }
            }
            if (_this._propertyPaneElement) {
                _this._propertyPaneElement.className = _this._currentPropertyPaneData.webPartId;
                if (_this._title) {
                    _this._currentPropertyPaneData.title = _this._title;
                }
                var el = React.createElement(propertyPane.default, {
                    data: _this._currentPropertyPaneData,
                    renderNarrow: _this._narrowRender
                }, _this._topControl);
                ReactDOM.render(el, _this._propertyPaneElement);
            }
            // If the consumer app provides a container div, the property pane will slide-in/out.
            // Else, the property pane will be a popup and overlay over the content area.
            // Further, if not required, do not re-insert the element into dom.
            if (_this._propertyPaneContainer) {
                if (insertIntoDom) {
                    _this._clearPropertyPaneContainer();
                    if (_this._propertyPaneElement) {
                        _this._propertyPaneContainer.appendChild(_this._propertyPaneElement);
                    }
                }
            }
            else {
                if (insertIntoDom && document.body.lastChild && _this._propertyPaneElement) {
                    document.body.insertBefore(_this._propertyPaneElement, document.body.lastChild.nextSibling);
                }
            }
        })
            .catch(function (error) {
            _TraceLogger.logErrorData({
                source: _this._logSource,
                error: error
            });
            qosMonitor.writeUnexpectedFailure('UnhandledError', error);
        });
    };
    /**
     * Allow the property pane to re-render itself. Used when navigating pages.
     */
    PropertyPaneController.prototype._reRender = function () {
        var consumer = this._tryGetConsumer(this._currentPropertyPaneData.webPartId);
        if (consumer) {
            this._renderPropertyPane(consumer);
        }
    };
    /**
     * Property pane field change event handler.
     *
     * @param propertyName - Name of the property pane field changed.
     * @param newValue - New value.
     *  This value could be undefined/empty in the case of custom field.
     */
    /* tslint:disable:no-any */
    PropertyPaneController.prototype._onPropertyPaneFieldChanged = function (propertyName, newValue, fieldType) {
        /* tslint:enable:no-any */
        Validate.isNonemptyString(propertyName, 'propertyName');
        if (!this._currentPropertyPaneData.webPartId) {
            throw new Error('onPropertyPaneFieldChanged event is not expected when no consumer is being configured');
        }
        var consumer = this._tryGetConsumer(this._currentPropertyPaneData.webPartId);
        if (consumer) {
            consumer._onPropertyPaneFieldChanged(propertyName, newValue, fieldType);
            // Resetting the boolean value.
            this._renderPropertyPane(consumer);
        }
        if (this._isCurrentlyConfiguredPropertyPaneReactive()) {
            this._resetConfigurationCompleteTimeout();
        }
    };
    /**
     * Callback to handle the configuration events that originate in the property pane.
     *
     * @example
     * PropertyPaneClosed, PropertyPaneApplyClicked etc.,
     */
    PropertyPaneController.prototype._onConfigurationEvent = function (configurationEvent) {
        switch (configurationEvent) {
            /**
             * For the event 'PropertyPaneClosed' we need to fire both the 'PropertyPaneClosed' and
             * 'PropertyPaneConfigurationComplete' events to the consumer.
             * '_togglePropertyPanePosition' internally fires both the events.
             */
            case 4 /* Closed */:
                this._hidePropertyPane();
                this._firePostToggleConfigurationEvents();
                break;
            /**
             * For these events we need to fire two events:
             *  - 'PropertyPaneConfigurationComplete' and
             *  - Whatever the event the caller has passed in 'configurationEvent'.
             */
            case 5 /* ApplyClicked */:
            case 6 /* LostFocus */:
                this._fireConfigurationEvent(this._currentlyConfiguredConsumerId, configurationEvent);
                this._fireConfigurationEvent(this._currentlyConfiguredConsumerId, 2 /* ConfigurationComplete */);
                break;
        }
    };
    /**
     * Method to fire the configuration events post toggling the property pane.
     * If toggling opened the property pane then fire both the 'PropertyPaneOpened' and 'PropertyPaneConfigurationStart'
     * events after the ANIMATION_TIMEOUT is elapsed.
     * Else if the toggling resulted in closing the property pane then fire 'PropertyPaneConfigurationComplete' event
     * and then after ANIMATION_TIMEOUT is elapsed fire 'PropertyPaneClosed' event.
     */
    PropertyPaneController.prototype._firePostToggleConfigurationEvents = function () {
        var _this = this;
        // @todo: this is a temporary fix to let the host (e.g. Canvas) know that the property pane has completed
        // animating. The current property pane animation is 367ms and hence the 400ms timeout. The correct fix is
        // to hookup to the animation end event.
        if (this._isOpen) {
            window.setTimeout(function () {
                _this._fireConfigurationEvent(_this._currentlyConfiguredConsumerId, 3 /* Opened */);
                _this._fireConfigurationEvent(_this._currentlyConfiguredConsumerId, 1 /* ConfigurationStart */);
                /**
                 * Posting a message to the current window indicating that the property pane toggled.
                 * @example: Modern pages use this message to re-size it's header.'
                 */
                window.postMessage('Property pane toggled', window.location.origin);
            }, PropertyPaneController.ANIMATION_TIMEOUT);
        }
        else {
            this._fireConfigurationEvent(this._currentlyConfiguredConsumerId, 2 /* ConfigurationComplete */);
            window.setTimeout(function () {
                _this._fireConfigurationEvent(_this._currentlyConfiguredConsumerId, 4 /* Closed */);
                /**
                 * Posting a message to the current window indicating that the property pane toggled.
                 * @example: Modern pages use this message to re-size it's header.'
                 * @todo(SPPPLAT Bug #299413): Implement missing schema for property pane post messages
                 */
                window.postMessage('Property pane toggled', window.location.origin);
            }, PropertyPaneController.ANIMATION_TIMEOUT);
        }
    };
    /**
     * Method to fire the configuration events when the property pane did not toggle.
     * Fire the 'ConfigurationComplete' event on the current consumer and
     * then 'ConfigurationStart' for the new consumer.
     *
     * @param id - Id of the consumer to be configured.
     */
    PropertyPaneController.prototype._fireNoToggleConfigurationEvents = function (id) {
        // Firing events for the current consumer.
        this._fireConfigurationEvent(this._currentlyConfiguredConsumerId, 2 /* ConfigurationComplete */);
        // Firing events for the new consumer.
        this._fireConfigurationEvent(id, 1 /* ConfigurationStart */);
    };
    /**
     * Method to fire the configuration event to the host and the consumer.
     *
     * @param componentId - Id of the consumer to which the event needs to be sent.
     * @param configurationEvent - Kind of configuration event to fire.
     */
    PropertyPaneController.prototype._fireConfigurationEvent = function (componentId, configurationEvent) {
        this._clearConfigurationCompleteTimeout();
        // Up to IWebPartGetter to handle an undefined string.
        var consumer = this._tryGetConsumer(componentId);
        if (consumer) {
            // Raise the event to the host.
            if (this._lifeCycleEventCallback) {
                this._lifeCycleEventCallback(configurationEvent, componentId);
            }
            // Raise the event to the consumer.
            consumer._onPropertyPaneLifeCycleEvent(configurationEvent);
        }
    };
    /**
     * Private method to set the property pane related DOM elements, which are used in slide in slide out effect.
     */
    PropertyPaneController.prototype._setPropertyPaneDOMElements = function () {
        var workbenchElement = document.getElementById('workbenchPageContent');
        // @todo: (SPPPLAT VSO#222337) - Refactor Workbench page layout
        if (workbenchElement) {
            this._pageContentElement = workbenchElement;
            this._workbenchCommandBarElement = document.getElementById('workbenchCommandBar');
        }
        else {
            this._pageContentElement = document.getElementById('spPageChromeAppDiv');
        }
        // All modern apps should have the spPageChromeAppDiv. If not, then we should treat like the Classic page scenario.
        // i.e.the container div should be hanging off the root node. And we should create it only the first time.
        if (!this._pageContentElement) {
            if (!this._propertyPaneContainer) {
                this._propertyPaneContainer = document.createElement('div');
                this._propertyPaneContainer.id = this._propertyPaneContainerId;
                this._propertyPaneContainer.className = this._propertyPaneContainerId;
                document.body.appendChild(this._propertyPaneContainer);
            }
        }
        else {
            // We know it will always exist in the Classic Page scenario.
            this._propertyPaneContainer = document.getElementById(this._propertyPaneContainerId) ||
                // classic page or when flexbox killswitch is on
                document.getElementById(PropertyPaneController.PROPERTY_PANE_CONTAINER_NOFLEXBOX_ID);
        }
    };
    /**
     * Removes all the children of the property pane container.
     */
    PropertyPaneController.prototype._clearPropertyPaneContainer = function () {
        while (this._propertyPaneContainer && this._propertyPaneContainer.firstChild) {
            this._propertyPaneContainer.removeChild(this._propertyPaneContainer.firstChild);
        }
    };
    /**
     * Reset configuration completion timeout.
     */
    PropertyPaneController.prototype._resetConfigurationCompleteTimeout = function () {
        this._clearConfigurationCompleteTimeout();
        this._configurationCompletionTimeout = window.setTimeout(this._fireConfigurationEvent, PropertyPaneController.CONFIGURATION_COMPLETE_TIMEOUT, this._currentlyConfiguredConsumerId, 2 /* ConfigurationComplete */);
    };
    /**
     * Clear configuration completion timeout.
     */
    PropertyPaneController.prototype._clearConfigurationCompleteTimeout = function () {
        if (this._configurationCompletionTimeout) {
            window.clearTimeout(this._configurationCompletionTimeout);
            this._configurationCompletionTimeout = undefined;
        }
    };
    /**
     * Method to check whether the currently configured property pane is reactive or not.
     */
    PropertyPaneController.prototype._isCurrentlyConfiguredPropertyPaneReactive = function () {
        if (this._currentlyConfiguredConsumerId) {
            var consumer = this._tryGetConsumer(this._currentlyConfiguredConsumerId);
            var isReactive = this._currentPropertyPaneData ?
                this._currentPropertyPaneData.isReactive :
                consumer && !consumer._isPropertyPaneReactive();
            return !!isReactive;
        }
        return false;
    };
    /**
     * Method to get a consumer instance.
     */
    PropertyPaneController.prototype._tryGetConsumer = function (id) {
        return this._consumers.get(id);
    };
    /**
     * Returns the property pane data which has only 'onClose' defined. This is used when we have to display
     * empty property pane, when there is nothing to configure.
     */
    PropertyPaneController.prototype._getEmptyPropertyPaneData = function () {
        return {
            webPartId: undefined,
            title: undefined,
            shouldResetState: true,
            onPropertyPaneFieldChanged: undefined,
            onConfigurationEvent: this._onConfigurationEvent,
            onRendered: undefined,
            properties: undefined,
            configuration: {
                pages: []
            },
            dynamicConfiguration: undefined
        };
    };
    /**
     * Property pane animation timeout (in milliseconds).
     */
    PropertyPaneController.ANIMATION_TIMEOUT = 400;
    /**
     * Property pane configuration complete timeout for Reactive components (in milliseconds).
     */
    PropertyPaneController.CONFIGURATION_COMPLETE_TIMEOUT = 5000;
    /**
     * Property pane container id.
     */
    PropertyPaneController.PROPERTY_PANE_CONTAINER_ID = 'spPropertyPaneContainer';
    /**
     * Property pane container id.
     */
    PropertyPaneController.PROPERTY_PANE_CONTAINER_NOFLEXBOX_ID = 'spPropertyPaneContainerNoFlexbox';
    return PropertyPaneController;
}());
export default PropertyPaneController;
//# sourceMappingURL=PropertyPaneController.js.map