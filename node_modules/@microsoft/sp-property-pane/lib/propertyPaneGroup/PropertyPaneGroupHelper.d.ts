import { DynamicProperty } from '@microsoft/sp-component-base';
import { IDynamicConfiguration } from '../propertyPaneDynamicData/IDynamicConfiguration';
import { IPropertyPaneField } from '../propertyPaneFields/propertyPaneField/IPropertyPaneField';
/**
 * React requires a key to be set for each item in the collection.
 *
 * Key should be unique and consistent. With the way PropertyPane works today, it's very difficult to ensure the
 * consistency of the keys all the time. The only way we can achieve consistency all the time is when the web part
 * developer supplies a unique key with each field. From the framework standpoint, we did not want to keep the onus
 * of sending in the unique key with the web part developers. We are keeping it simple. Hence, solving the problem
 * for most of the cases. Uniqueness is obtained by maintaining a dictionary of keys.
 *
 * Choosing 'type' and 'targetProperty' as the key ensures that in most of the cases consistency is achieved.
 * This is because every field will have an associated target property or 'key' for CustomField.
 * For the corner cases where there is no targetProperty or same targetProperty is assigned to multiple fields,
 * we are generating a key appended by index.
 *
 * This will result in a compromised performance, but not very noticeable and hence we are okay with it.
 * If we can think of any better and simple solution to keep the consistency, we will revisit this logic.
 */
export declare function generateGroupFieldKey(keys: {
    [key: string]: number;
}, groupField: IPropertyPaneField<any>): string;
/**
 * This method does the following things to fix up the propValue:
 * If the group field is a DynamicFieldSet then,
 *    - It creates a map of targetProperty and its fixed up dynamic property.
 *    - For each entry of the set,
 *      - it will extract the propValue from the properties and
 *      - check if the propValue is of type 'DynamicProperty', if
 *        - Yes, its a NO-OP. Everyhting is good with propValue, no fixup required.
 *        - No, then using its static value, make the propValue a DynamicProperty
 *  else if the group field is a DynamicField then,
 *    - Will check if the propValue is of type 'DynamicProperty', if
 *      - Yes, its a NO-OP. Everyhting is good with propValue, no fixup required.
 *      - No, then using its static value, make the propValue a DynamicProperty
 *  else
 *    - Will check if the propValue is of type DynamicProperty, if
 *      - Yes, then extract the value out of the DynamicProperty and assign it as
 *        a static value. This case is possible, when the developers map an existing
 *        dynamic field to a non dynamic field.
 *      - No, then it's a NO-OP
 *
 * @param propertyPaneField - Group field reference.
 */
export declare function getFixedUpPropValue(propertyPaneField: IPropertyPaneField<any>, properties: any, dynamicConfiguration: IDynamicConfiguration): any;
/**
 * Checks if the propValue is of type 'DynamicProperty', if
 *  - Yes, its a NO-OP. Everyhting is good with propValue, no fixup required.
 *  - No, then using its static value, make the propValue a DynamicProperty
 *
 * @remarks
 * If the component provides a callback as part of the groupfield properties's dynamicConfiguration
 * then we would take it else fall back to the defaultCallback of the component which is
 * provided by the framework. Example - BaseWebPart for web parts.

 * @param propValue - propValue to be fixed.
 */
export declare function getFixedUpDynamicProperty(dynamicConfiguration: IDynamicConfiguration, propValue: any): DynamicProperty<any>;
//# sourceMappingURL=PropertyPaneGroupHelper.d.ts.map