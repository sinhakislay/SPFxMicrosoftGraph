import { DynamicProperty } from '@microsoft/sp-component-base';
import { Validate } from '@microsoft/sp-core-library';
import * as lodash from '@microsoft/sp-lodash-subset';
import { PropertyPaneFieldType } from '../propertyPaneFields/propertyPaneField/IPropertyPaneField';
/**
 * React requires a key to be set for each item in the collection.
 *
 * Key should be unique and consistent. With the way PropertyPane works today, it's very difficult to ensure the
 * consistency of the keys all the time. The only way we can achieve consistency all the time is when the web part
 * developer supplies a unique key with each field. From the framework standpoint, we did not want to keep the onus
 * of sending in the unique key with the web part developers. We are keeping it simple. Hence, solving the problem
 * for most of the cases. Uniqueness is obtained by maintaining a dictionary of keys.
 *
 * Choosing 'type' and 'targetProperty' as the key ensures that in most of the cases consistency is achieved.
 * This is because every field will have an associated target property or 'key' for CustomField.
 * For the corner cases where there is no targetProperty or same targetProperty is assigned to multiple fields,
 * we are generating a key appended by index.
 *
 * This will result in a compromised performance, but not very noticeable and hence we are okay with it.
 * If we can think of any better and simple solution to keep the consistency, we will revisit this logic.
 */
// tslint:disable-next-line:no-any
export function generateGroupFieldKey(keys, groupField) {
    var key = '';
    if (groupField.type === PropertyPaneFieldType.Custom) {
        Validate.isNonemptyString(groupField.properties.key, 'Custom field key');
        // CustomField uses `key` instead of `targetProperty`.
        // Adding group field type as prefix to avoid keys being messed up with keys from different control type.
        var customField = groupField;
        key = customField.type + "-" + customField.properties.key;
    }
    else { // Non-custom fields
        key = groupField.type + "-" + (groupField.targetProperty || '');
    }
    // Append the smallest unused index to the key and update the index.
    // @example
    // If two CustomField controls have same properties.key such as 'sampleKey'. Their final key generated will
    // be '1-sampleKey-0' and '1-sampleKey-1'. The prefix '1' represents the control type is CustomField.
    // The suffix '0' and '1' are indexes determined by the order they appear in PropertyPaneConfiguration.
    var keyIndex = keys[key] || 0;
    keys[key] = keyIndex + 1;
    key += "-" + keyIndex;
    return key;
}
/**
 * This method does the following things to fix up the propValue:
 * If the group field is a DynamicFieldSet then,
 *    - It creates a map of targetProperty and its fixed up dynamic property.
 *    - For each entry of the set,
 *      - it will extract the propValue from the properties and
 *      - check if the propValue is of type 'DynamicProperty', if
 *        - Yes, its a NO-OP. Everyhting is good with propValue, no fixup required.
 *        - No, then using its static value, make the propValue a DynamicProperty
 *  else if the group field is a DynamicField then,
 *    - Will check if the propValue is of type 'DynamicProperty', if
 *      - Yes, its a NO-OP. Everyhting is good with propValue, no fixup required.
 *      - No, then using its static value, make the propValue a DynamicProperty
 *  else
 *    - Will check if the propValue is of type DynamicProperty, if
 *      - Yes, then extract the value out of the DynamicProperty and assign it as
 *        a static value. This case is possible, when the developers map an existing
 *        dynamic field to a non dynamic field.
 *      - No, then it's a NO-OP
 *
 * @param propertyPaneField - Group field reference.
 */
// tslint:disable:no-any
export function getFixedUpPropValue(propertyPaneField, properties, dynamicConfiguration) {
    var fixedUpPropValue = lodash.get(properties, propertyPaneField.targetProperty);
    // tslint:enable:no-any
    if (propertyPaneField.type === PropertyPaneFieldType.DynamicFieldSet) { // DynamicFieldSet
        var entries_1 = [];
        propertyPaneField.properties.fields.forEach(function (field) {
            var propValue = lodash.get(properties, field.targetProperty); // tslint:disable-line:no-any
            entries_1.push({
                targetProperty: field.targetProperty,
                value: getFixedUpDynamicProperty(dynamicConfiguration, propValue),
                properties: field.properties
            });
        });
        fixedUpPropValue = entries_1;
    }
    else if (propertyPaneField.type === PropertyPaneFieldType.DynamicField) { // DynamicField
        var entry = {
            targetProperty: propertyPaneField.targetProperty,
            value: getFixedUpDynamicProperty(dynamicConfiguration, fixedUpPropValue),
            properties: propertyPaneField.properties
        };
        fixedUpPropValue = entry;
    }
    else { // Non dynamic field but the value is a DynamicProperty
        if (fixedUpPropValue instanceof DynamicProperty) {
            fixedUpPropValue = fixedUpPropValue.tryGetValue(); // tslint:disable-line:no-any
        }
    }
    return fixedUpPropValue;
}
/**
 * Checks if the propValue is of type 'DynamicProperty', if
 *  - Yes, its a NO-OP. Everyhting is good with propValue, no fixup required.
 *  - No, then using its static value, make the propValue a DynamicProperty
 *
 * @remarks
 * If the component provides a callback as part of the groupfield properties's dynamicConfiguration
 * then we would take it else fall back to the defaultCallback of the component which is
 * provided by the framework. Example - BaseWebPart for web parts.

 * @param propValue - propValue to be fixed.
 */
export function getFixedUpDynamicProperty(dynamicConfiguration, propValue // tslint:disable-line:no-any
) {
    var isDynamicProperty = (propValue instanceof DynamicProperty);
    if (!isDynamicProperty) {
        var tempPropValue = propValue; // tslint:disable-line:no-any
        propValue = new DynamicProperty(dynamicConfiguration.dynamicDataProvider, dynamicConfiguration.defaultCallback);
        propValue.setValue(tempPropValue); // tslint:disable-line:no-any
    }
    return propValue;
}
//# sourceMappingURL=PropertyPaneGroupHelper.js.map