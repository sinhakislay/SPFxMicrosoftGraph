import * as tslib_1 from "tslib";
import { autobind, Label } from '@microsoft/office-ui-fabric-react-bundle';
import { Dropdown } from 'office-ui-fabric-react/lib/components/Dropdown/Dropdown';
import * as React from 'react';
import Strings from '../../loc/Strings.resx';
import { PropertyPaneFieldType } from '../../propertyPaneFields/propertyPaneField/IPropertyPaneField';
import Styles from '../DynamicDataWidget.module.scss';
import DynamicDataWidgetProperty from '../dynamicDataWidgetProperty/DynamicDataWidgetProperty';
import { DynamicDataSharedDepth } from '../IDynamicConfiguration';
var DynamicDataWidgetSource = /** @class */ (function (_super) {
    tslib_1.__extends(DynamicDataWidgetSource, _super);
    function DynamicDataWidgetSource(props) {
        var _this = _super.call(this, props) || this;
        // Set the selected source.
        _this.state = {
            selectedSourceId: _this._getSelectedSourceId()
        };
        return _this;
    }
    DynamicDataWidgetSource.prototype.render = function () {
        this._selectedSource = this.props.dynamicDataProvider.tryGetSource(this._getSelectedSourceId());
        return (React.createElement("div", null,
            this._renderSourceDropdown(),
            this._selectedSource && this._renderWidgetProperties()));
    };
    /**
     * Returns the source id:
     *  - if source id filter is provided, then it takes precedence over everything else.
     *  - else, if all the entries have the same source id, then selected source id would
     *    be that source id. This is because at this stage, source is common for all the
     *    entries.
     *  - else empty string.
     */
    DynamicDataWidgetSource.prototype._getSelectedSourceId = function () {
        var selectedSourceId = this._getSourceIdFilter();
        var entries = this.props.entries;
        if (!selectedSourceId) {
            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                var entry = entries_1[_i];
                if (entry.value._getSourceId()) {
                    selectedSourceId = entry.value._getSourceId();
                    break;
                }
                else {
                    selectedSourceId = '';
                }
            }
        }
        return selectedSourceId;
    };
    /**
     * Renders the sources dropdown.
     */
    DynamicDataWidgetSource.prototype._renderSourceDropdown = function () {
        var _this = this;
        var selectedSourceId = this.state.selectedSourceId;
        var sourceIdFilter = this._getSourceIdFilter();
        // If source id filter is given, then it takes presedence over the existing source id, if any.
        if (sourceIdFilter) {
            selectedSourceId = sourceIdFilter;
        }
        var sourceLabel = '';
        if (this.props.type === PropertyPaneFieldType.DynamicField) {
            sourceLabel = this.props.fieldProperties.sourcesLabel ||
                Strings.DynamicDataSourcesDropdownLabel;
        }
        else {
            var sharedConfiguration = this.props.fieldProperties.sharedConfiguration;
            sourceLabel = (sharedConfiguration &&
                sharedConfiguration.source &&
                sharedConfiguration.source.sourcesLabel) || Strings.DynamicDataSourcesDropdownLabel;
        }
        return (React.createElement("div", null, !sourceIdFilter &&
            React.createElement("div", null,
                React.createElement(Dropdown, { label: sourceLabel, onChanged: function (option) {
                        _this.setState({
                            selectedSourceId: option.key
                        });
                    }, options: this._getDataSourcesDropdownOptions(selectedSourceId), selectedKey: selectedSourceId, "data-automation-id": 'DynamicDataWidgetSource' }))));
    };
    /**
     * Returns the source id, if the component decides to filter by the source id
     * else undefined.
     */
    DynamicDataWidgetSource.prototype._getSourceIdFilter = function () {
        var _a = this.props, type = _a.type, entries = _a.entries;
        var sourceIdFilter;
        if (type === PropertyPaneFieldType.DynamicField) {
            var entry = entries[0];
            var filters = entry.properties.filters;
            sourceIdFilter = filters && filters.sourceId;
        }
        else { // DynamicFieldSet
            var sharedConfiguration = this.props.fieldProperties.sharedConfiguration;
            sourceIdFilter = sharedConfiguration &&
                sharedConfiguration.source &&
                sharedConfiguration.source.filters &&
                sharedConfiguration.source.filters.sourceId;
        }
        // If the currently available sources has a source with id 'sourceIdFilter'
        // then it is a valid filter.
        if (sourceIdFilter) {
            var dynamicDataProvider = this.props.dynamicDataProvider;
            var sources = dynamicDataProvider.getAvailableSources();
            var filteredSources = sources.filter(function (source) { return source.id === sourceIdFilter; });
            if (filteredSources) {
                this._selectedSource = filteredSources[0];
                return sourceIdFilter;
            }
        }
        return '';
    };
    /**
     * Retuns data source dropdown options with id-title pairs of all DD sources that are currently available.
     */
    DynamicDataWidgetSource.prototype._getDataSourcesDropdownOptions = function (selectedSourceId) {
        var _this = this;
        var options = [];
        var sources = this._getAvailableSources();
        // reset the selected source, so that while filling the options it is set again accordingly.
        this._selectedSource = undefined;
        sources.forEach(function (source) {
            // Omitting the current component from the list of displayed sources.
            if (_this.props.dynamicDataProvider._dynamicDataSourceId !== source.id) {
                options.push({ key: source.id, text: source.metadata.title });
                if (source.id === selectedSourceId) {
                    _this._selectedSource = source;
                }
            }
        });
        return options;
    };
    /**
     * Refreshes the Available sources based on the component id provided by the component
     * as part of the filters. If none provided, then it updates '_sources' array with all
     * the available sources.
     */
    DynamicDataWidgetSource.prototype._getAvailableSources = function () {
        var sources = [];
        var filters = this.props.entries[0].properties.filters;
        if (this.props.type === PropertyPaneFieldType.DynamicField) {
            if (filters && filters.componentId) {
                sources = this.props.dynamicDataProvider.getAvailableSourcesByComponentId(filters.componentId);
            }
        }
        else { // DynamicFieldSet
            var sharedConfiguration = this.props.fieldProperties.sharedConfiguration;
            var dynamicDataProvider = this.props.dynamicDataProvider;
            if (sharedConfiguration &&
                sharedConfiguration.source &&
                sharedConfiguration.source.filters &&
                sharedConfiguration.source.filters.componentId) {
                sources = dynamicDataProvider.getAvailableSourcesByComponentId(sharedConfiguration.source.filters.componentId);
            }
        }
        var filtersUsed = Boolean(filters && filters.componentId);
        if (sources.length > 0 ||
            filtersUsed // if filters were used return the result, even if empty
        ) {
            return sources;
        }
        else {
            return this.props.dynamicDataProvider.getAvailableSources();
        }
    };
    DynamicDataWidgetSource.prototype._renderWidgetProperties = function () {
        var _this = this;
        var widgetProperties = [];
        if (this._isPropertyShared()) {
            widgetProperties.push(this._renderWidgetProperty(widgetProperties.length, this.props.entries));
        }
        else {
            this.props.entries.forEach(function (entry) {
                widgetProperties.push(_this._renderWidgetProperty(widgetProperties.length, [entry]));
            });
        }
        return (React.createElement("div", null, widgetProperties));
    };
    DynamicDataWidgetSource.prototype._isPropertyShared = function () {
        if (this.props.entries.length === 1) {
            return true;
        }
        else {
            // If we are here, then the type must be DynamicFieldSet
            var sharedConfiguration = this.props.fieldProperties.sharedConfiguration;
            return !!(sharedConfiguration && sharedConfiguration.depth === DynamicDataSharedDepth.Property);
        }
    };
    DynamicDataWidgetSource.prototype._renderWidgetProperty = function (counter, entries) {
        var currentKey = this.props.parentKey + '-dynamicDataWidgetProperty' + counter;
        return (React.createElement("div", { key: currentKey },
            (this.props.entries.length > 1 && !this._isPropertyShared()) &&
                React.createElement(Label, { className: Styles.entryLabel }, entries[0].properties.label),
            React.createElement(DynamicDataWidgetProperty, tslib_1.__assign({}, this.props, { parentKey: currentKey, selectedSource: this._selectedSource, entries: entries }))));
    };
    tslib_1.__decorate([
        autobind
    ], DynamicDataWidgetSource.prototype, "_getSelectedSourceId", null);
    tslib_1.__decorate([
        autobind
    ], DynamicDataWidgetSource.prototype, "_getSourceIdFilter", null);
    return DynamicDataWidgetSource;
}(React.Component));
export default DynamicDataWidgetSource;
//# sourceMappingURL=DynamicDataWidgetSource.js.map