import * as tslib_1 from "tslib";
import { autobind } from '@microsoft/office-ui-fabric-react-bundle';
import { DynamicDataProvider } from '@microsoft/sp-component-base';
import { Log, Text } from '@microsoft/sp-core-library';
import { Dropdown } from 'office-ui-fabric-react/lib/components/Dropdown/Dropdown';
import * as React from 'react';
import Strings from '../../loc/Strings.resx';
var MAX_PROPERTY_VALUE_DEPTH = 2;
var DynamicDataWidgetEntry = /** @class */ (function (_super) {
    tslib_1.__extends(DynamicDataWidgetEntry, _super);
    function DynamicDataWidgetEntry(props) {
        var _this = _super.call(this, props) || this;
        _this._selectedSubPropertyText = '';
        _this.state = {
            selectedSubPropertyPath: _this.props.value._getPropertyPath(),
            selectedSubPropertyText: undefined
        };
        _this._updateReference();
        return _this;
    }
    DynamicDataWidgetEntry.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {
        var _this = this;
        if (this.props.selectedSource.id !== newProps.selectedSource.id ||
            this.props.selectedPropertyId !== newProps.selectedPropertyId) {
            // reset state when the selected property changes.
            this.setState({
                selectedSubPropertyText: '',
                selectedSubPropertyPath: ''
            }, function () {
                _this._updateReference();
            });
        }
    };
    /**
     * Renders the entries based on the maxPropertyValueDepth value provided by the component.
     * If the value of maxPropertyValueDepth is invalid then we display a console warning and
     * fall back to the default depth(MAX_SUBPROPERTY_DEPTH).
     * If it is not provided then we fall back to the default depth.
     */
    DynamicDataWidgetEntry.prototype.render = function () {
        var selectedPropertyId = this.props.selectedPropertyId;
        var selectedSubPropertyPath = this.state.selectedSubPropertyPath;
        var dropDowns = [];
        // Construct the next level of dropdowns, only if a property is selected.
        if (selectedPropertyId) {
            var level = 0;
            var currentPropertyPath = selectedPropertyId;
            var subProperties = selectedSubPropertyPath ? selectedSubPropertyPath.split('.') : [];
            var maxDepth = this._getMaxSubPropertyDepth();
            while (level < maxDepth && currentPropertyPath && subProperties) {
                dropDowns.push(this._getDropdownForSubProperty(level, currentPropertyPath, subProperties[level]));
                currentPropertyPath = subProperties[level] ? currentPropertyPath + '.' + subProperties[level] : '';
                level++;
            }
        }
        return (React.createElement("div", null, dropDowns));
    };
    /**
     * Returns the dropdown for the sub property.
     *
     * @param level - Current level of the new dropdown
     * @param propertyPath - Property selected in the previous dropdown, and for which the dropdown
     *  needs to be constructed.
     * @param selectedKey - SelectedKey for the new dropdown.
     */
    DynamicDataWidgetEntry.prototype._getDropdownForSubProperty = function (level, propertyPath, selectedKey) {
        var key = this.props.parentKey + 'sub-property' + level;
        // If the sub-property is an array type, then the selected key will be of the type
        // <subPropertyName>[*]. Hence extracting the sub property name, accordingly.
        selectedKey = selectedKey && selectedKey.split(DynamicDataProvider._jsonPathArrayRegex)[0];
        var options = this._getDropdownOptions(this._getSubPropertyValueObject(propertyPath), propertyPath, false, selectedKey);
        var selectedText = (level === 0) ?
            this.props.selectedPropertyText :
            (this.state.selectedSubPropertyText || this._selectedSubPropertyText);
        return (React.createElement("div", { key: key }, (options.length > 0) &&
            React.createElement(Dropdown, { label: Text.format(Strings.DynamicDataPropertiesDropdownLabel, selectedText), onChanged: this._onSubPropertySelectionChange.bind(this, level), options: options, selectedKey: selectedKey || '', "data-automation-id": 'DynamicDataWidgetEntryDropdown' })));
    };
    /**
     * Handler for the sub property dropdown.
     *
     * @param option - selected option.
     * @param level - level of the current dropdown among the sub property dropdowns.
     */
    DynamicDataWidgetEntry.prototype._onSubPropertySelectionChange = function (level, option) {
        var _this = this;
        var _a = this.state, selectedSubPropertyPath = _a.selectedSubPropertyPath, selectedSubPropertyText = _a.selectedSubPropertyText;
        var selectedKey = option.key;
        var paths = selectedSubPropertyPath ? selectedSubPropertyPath.split('.') : [];
        // Update the 'level' indexed path and anything before that remains same as previous
        // and anything after will be removed, as those entries don't belong to the newly selected option.
        selectedSubPropertyPath = '';
        for (var i = 0; i < level; i++) {
            selectedSubPropertyPath += paths[i] + '.';
        }
        selectedSubPropertyPath = selectedKey ?
            selectedSubPropertyPath + selectedKey : selectedSubPropertyPath.slice(0, -1); // Remove extra . at the end.
        selectedSubPropertyText = level === 0 ?
            option.text : selectedSubPropertyText;
        this.setState({
            selectedSubPropertyText: selectedSubPropertyText,
            selectedSubPropertyPath: selectedSubPropertyPath
        }, function () {
            _this._updateReference();
        });
    };
    /**
     * Returns the dropdown options based on the type of the object passed.
     *
     * @param propValue - Object with which dropdown options are to to be built.
     * @param propertyPath - property path at the current level
     * @param recursiveCall - Indicates whether it is recursive call or not.
     * @param selectedKey - Key to be marked as selected.
     */
    DynamicDataWidgetEntry.prototype._getDropdownOptions = function (propValue, // tslint:disable-line:no-any
    propertyPath, recursiveCall, selectedKey) {
        var _this = this;
        var options = [];
        // If the propValue is not object type we don't want to create any dropdown for it.
        if (typeof propValue === 'object') {
            if (Array.isArray(propValue)) { // propertyValue is of type Array or Set.
                options = this._getDropdownOptions(propValue[0], propertyPath, true, selectedKey);
            }
            else if (propValue instanceof Set) {
                // Handle this case
            }
            else if (propValue instanceof Map) {
                propValue.forEach(function (value, key) {
                    options.push(_this._getDropdownOption(propertyPath, key, selectedKey));
                });
            }
            else { // propertyValue is of type object
                Object.keys(propValue).forEach(function (key) {
                    options.push(_this._getDropdownOption(propertyPath, key, selectedKey));
                });
            }
            // Adding empty option in the begining.
            // It is only for sub-property dropdowns.
            if (!recursiveCall && options.length > 1) {
                options.unshift({ key: '', text: '' });
            }
        }
        return options;
    };
    /**
     * Returns a dropdown option based on the proeprty path and the key.
     * @param propertyPath - property path to the current level
     * @param key - key with which the dropdown option is built.
     * @param selectedKey - Current selected key.
     */
    DynamicDataWidgetEntry.prototype._getDropdownOption = function (propertyPath, key, selectedKey) {
        if (key === selectedKey) {
            this._selectedSubPropertyText = key;
        }
        return {
            key: key,
            text: this._getOptionText(propertyPath, key) || key
        };
    };
    /**
     * Returns the text for the dropdown option, given the property path
     * @param propertyPath - property path to the current level
     * @param key - key for which the text is required.
     */
    DynamicDataWidgetEntry.prototype._getOptionText = function (propertyPath, key) {
        if (this._currentAnnotatedPropertyValue && this._currentAnnotatedPropertyValue.metadata) {
            var subPaths = propertyPath.split('.').slice(1);
            var metadata = this._currentAnnotatedPropertyValue.metadata;
            for (var _i = 0, subPaths_1 = subPaths; _i < subPaths_1.length; _i++) {
                var subPath = subPaths_1[_i];
                if (metadata && metadata.hasOwnProperty(subPath)) {
                    if (key === subPath) {
                        return metadata[subPath].title;
                    }
                    metadata = metadata[subPath].metadata;
                }
                else {
                    return undefined;
                }
            }
            if (metadata && metadata.hasOwnProperty(key)) {
                return metadata[key].title;
            }
        }
        else {
            return undefined;
        }
    };
    /**
     * Updates dynamic property's reference using the current state
     */
    DynamicDataWidgetEntry.prototype._updateReference = function () {
        if (this.props.selectedPropertyId) {
            var reference = this.props.selectedSource.id + ':' + this.props.selectedPropertyId;
            // check if the selectedPropertyId is returning an array
            if (this._isSelectedPropertyValueAnArray()) {
                reference += '[*]';
            }
            if (this.state.selectedSubPropertyPath) {
                var subPropertyPath = this._getSubPropertyPath();
                if (subPropertyPath) {
                    reference += ':' + subPropertyPath;
                }
            }
            this.props.value.setReference(reference);
            this.props.onChange(this.props.targetProperty, this.props.value);
        }
    };
    /**
     * Returns the max sub-property depth to show on the widget.
     */
    DynamicDataWidgetEntry.prototype._getMaxSubPropertyDepth = function () {
        var propertyValueDepth = this.props.propertyValueDepth;
        var maxDepth = MAX_PROPERTY_VALUE_DEPTH;
        if (propertyValueDepth !== undefined) {
            if (propertyValueDepth >= 0 && propertyValueDepth < 2) {
                maxDepth = propertyValueDepth;
            }
            else {
                Log.warn('propertyValueDepth', Text.format(Strings.InvalidPropertyValueDepthWarning, 'propertyValueDepth', 0, 2));
            }
        }
        return maxDepth;
    };
    /**
     * Returns the sub property value object based on the given property path.
     * @param propertyPath - property path to the current level
     */
    DynamicDataWidgetEntry.prototype._getSubPropertyValueObject = function (propertyPath) {
        var subPropertyValueObject; // tslint:disable-line:no-any
        var subPaths = propertyPath.split('.');
        // first sub path will always be the property
        var property = subPaths.shift();
        this._currentAnnotatedPropertyValue =
            this.props.selectedSource.getAnnotatedPropertyValue(property); /* tslint:disable-line:no-any */
        subPropertyValueObject = this._currentAnnotatedPropertyValue.sampleValue;
        // Look for the existence of sub-paths only if the subPropertyValueObject is an object type
        if (typeof subPropertyValueObject === 'object') {
            for (var _i = 0, subPaths_2 = subPaths; _i < subPaths_2.length; _i++) {
                var subPath = subPaths_2[_i];
                // If the sub-property is an array type, then the selected key will be of the type
                // <subPropertyName>[*]. Hence extracting the sub property name, accordingly.
                subPath = subPath.split(DynamicDataProvider._jsonPathArrayRegex)[0];
                // If the subPropertyValueObject is an array type recursively go inside of the array until
                // the value is not an array, and assign the value to the subPropertyValueObject at every step.
                while (Array.isArray(subPropertyValueObject)) {
                    subPropertyValueObject = subPropertyValueObject[0];
                }
                // At this point, subPropertyValueObject is not an array.
                // Look for sub-path only if subPropertyValueObject is an object type.
                if (typeof subPropertyValueObject === 'object') {
                    if (subPropertyValueObject.hasOwnProperty(subPath)) {
                        subPropertyValueObject = subPropertyValueObject[subPath];
                    }
                }
            }
        }
        return subPropertyValueObject;
    };
    DynamicDataWidgetEntry.prototype._isSelectedPropertyValueAnArray = function () {
        var _a = this.props, selectedSource = _a.selectedSource, selectedPropertyId = _a.selectedPropertyId;
        /* tslint:disable-next-line:no-any */
        var sampleValue = selectedSource.getAnnotatedPropertyValue(selectedPropertyId).sampleValue;
        return Array.isArray(sampleValue);
    };
    /**
     * Returns the sub-property path based on the current state. If the sub-property which is in the current
     * state, is not present on the reatltime object, then we return an empty string.
     *
     * @remarks
     * If the sub-property value associated with the subPropertyPath, is an array then the
     * subPropertyPath will have [*] notation appended at the end to support valid JSON Path notation.
     * Hence when reading the property id, we account for that and extract the name accordingly.
     */
    DynamicDataWidgetEntry.prototype._getSubPropertyPath = function () {
        var _a = this.props, selectedSource = _a.selectedSource, selectedPropertyId = _a.selectedPropertyId;
        var subPropertyReferencePath = '';
        var subPropertyPaths = this.state.selectedSubPropertyPath.split('.');
        /* tslint:disable-next-line:no-any */
        var propertyValueObject = selectedSource.getAnnotatedPropertyValue(selectedPropertyId).sampleValue;
        subPropertyPaths.forEach(function (subPropertyPath) {
            // If the sub-property is an array type, then the selected key will be of the type
            // <subPropertyName>[*]. Hence extracting the sub property name, accordingly.
            subPropertyPath = subPropertyPath.split(DynamicDataProvider._jsonPathArrayRegex)[0];
            if (propertyValueObject) {
                while (Array.isArray(propertyValueObject) && propertyValueObject.length) {
                    propertyValueObject = propertyValueObject[0];
                }
                if (propertyValueObject.hasOwnProperty(subPropertyPath)) { // It means propertyValueObject is an object.
                    subPropertyReferencePath += subPropertyPath;
                    var subPropertyValueObject = propertyValueObject[subPropertyPath]; /* tslint:disable-line:no-any */
                    if (Array.isArray(subPropertyValueObject)) {
                        subPropertyReferencePath += '[*]';
                    }
                    subPropertyReferencePath += '.';
                    propertyValueObject = subPropertyValueObject;
                }
                else {
                    // If the control is here, it means that the subProperty was not found in propertyValueObject.
                    // Hence the next iteration would get propertyValueObject as undefined.
                    propertyValueObject = undefined;
                }
            }
        });
        // remove extra '.' at the end, if any.
        return subPropertyReferencePath.replace(/\.$/, '');
    };
    tslib_1.__decorate([
        autobind
    ], DynamicDataWidgetEntry.prototype, "_onSubPropertySelectionChange", null);
    tslib_1.__decorate([
        autobind
    ], DynamicDataWidgetEntry.prototype, "_getDropdownOption", null);
    tslib_1.__decorate([
        autobind
    ], DynamicDataWidgetEntry.prototype, "_getOptionText", null);
    tslib_1.__decorate([
        autobind
    ], DynamicDataWidgetEntry.prototype, "_updateReference", null);
    tslib_1.__decorate([
        autobind
    ], DynamicDataWidgetEntry.prototype, "_getMaxSubPropertyDepth", null);
    return DynamicDataWidgetEntry;
}(React.Component));
export default DynamicDataWidgetEntry;
//# sourceMappingURL=DynamicDataWidgetEntry.js.map