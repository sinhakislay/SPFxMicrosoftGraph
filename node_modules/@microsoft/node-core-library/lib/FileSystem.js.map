{"version":3,"file":"FileSystem.js","sourceRoot":"","sources":["../src/FileSystem.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as pathUtilities from 'path';\r\nimport * as fs from 'fs';\r\nimport * as fsx from 'fs-extra';\r\n\r\nimport { Text, NewlineKind, Encoding } from './Text';\r\nimport { PosixModeBits } from './PosixModeBits';\r\n\r\n// The PosixModeBits are intended to be used with bitwise operations.\r\n// tslint:disable:no-bitwise\r\n\r\n/**\r\n * The options for FileSystem.readFolder()\r\n * @public\r\n */\r\nexport interface IFileSystemReadFolderOptions {\r\n  /**\r\n   * If true, returns the absolute paths of the files in the folder.\r\n   * Defaults to `false`.\r\n   */\r\n  absolutePaths?: boolean;\r\n}\r\n\r\n/**\r\n * The options for FileSystem.writeFile()\r\n * @public\r\n */\r\nexport interface IFileSystemWriteFileOptions {\r\n  /**\r\n   * If true, will ensure the folder is created before writing the file.\r\n   * Defaults to `false`.\r\n   */\r\n  ensureFolderExists?: boolean;\r\n\r\n  /**\r\n   * If specified, will normalize line endings to the specified style of newline.\r\n   * Defaults to `NewlineKind.None`.\r\n   */\r\n  convertLineEndings?: NewlineKind;\r\n\r\n  /**\r\n   * If specified, will change the encoding of the file that will be written.\r\n   * Defaults to `\"utf8\"`.\r\n   */\r\n  encoding?: Encoding;\r\n}\r\n\r\n/**\r\n * The options for FileSystem.readFile()\r\n * @public\r\n */\r\nexport interface IFileSystemReadFileOptions {\r\n  /**\r\n   * If specified, will change the encoding of the file that will be written.\r\n   * Defaults to `\"utf8\"`.\r\n   */\r\n  encoding?: Encoding;\r\n\r\n  /**\r\n   * If specified, will normalize line endings to the specified style of newline.\r\n   * Defaults to `NewlineKind.None`.\r\n   */\r\n  convertLineEndings?: NewlineKind;\r\n}\r\n\r\n/**\r\n * The options for FileSystem.move()\r\n * @public\r\n */\r\nexport interface IFileSystemMoveOptions {\r\n  /**\r\n   * The path of the existing object to be moved.\r\n   * The path may be absolute or relative.\r\n   */\r\n  sourcePath: string;\r\n\r\n  /**\r\n   * The new path for the object.\r\n   * The path may be absolute or relative.\r\n   */\r\n  destinationPath: string;\r\n\r\n  /**\r\n   * If true, will overwrite the file if it already exists. Defaults to true.\r\n   */\r\n  overwrite?: boolean;\r\n\r\n  /**\r\n   * If true, will ensure the folder is created before writing the file.\r\n   * Defaults to `false`.\r\n   */\r\n  ensureFolderExists?: boolean;\r\n}\r\n\r\n/**\r\n * The options for FileSystem.copyFile()\r\n * @public\r\n */\r\nexport interface IFileSystemCopyFileOptions {\r\n  /**\r\n   * The path of the existing object to be copied.\r\n   * The path may be absolute or relative.\r\n   */\r\n  sourcePath: string;\r\n\r\n  /**\r\n   * The path that the object will be copied to.\r\n   * The path may be absolute or relative.\r\n   */\r\n  destinationPath: string;\r\n}\r\n\r\n/**\r\n * The options for FileSystem.deleteFile()\r\n * @public\r\n*/\r\nexport interface IFileSystemDeleteFileOptions {\r\n  /**\r\n   * If true, will throw an exception if the file did not exist before `deleteFile()` was called.\r\n   * Defaults to `false`.\r\n   */\r\n  throwIfNotExists?: boolean;\r\n}\r\n\r\n/**\r\n * The parameters for `updateTimes()`.\r\n * Both times must be specified.\r\n * @public\r\n */\r\nexport interface IFileSystemUpdateTimeParameters {\r\n  /**\r\n   * The POSIX epoch time or Date when this was last accessed.\r\n   */\r\n  accessedTime: number | Date;\r\n\r\n  /**\r\n   * The POSIX epoch time or Date when this was last modified\r\n   */\r\n  modifiedTime: number | Date;\r\n}\r\n\r\n/**\r\n * The options for `FileSystem.createSymbolicLinkJunction()`, `createSymbolicLinkFile()`,\r\n * `createSymbolicLinkFolder()`,  and `createHardLink()`.\r\n *\r\n * @public\r\n */\r\nexport interface IFileSystemCreateLinkOptions {\r\n  /**\r\n   * The existing path that the symbolic link will point to.\r\n   */\r\n  linkTargetPath: string;\r\n\r\n  /**\r\n   * The new path for the new symlink link to be created.\r\n   */\r\n  newLinkPath: string;\r\n}\r\n\r\n/**\r\n * The FileSystem API provides a complete set of recommended operations for interacting with the file system.\r\n *\r\n * @remarks\r\n * We recommend to use this instead of the native `fs` API, because `fs` is a minimal set of low-level\r\n * primitives that must be mapped for each supported operating system. The FileSystem API takes a\r\n * philosophical approach of providing \"one obvious way\" to do each operation. We also prefer synchronous\r\n * operations except in cases where there would be a clear performance benefit for using async, since synchronous\r\n * code is much easier to read and debug. Also, indiscriminate parallelism has been seen to actually worsen\r\n * performance, versus improving it.\r\n *\r\n * Note that in the documentation, we refer to \"filesystem objects\", this can be a\r\n * file, folder, symbolic link, hard link, directory junction, etc.\r\n *\r\n * @public\r\n */\r\nexport class FileSystem {\r\n\r\n  // ===============\r\n  // COMMON OPERATIONS\r\n  // ===============\r\n\r\n  /**\r\n   * Returns true if the path exists on disk.\r\n   * Behind the scenes it uses `fs.existsSync()`.\r\n   * @remarks\r\n   * There is a debate about the fact that after `fs.existsSync()` returns true,\r\n   * the file might be deleted before fs.readSync() is called, which would imply that everybody\r\n   * should catch a `readSync()` exception, and nobody should ever use `fs.existsSync()`.\r\n   * We find this to be unpersuasive, since \"unexceptional exceptions\" really hinder the\r\n   * break-on-exception debugging experience. Also, throwing/catching is generally slow.\r\n   * @param path - The absolute or relative path to the filesystem object.\r\n   */\r\n  public static exists(path: string): boolean {\r\n    return fsx.existsSync(path);\r\n  }\r\n\r\n  /**\r\n   * Gets the statistics for a particular filesystem object.\r\n   * If the path is a link, this function follows the link and returns statistics about the link target.\r\n   * Behind the scenes it uses `fs.statSync()`.\r\n   * @param path - The absolute or relative path to the filesystem object.\r\n   */\r\n  public static getStatistics(path: string): fs.Stats {\r\n    return fsx.statSync(path);\r\n  }\r\n\r\n  /**\r\n   * Updates the accessed and modified timestamps of the filesystem object referenced by path.\r\n   * Behind the scenes it uses `fs.utimesSync()`.\r\n   * The caller should specify both times in the `times` parameter.\r\n   * @param path - The path of the file that should be modified.\r\n   * @param times - The times that the object should be updated to reflect.\r\n   */\r\n  public static updateTimes(path: string, times: IFileSystemUpdateTimeParameters): void {\r\n    // tslint:disable-next-line:no-any\r\n    fsx.utimesSync(path, times.accessedTime as any, times.modifiedTime as any);\r\n  }\r\n\r\n  /**\r\n   * Changes the permissions (i.e. file mode bits) for a filesystem object.\r\n   * Behind the scenes it uses `fs.chmodSync()`.\r\n   * @param path - The absolute or relative path to the object that should be updated.\r\n   * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum\r\n   */\r\n  public static changePosixModeBits(path: string, mode: PosixModeBits): void {\r\n    fs.chmodSync(path, mode);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the permissions (i.e. file mode bits) for a filesystem object.\r\n   * Behind the scenes it uses `fs.chmodSync()`.\r\n   * @param path - The absolute or relative path to the object that should be updated.\r\n   */\r\n  public static getPosixModeBits(path: string): PosixModeBits {\r\n    return FileSystem.getStatistics(path).mode;\r\n  }\r\n\r\n  /**\r\n   * Returns a 10-character string representation of a PosixModeBits value similar to what\r\n   * would be displayed by a command such as \"ls -l\" on a POSIX-like operating system.\r\n   * @remarks\r\n   * For example, `PosixModeBits.AllRead | PosixModeBits.AllWrite` would be formatted as \"-rw-rw-rw-\".\r\n   * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum\r\n   */\r\n  public static formatPosixModeBits(modeBits: PosixModeBits): string {\r\n    let result: string = '-';  // (later we may add support for additional states such as S_IFDIR or S_ISUID)\r\n\r\n    result += (modeBits & PosixModeBits.UserRead) ? 'r' : '-';\r\n    result += (modeBits & PosixModeBits.UserWrite) ? 'w' : '-';\r\n    result += (modeBits & PosixModeBits.UserExecute) ? 'x' : '-';\r\n\r\n    result += (modeBits & PosixModeBits.GroupRead) ? 'r' : '-';\r\n    result += (modeBits & PosixModeBits.GroupWrite) ? 'w' : '-';\r\n    result += (modeBits & PosixModeBits.GroupExecute) ? 'x' : '-';\r\n\r\n    result += (modeBits & PosixModeBits.OthersRead) ? 'r' : '-';\r\n    result += (modeBits & PosixModeBits.OthersWrite) ? 'w' : '-';\r\n    result += (modeBits & PosixModeBits.OthersExecute) ? 'x' : '-';\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Moves a file. The folder must exist, unless the `ensureFolderExists` option is provided.\r\n   * Behind the scenes it uses `fs-extra.moveSync()`\r\n   */\r\n  public static move(options: IFileSystemMoveOptions): void {\r\n    options = {\r\n      overwrite: true,\r\n      ensureFolderExists: false,\r\n      ...options\r\n    };\r\n\r\n    if (options.ensureFolderExists) {\r\n      FileSystem.ensureFolder(pathUtilities.basename(options.sourcePath));\r\n    }\r\n\r\n    fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });\r\n  }\r\n\r\n  // ===============\r\n  // FOLDER OPERATIONS\r\n  // ===============\r\n\r\n  /**\r\n   * Recursively creates a folder at a given path.\r\n   * Behind the scenes is uses `fs-extra.ensureDirSync()`.\r\n   * @remarks\r\n   * Throws an exception if anything in the folderPath is not a folder.\r\n   * @param folderPath - The absolute or relative path of the folder which should be created.\r\n   */\r\n  public static ensureFolder(folderPath: string): void {\r\n    fsx.ensureDirSync(folderPath);\r\n  }\r\n\r\n  /**\r\n   * Reads the contents of the folder, not including \".\" or \"..\".\r\n   * Behind the scenes it uses `fs.readdirSync()`.\r\n   * @param folderPath - The absolute or relative path to the folder which should be read.\r\n   * @param options - Optional settings that can change the behavior. Type: `IReadFolderOptions`\r\n   */\r\n  public static readFolder(folderPath: string, options?: IFileSystemReadFolderOptions): Array<string> {\r\n    options = {\r\n      absolutePaths: false,\r\n      ...options\r\n    };\r\n\r\n    if (!FileSystem.exists(folderPath)) {\r\n      throw new Error(`Folder does not exist: \"${folderPath}\"`);\r\n    }\r\n\r\n    const fileNames: Array<string> = fsx.readdirSync(folderPath);\r\n\r\n    if (options.absolutePaths) {\r\n      return fileNames.map(fileName => pathUtilities.resolve(folderPath, fileName));\r\n    }\r\n\r\n    return fileNames;\r\n  }\r\n\r\n  /**\r\n   * Deletes a folder, including all of its contents.\r\n   * Behind the scenes is uses `fs-extra.removeSync()`.\r\n   * @remarks\r\n   * Does not throw if the folderPath does not exist.\r\n   * @param folderPath - The absolute or relative path to the folder which should be deleted.\r\n   */\r\n  public static deleteFolder(folderPath: string): void {\r\n    fsx.removeSync(folderPath);\r\n  }\r\n\r\n  /**\r\n   * Deletes the content of a folder, but not the folder itself. Also ensures the folder exists.\r\n   * Behind the scenes it uses `fs-extra.emptyDirSync()`.\r\n   * @remarks\r\n   * This is a workaround for a common race condition, where the virus scanner holds a lock on the folder\r\n   * for a brief period after it was deleted, causing EBUSY errors for any code that tries to recreate the folder.\r\n   * @param folderPath - The absolute or relative path to the folder which should have its contents deleted.\r\n   */\r\n  public static ensureEmptyFolder(folderPath: string): void {\r\n    fsx.emptyDirSync(folderPath);\r\n  }\r\n\r\n  // ===============\r\n  // FILE OPERATIONS\r\n  // ===============\r\n\r\n  /**\r\n   * Writes a text string to a file on disk, overwriting the file if it already exists.\r\n   * Behind the scenes it uses `fs.writeFileSync()`.\r\n   * @remarks\r\n   * Throws an error if the folder doesn't exist, unless ensureFolder=true.\r\n   * @param filePath - The absolute or relative path of the file.\r\n   * @param contents - The text that should be written to the file.\r\n   * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`\r\n   */\r\n  public static writeFile(filePath: string, contents: string | Buffer, options?: IFileSystemWriteFileOptions): void {\r\n    options = {\r\n      ensureFolderExists: false,\r\n      convertLineEndings: undefined,\r\n      encoding: Encoding.Utf8,\r\n      ...options\r\n    };\r\n\r\n    if (options.ensureFolderExists) {\r\n      const folderPath: string = pathUtilities.dirname(filePath);\r\n      FileSystem.ensureFolder(folderPath);\r\n    }\r\n\r\n    contents = FileSystem._convertLineEndings(contents.toString(), options.convertLineEndings);\r\n\r\n    fsx.writeFileSync(filePath, contents, { encoding: options.encoding });\r\n  }\r\n\r\n  /**\r\n   * Writes a text string to a file on disk, appending to the file if it already exists.\r\n   * Behind the scenes it uses `fs.appendFileSync()`.\r\n   * @remarks\r\n   * Throws an error if the folder doesn't exist, unless ensureFolder=true.\r\n   * @param filePath - The absolute or relative path of the file.\r\n   * @param contents - The text that should be written to the file.\r\n   * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`\r\n   */\r\n  public static appendToFile(filePath: string, contents: string | Buffer, options?: IFileSystemWriteFileOptions): void {\r\n    options = {\r\n      ensureFolderExists: false,\r\n      convertLineEndings: undefined,\r\n      encoding: Encoding.Utf8,\r\n      ...options\r\n    };\r\n\r\n    if (options.ensureFolderExists) {\r\n      const folderPath: string = pathUtilities.dirname(filePath);\r\n      FileSystem.ensureFolder(folderPath);\r\n    }\r\n\r\n    contents = FileSystem._convertLineEndings(contents.toString(), options.convertLineEndings);\r\n\r\n    fsx.appendFileSync(filePath, contents, { encoding: options.encoding });\r\n  }\r\n\r\n  /**\r\n   * Reads the contents of a file into a string.\r\n   * Behind the scenes it uses `fs.readFileSync()`.\r\n   * @param filePath - The relative or absolute path to the file whose contents should be read.\r\n   * @param options - Optional settings that can change the behavior. Type: `IReadFileOptions`\r\n   */\r\n  public static readFile(filePath: string, options?: IFileSystemReadFileOptions): string {\r\n    options = {\r\n      encoding: Encoding.Utf8,\r\n      convertLineEndings: undefined,\r\n      ...options\r\n    };\r\n\r\n    const contents: string = FileSystem.readFileToBuffer(filePath).toString(options.encoding);\r\n    return FileSystem._convertLineEndings(contents, options.convertLineEndings);\r\n  }\r\n\r\n  /**\r\n   * Reads the contents of a file into a buffer.\r\n   * Behind the scenes is uses `fs.readFileSync()`.\r\n   * @param filePath - The relative or absolute path to the file whose contents should be read.\r\n   */\r\n  public static readFileToBuffer(filePath: string): Buffer {\r\n    return fsx.readFileSync(filePath);\r\n  }\r\n\r\n  /**\r\n   * Copies a file from one location to another.\r\n   * By default, destinationPath is overwritten if it already exists.\r\n   * Behind the scenes it uses `fs.copyFileSync()`.\r\n   */\r\n  public static copyFile(options: IFileSystemCopyFileOptions): void {\r\n    fsx.copySync(options.sourcePath, options.destinationPath);\r\n  }\r\n\r\n  /**\r\n   * Deletes a file. Can optionally throw if the file doesn't exist.\r\n   * Behind the scenes it uses `fs.unlinkSync()`.\r\n   * @param filePath - The absolute or relative path to the file that should be deleted.\r\n   * @param options - Optional settings that can change the behavior. Type: `IDeleteFileOptions`\r\n   */\r\n  public static deleteFile(filePath: string, options?: IFileSystemDeleteFileOptions): void {\r\n    options = {\r\n      throwIfNotExists: false,\r\n      ...options\r\n    };\r\n\r\n    if (options.throwIfNotExists) {\r\n      fsx.unlinkSync(filePath);\r\n    } else {\r\n      try {\r\n        fsx.unlinkSync(filePath);\r\n      } catch (error) {\r\n        /* no-op */\r\n      }\r\n    }\r\n  }\r\n\r\n  // ===============\r\n  // LINK OPERATIONS\r\n  // ===============\r\n\r\n  /**\r\n   * Gets the statistics of a filesystem object. Does NOT follow the link to its target.\r\n   * Behind the scenes it uses `fs.lstatSync()`.\r\n   * @param path - The absolute or relative path to the filesystem object.\r\n   */\r\n  public static getLinkStatistics(path: string): fs.Stats {\r\n    return fsx.lstatSync(path);\r\n  }\r\n\r\n  /**\r\n   * Creates a Windows \"directory junction\". Behaves like `createSymbolicLinkToFile()` on other platforms.\r\n   * Behind the scenes it uses `fs.symlinkSync()`.\r\n   */\r\n  public static createSymbolicLinkJunction(options: IFileSystemCreateLinkOptions): void {\r\n    // For directories, we use a Windows \"junction\".  On POSIX operating systems, this produces a regular symlink.\r\n    fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'junction');\r\n  }\r\n\r\n  /**\r\n   * Creates a symbolic link to a file (on Windows this requires elevated permissionsBits).\r\n   * Behind the scenes it uses `fs.symlinkSync()`.\r\n   */\r\n  public static createSymbolicLinkFile(options: IFileSystemCreateLinkOptions): void {\r\n    fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'file');\r\n  }\r\n\r\n  /**\r\n   * Creates a symbolic link to a folder (on Windows this requires elevated permissionsBits).\r\n   * Behind the scenes it uses `fs.symlinkSync()`.\r\n   */\r\n  public static createSymbolicLinkFolder(options: IFileSystemCreateLinkOptions): void {\r\n    fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'dir');\r\n  }\r\n\r\n  /**\r\n   * Creates a hard link.\r\n   * Behind the scenes it uses `fs.linkSync()`.\r\n   */\r\n  public static createHardLink(options: IFileSystemCreateLinkOptions): void {\r\n    fsx.linkSync(options.linkTargetPath, options.newLinkPath);\r\n  }\r\n\r\n  /**\r\n   * Follows a link to its destination and returns the absolute path to the final target of the link.\r\n   * Behind the scenes it uses `fs.realpathSync()`.\r\n   * @param linkPath - The path to the link.\r\n   */\r\n  public static getRealPath(linkPath: string): string {\r\n    return fsx.realpathSync(linkPath);\r\n  }\r\n\r\n  /**\r\n   * A helper function that converts line endings on a string.\r\n   * @param text - The text to be normalized.\r\n   * @param lineEndings - The style of line endings to use.\r\n   */\r\n  private static _convertLineEndings(text: string, lineEndings: NewlineKind | undefined): string {\r\n    switch (lineEndings) {\r\n      case NewlineKind.CrLf:\r\n        return Text.convertToCrLf(text);\r\n      case NewlineKind.Lf:\r\n        return Text.convertToLf(text);\r\n      default:\r\n        return text;\r\n    }\r\n  }\r\n}\r\n"]}