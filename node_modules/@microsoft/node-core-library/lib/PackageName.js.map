{"version":3,"file":"PackageName.js","sourceRoot":"","sources":["../src/PackageName.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/**\r\n * A package name that has been separated into its scope and unscoped name.\r\n *\r\n * @public\r\n */\r\nexport interface IParsedPackageName {\r\n  /**\r\n   * The parsed NPM scope, or an empty string if there was no scope.  The scope value will\r\n   * always include the at-sign.\r\n   * @remarks\r\n   * For example, if the parsed input was \"\\@scope/example\", then scope would be \"\\@scope\".\r\n   */\r\n  scope: string;\r\n\r\n  /**\r\n   * The parsed NPM package name without the scope.\r\n   * @remarks\r\n   * For example, if the parsed input was \"\\@scope/example\", then the name would be \"example\".\r\n   */\r\n  unscopedName: string;\r\n}\r\n\r\n/**\r\n * Result object returned by {@link PackageName.tryParse}\r\n *\r\n * @public\r\n */\r\nexport interface IParsedPackageNameOrError extends IParsedPackageName {\r\n  /**\r\n   * If the input string could not be parsed, then this string will contain a nonempty\r\n   * error message.  Otherwise it will be an empty string.\r\n   */\r\n  error: string;\r\n}\r\n\r\n/**\r\n * Various functions for working with package names that may include scopes.\r\n *\r\n * @public\r\n */\r\nexport class PackageName {\r\n  // encodeURIComponent() escapes all characters except:  A-Z a-z 0-9 - _ . ! ~ * ' ( )\r\n  // However, these are disallowed because they are shell characters:       ! ~ * ' ( )\r\n  private static readonly invalidNameCharactersRegExp: RegExp = /[^A-Za-z0-9\\-_\\.]/;\r\n\r\n  /**\r\n   * This attempts to parse a package name that may include a scope component.\r\n   * The packageName must not be an empty string.\r\n   * @remarks\r\n   * This function will not throw an exception.\r\n   *\r\n   * @returns an {@link IParsedPackageNameOrError} structure whose `error` property will be\r\n   * nonempty if the string could not be parsed.\r\n   */\r\n  public static tryParse(packageName: string): IParsedPackageNameOrError {\r\n    const result: IParsedPackageNameOrError = {\r\n      scope: '',\r\n      unscopedName: '',\r\n      error: ''\r\n    };\r\n\r\n    let input: string = packageName;\r\n\r\n    if (input === null || input === undefined) {\r\n      result.error = 'The package name must not be null or undefined';\r\n      return result;\r\n    }\r\n\r\n    // Rule from npmjs.com:\r\n    // \"The name must be less than or equal to 214 characters. This includes the scope for scoped packages.\"\r\n    if (packageName.length > 214) {\r\n      // Don't attempt to parse a ridiculously long input\r\n      result.error = 'The package name cannot be longer than 214 characters';\r\n      return result;\r\n    }\r\n\r\n    if (input[0] === '@') {\r\n      const indexOfScopeSlash: number = input.indexOf('/');\r\n      if (indexOfScopeSlash <= 0) {\r\n        result.scope = input;\r\n        result.error = `Error parsing \"${packageName}\": The scope must be followed by a slash`;\r\n        return result;\r\n      }\r\n\r\n      // Extract the scope substring\r\n      result.scope = input.substr(0, indexOfScopeSlash);\r\n\r\n      input = input.substr(indexOfScopeSlash + 1);\r\n    }\r\n\r\n    result.unscopedName = input;\r\n\r\n    if (result.scope === '@') {\r\n      result.error = `Error parsing \"${packageName}\": The scope name cannot be empty`;\r\n      return result;\r\n    }\r\n\r\n    if (result.unscopedName === '') {\r\n      result.error = 'The package name must not be empty';\r\n      return result;\r\n    }\r\n\r\n    // Rule from npmjs.com:\r\n    // \"The name can't start with a dot or an underscore.\"\r\n    if (result.unscopedName[0] === '.' || result.unscopedName[0] === '_') {\r\n      result.error = `The package name \"${packageName}\" starts with an invalid character`;\r\n      return result;\r\n    }\r\n\r\n    // Convert \"@scope/unscoped-name\" --> \"scopeunscoped-name\"\r\n    const nameWithoutScopeSymbols: string = (result.scope ? result.scope.slice(1, -1) : '')\r\n      + result.unscopedName;\r\n\r\n    // \"New packages must not have uppercase letters in the name.\"\r\n    // This can't be enforced because \"old\" packages are still actively maintained.\r\n    // Example: https://www.npmjs.com/package/Base64\r\n    // However it's pretty reasonable to require the scope to be lower case\r\n    if (result.scope !== result.scope.toLowerCase()) {\r\n      result.error = `The package scope \"${result.scope}\" must not contain upper case characters`;\r\n      return result;\r\n    }\r\n\r\n    // \"The name ends up being part of a URL, an argument on the command line, and a folder name.\r\n    // Therefore, the name can't contain any non-URL-safe characters\"\r\n    const match: RegExpMatchArray | null = nameWithoutScopeSymbols.match(PackageName.invalidNameCharactersRegExp);\r\n    if (match) {\r\n      result.error = `The package name \"${packageName}\" contains an invalid character: \"${match[0]}\"`;\r\n      return result;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Same as {@link PackageName.tryParse}, except this throws an exception if the input\r\n   * cannot be parsed.\r\n   * @remarks\r\n   * The packageName must not be an empty string.\r\n   */\r\n  public static parse(packageName: string): IParsedPackageName {\r\n    const result: IParsedPackageNameOrError = PackageName.tryParse(packageName);\r\n    if (result.error) {\r\n      throw new Error(result.error);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * {@inheritDoc IParsedPackageName.scope}\r\n   */\r\n  public static getScope(packageName: string): string {\r\n    return PackageName.parse(packageName).scope;\r\n  }\r\n\r\n  /**\r\n   * {@inheritDoc IParsedPackageName.unscopedName}\r\n   */\r\n  public static getUnscopedName(packageName: string): string {\r\n    return PackageName.parse(packageName).unscopedName;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the specified package name is valid, or false otherwise.\r\n   * @remarks\r\n   * This function will not throw an exception.\r\n   */\r\n  public static isValidName(packageName: string): boolean {\r\n    const result: IParsedPackageNameOrError = PackageName.tryParse(packageName);\r\n    return !result.error;\r\n  }\r\n\r\n  /**\r\n   * Throws an exception if the specified name is not a valid package name.\r\n   * The packageName must not be an empty string.\r\n   */\r\n  public static validate(packageName: string): void {\r\n    PackageName.parse(packageName);\r\n  }\r\n\r\n  /**\r\n   * Combines an optional package scope with an unscoped root name.\r\n   * @param scope - Must be either an empty string, or a scope name such as \"\\@example\"\r\n   * @param unscopedName - Must be a nonempty package name that does not contain a scope\r\n   * @returns A full package name such as \"\\@example/some-library\".\r\n   */\r\n  public static combineParts(scope: string, unscopedName: string): string {\r\n    if (scope !== '') {\r\n      if (scope[0] !== '@') {\r\n        throw new Error('The scope must start with an \"@\" character');\r\n      }\r\n    }\r\n    if (scope.indexOf('/') >= 0) {\r\n      throw new Error('The scope must not contain a \"/\" character');\r\n    }\r\n\r\n    if (unscopedName[0] === '@') {\r\n      throw new Error('The unscopedName cannot start with an \"@\" character');\r\n    }\r\n    if (unscopedName.indexOf('/') >= 0) {\r\n      throw new Error('The unscopedName must not contain a \"/\" character');\r\n    }\r\n\r\n    let result: string;\r\n    if (scope === '') {\r\n      result = unscopedName;\r\n    } else {\r\n      result = scope + '/' + unscopedName;\r\n    }\r\n\r\n    // Make sure the result is a valid package name\r\n    PackageName.validate(result);\r\n\r\n    return result;\r\n  }\r\n}\r\n"]}