"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const ITerminalProvider_1 = require("./ITerminalProvider");
const Colors_1 = require("./Colors");
/**
 * This class facilitates writing to a console.
 *
 * @beta
 */
class Terminal {
    constructor(provider) {
        this._providers = new Set();
        this._providers.add(provider);
    }
    /**
     * Subscribe a new terminal provider.
     */
    registerProvider(provider) {
        this._providers.add(provider);
    }
    /**
     * Unsubscribe a terminal provider. If the provider isn't subscribed, this function does nothing.
     */
    unregisterProvider(provider) {
        if (this._providers.has(provider)) {
            this._providers.delete(provider);
        }
    }
    /**
     * Write a generic message to the terminal
     */
    write(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.log);
    }
    /**
     * Write a generic message to the terminal, followed by a newline
     */
    writeLine(...messageParts) {
        this.write(...messageParts, Colors_1.eolSequence);
    }
    /**
     * Write a warning message to the console with yellow text.
     *
     * @remarks
     * The yellow color takes precedence over any other foreground colors set.
     */
    writeWarning(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => (Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part), { foregroundColor: Colors_1.ColorValue.Yellow }))), ITerminalProvider_1.TerminalProviderSeverity.warning);
    }
    /**
     * Write a warning message to the console with yellow text, followed by a newline.
     *
     * @remarks
     * The yellow color takes precedence over any other foreground colors set.
     */
    writeWarningLine(...messageParts) {
        this._writeSegmentsToProviders([
            ...messageParts.map((part) => (Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part), { foregroundColor: Colors_1.ColorValue.Yellow }))),
            Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.warning);
    }
    /**
     * Write an error message to the console with red text.
     *
     * @remarks
     * The red color takes precedence over any other foreground colors set.
     */
    writeError(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => (Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part), { foregroundColor: Colors_1.ColorValue.Red }))), ITerminalProvider_1.TerminalProviderSeverity.error);
    }
    /**
     * Write an error message to the console with red text, followed by a newline.
     *
     * @remarks
     * The red color takes precedence over any other foreground colors set.
     */
    writeErrorLine(...messageParts) {
        this._writeSegmentsToProviders([
            ...messageParts.map((part) => (Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part), { foregroundColor: Colors_1.ColorValue.Red }))),
            Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.error);
    }
    /**
     * Write a verbose-level message.
     */
    writeVerbose(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.verbose);
    }
    /**
     * Write a verbose-level message followed by a newline.
     */
    writeVerboseLine(...messageParts) {
        this.writeVerbose(...messageParts, Colors_1.eolSequence);
    }
    _writeSegmentsToProviders(segments, severity) {
        const withColorText = {};
        const withoutColorText = {};
        let withColorLines;
        let withoutColorLines;
        this._providers.forEach((provider) => {
            const eol = provider.eolCharacter;
            let textToWrite;
            if (provider.supportsColor) {
                if (!withColorLines) {
                    withColorLines = this._serializeFormattableTextSegments(segments, true);
                }
                if (!withColorText[eol]) {
                    withColorText[eol] = withColorLines.join(eol);
                }
                textToWrite = withColorText[eol];
            }
            else {
                if (!withoutColorLines) {
                    withoutColorLines = this._serializeFormattableTextSegments(segments, false);
                }
                if (!withoutColorText[eol]) {
                    withoutColorText[eol] = withoutColorLines.join(eol);
                }
                textToWrite = withoutColorText[eol];
            }
            provider.write(textToWrite, severity);
        });
    }
    _serializeFormattableTextSegments(segments, withColor) {
        const lines = [];
        let segmentsToJoin = [];
        let lastSegmentWasEol = false;
        for (let i = 0; i < segments.length; i++) {
            const segment = Colors_1.Colors._normalizeStringOrColorableSequence(segments[i]);
            lastSegmentWasEol = !!segment.isEol;
            if (lastSegmentWasEol) {
                lines.push(segmentsToJoin.join(''));
                segmentsToJoin = [];
            }
            else {
                if (withColor) {
                    const startColorCodes = [];
                    const endColorCodes = [];
                    switch (segment.foregroundColor) {
                        case Colors_1.ColorValue.Black: {
                            startColorCodes.push(30);
                            endColorCodes.push(39);
                            break;
                        }
                        case Colors_1.ColorValue.Red: {
                            startColorCodes.push(31);
                            endColorCodes.push(39);
                            break;
                        }
                        case Colors_1.ColorValue.Green: {
                            startColorCodes.push(32);
                            endColorCodes.push(39);
                            break;
                        }
                        case Colors_1.ColorValue.Yellow: {
                            startColorCodes.push(33);
                            endColorCodes.push(39);
                            break;
                        }
                        case Colors_1.ColorValue.Blue: {
                            startColorCodes.push(34);
                            endColorCodes.push(39);
                            break;
                        }
                        case Colors_1.ColorValue.Magenta: {
                            startColorCodes.push(35);
                            endColorCodes.push(39);
                            break;
                        }
                        case Colors_1.ColorValue.Cyan: {
                            startColorCodes.push(36);
                            endColorCodes.push(39);
                            break;
                        }
                        case Colors_1.ColorValue.White: {
                            startColorCodes.push(37);
                            endColorCodes.push(39);
                            break;
                        }
                        case Colors_1.ColorValue.Gray: {
                            startColorCodes.push(90);
                            endColorCodes.push(39);
                            break;
                        }
                    }
                    switch (segment.backgroundColor) {
                        case Colors_1.ColorValue.Black: {
                            startColorCodes.push(40);
                            endColorCodes.push(49);
                            break;
                        }
                        case Colors_1.ColorValue.Red: {
                            startColorCodes.push(41);
                            endColorCodes.push(49);
                            break;
                        }
                        case Colors_1.ColorValue.Green: {
                            startColorCodes.push(42);
                            endColorCodes.push(49);
                            break;
                        }
                        case Colors_1.ColorValue.Yellow: {
                            startColorCodes.push(43);
                            endColorCodes.push(49);
                            break;
                        }
                        case Colors_1.ColorValue.Blue: {
                            startColorCodes.push(44);
                            endColorCodes.push(49);
                            break;
                        }
                        case Colors_1.ColorValue.Magenta: {
                            startColorCodes.push(45);
                            endColorCodes.push(49);
                            break;
                        }
                        case Colors_1.ColorValue.Cyan: {
                            startColorCodes.push(46);
                            endColorCodes.push(49);
                            break;
                        }
                        case Colors_1.ColorValue.White: {
                            startColorCodes.push(47);
                            endColorCodes.push(49);
                            break;
                        }
                        case Colors_1.ColorValue.Gray: {
                            startColorCodes.push(100);
                            endColorCodes.push(49);
                            break;
                        }
                    }
                    if (segment.textAttributes) {
                        for (const textAttribute of segment.textAttributes) {
                            switch (textAttribute) {
                                case Colors_1.TextAttribute.Bold: {
                                    startColorCodes.push(1);
                                    endColorCodes.push(21);
                                    break;
                                }
                                case Colors_1.TextAttribute.Dim: {
                                    startColorCodes.push(2);
                                    endColorCodes.push(22);
                                    break;
                                }
                                case Colors_1.TextAttribute.Underline: {
                                    startColorCodes.push(4);
                                    endColorCodes.push(24);
                                    break;
                                }
                                case Colors_1.TextAttribute.Blink: {
                                    startColorCodes.push(5);
                                    endColorCodes.push(25);
                                    break;
                                }
                                case Colors_1.TextAttribute.InvertColor: {
                                    startColorCodes.push(7);
                                    endColorCodes.push(27);
                                    break;
                                }
                                case Colors_1.TextAttribute.Hidden: {
                                    startColorCodes.push(8);
                                    endColorCodes.push(28);
                                    break;
                                }
                            }
                        }
                    }
                    for (let j = 0; j < startColorCodes.length; j++) {
                        const code = startColorCodes[j];
                        segmentsToJoin.push(...[
                            '\u001b[',
                            code.toString(),
                            'm'
                        ]);
                    }
                    segmentsToJoin.push(segment.text);
                    for (let j = endColorCodes.length - 1; j >= 0; j--) {
                        const code = endColorCodes[j];
                        segmentsToJoin.push(...[
                            '\u001b[',
                            code.toString(),
                            'm'
                        ]);
                    }
                }
                else {
                    segmentsToJoin.push(segment.text);
                }
            }
        }
        if (segmentsToJoin.length > 0) {
            lines.push(segmentsToJoin.join(''));
        }
        if (lastSegmentWasEol) {
            lines.push('');
        }
        return lines;
    }
}
exports.Terminal = Terminal;
//# sourceMappingURL=Terminal.js.map