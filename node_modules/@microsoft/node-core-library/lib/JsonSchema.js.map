{"version":3,"file":"JsonSchema.js","sourceRoot":"","sources":["../src/JsonSchema.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as os from 'os';\r\nimport * as path from 'path';\r\nimport Validator = require('z-schema');\r\n\r\nimport { JsonFile } from './JsonFile';\r\nimport { FileSystem } from './FileSystem';\r\n\r\ninterface ISchemaWithId {\r\n  id: string | undefined;\r\n}\r\n\r\n/**\r\n * Callback function arguments for JsonSchema.validateObjectWithCallback();\r\n * @public\r\n */\r\nexport interface IJsonSchemaErrorInfo {\r\n  /**\r\n   * The z-schema error tree, formatted as an indented text string.\r\n   */\r\n  details: string;\r\n}\r\n\r\n/**\r\n * Options for JsonSchema.validateObject()\r\n * @public\r\n */\r\nexport interface IJsonSchemaValidateOptions {\r\n  /**\r\n   * A custom header that will be used to report schema errors.\r\n   * @remarks\r\n   * If omitted, the default header is \"JSON validation failed:\".  The error message starts with\r\n   * the header, followed by the full input filename, followed by the z-schema error tree.\r\n   * If you wish to customize all aspects of the error message, use JsonFile.loadAndValidateWithCallback()\r\n   * or JsonSchema.validateObjectWithCallback().\r\n   */\r\n  customErrorHeader?: string;\r\n}\r\n\r\n/**\r\n * Options for JsonSchema.fromFile()\r\n * @public\r\n */\r\nexport interface IJsonSchemaFromFileOptions {\r\n  /**\r\n   * Other schemas that this schema references, e.g. via the \"$ref\" directive.\r\n   * @remarks\r\n   * The tree of dependent schemas may reference the same schema more than once.\r\n   * However, if the same schema \"id\" is used by two different JsonSchema instances,\r\n   * an error will be reported.  This means you cannot load the same filename twice\r\n   * and use them both together, and you cannot have diamond dependencies on different\r\n   * versions of the same schema.  Although technically this would be possible to support,\r\n   * it normally indicates an error or design problem.\r\n   *\r\n   * JsonSchema also does not allow circular references between schema dependencies.\r\n   */\r\n  dependentSchemas?: JsonSchema[];\r\n}\r\n\r\n/**\r\n * Represents a JSON schema that can be used to validate JSON data files loaded by the JsonFile class.\r\n * @remarks\r\n * The schema itself is normally loaded and compiled later, only if it is actually required to validate\r\n * an input.  To avoid schema errors at runtime, it's recommended to create a unit test that calls\r\n * JsonSchema.ensureCompiled() for each of your schema objects.\r\n *\r\n * @public\r\n */\r\nexport class JsonSchema {\r\n  private _dependentSchemas: JsonSchema[] = [];\r\n  private _filename: string = '';\r\n  private _validator: Validator | undefined = undefined;\r\n  private _schemaObject: Object | undefined = undefined;\r\n\r\n  /**\r\n   * Registers a JsonSchema that will be loaded from a file on disk.\r\n   * @remarks\r\n   * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated\r\n   * until it the schema is actually used.\r\n   */\r\n  public static fromFile(filename: string, options?: IJsonSchemaFromFileOptions): JsonSchema {\r\n    // This is a quick and inexpensive test to avoid the catch the most common errors early.\r\n    // Full validation will happen later in JsonSchema.compile().\r\n    if (!FileSystem.exists(filename)) {\r\n      throw new Error('Schema file not found: ' + filename);\r\n    }\r\n\r\n    const schema: JsonSchema = new JsonSchema();\r\n    schema._filename = filename;\r\n\r\n    if (options) {\r\n      schema._dependentSchemas = options.dependentSchemas || [];\r\n    }\r\n\r\n    return schema;\r\n  }\r\n\r\n  /**\r\n   * Registers a JsonSchema that will be loaded from a file on disk.\r\n   * @remarks\r\n   * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated\r\n   * until it the schema is actually used.\r\n   */\r\n  public static fromLoadedObject(schemaObject: Object): JsonSchema {\r\n    const schema: JsonSchema = new JsonSchema();\r\n    schema._schemaObject = schemaObject;\r\n    return schema;\r\n  }\r\n\r\n  private static _collectDependentSchemas(collectedSchemas: JsonSchema[], dependentSchemas: JsonSchema[],\r\n    seenObjects: Set<Object>, seenIds: Set<string>): void {\r\n\r\n    for (const dependentSchema of dependentSchemas) {\r\n      // It's okay for the same schema to appear multiple times in the tree, but we only process it once\r\n      if (seenObjects.has(dependentSchema)) {\r\n        continue;\r\n      }\r\n      seenObjects.add(dependentSchema);\r\n\r\n      const schemaId: string = dependentSchema._ensureLoaded();\r\n      if (schemaId === '') {\r\n        throw new Error(`This schema ${dependentSchema.shortName} cannot be referenced`\r\n          + ' because is missing the \"id\" field');\r\n      }\r\n      if (seenIds.has(schemaId)) {\r\n        throw new Error(`This schema ${dependentSchema.shortName} has the same \"id\" as`\r\n        + ' another schema in this set');\r\n      }\r\n\r\n      seenIds.add(schemaId);\r\n\r\n      collectedSchemas.push(dependentSchema);\r\n\r\n      JsonSchema._collectDependentSchemas(collectedSchemas, dependentSchema._dependentSchemas,\r\n        seenObjects, seenIds);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Used to nicely format the ZSchema error tree.\r\n   */\r\n  private static _formatErrorDetails(errorDetails: Validator.SchemaErrorDetail[]): string {\r\n    return JsonSchema._formatErrorDetailsHelper(errorDetails, '', '');\r\n  }\r\n\r\n  /**\r\n   * Used by _formatErrorDetails.\r\n   */\r\n  private static _formatErrorDetailsHelper(errorDetails: Validator.SchemaErrorDetail[], indent: string,\r\n    buffer: string): string {\r\n    for (const errorDetail of errorDetails) {\r\n\r\n      buffer += os.EOL + indent + `Error: ${errorDetail.path}`;\r\n\r\n      if (errorDetail.description) {\r\n        const MAX_LENGTH: number = 40;\r\n        let truncatedDescription: string = errorDetail.description.trim();\r\n        if (truncatedDescription.length > MAX_LENGTH) {\r\n          truncatedDescription = truncatedDescription.substr(0, MAX_LENGTH - 3)\r\n            + '...';\r\n        }\r\n\r\n        buffer += ` (${truncatedDescription})`;\r\n      }\r\n\r\n      buffer += os.EOL + indent + `       ${errorDetail.message}`;\r\n\r\n      if (errorDetail.inner) {\r\n        buffer = JsonSchema._formatErrorDetailsHelper(errorDetail.inner, indent + '  ', buffer);\r\n      }\r\n    }\r\n\r\n    return buffer;\r\n  }\r\n\r\n  /**\r\n   * Returns a short name for this schema, for use in error messages.\r\n   * @remarks\r\n   * If the schema was loaded from a file, then the base filename is used.  Otherwise, the \"id\"\r\n   * field is used if available.\r\n   */\r\n  public get shortName(): string {\r\n    if (!this._filename) {\r\n      if (this._schemaObject) {\r\n        const schemaWithId: ISchemaWithId = this._schemaObject as ISchemaWithId;\r\n        if (schemaWithId.id) {\r\n          return schemaWithId.id;\r\n        }\r\n      }\r\n      return '(anonymous schema)';\r\n    } else {\r\n      return path.basename(this._filename);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If not already done, this loads the schema from disk and compiles it.\r\n   * @remarks\r\n   * Any dependencies will be compiled as well.\r\n   */\r\n  public ensureCompiled(): void {\r\n    this._ensureLoaded();\r\n\r\n    if (!this._validator) {\r\n      // Don't assign this to _validator until we're sure everything was successful\r\n      const newValidator: Validator = new Validator({\r\n        breakOnFirstError: false,\r\n        noTypeless: true,\r\n        noExtraKeywords: true\r\n      });\r\n\r\n      const anythingSchema: Object = {\r\n        'type': [\r\n          'array',\r\n          'boolean',\r\n          'integer',\r\n          'number',\r\n          'object',\r\n          'string'\r\n        ]\r\n      };\r\n\r\n      // tslint:disable-next-line:no-any\r\n      (newValidator as any).setRemoteReference('http://json-schema.org/draft-04/schema',  anythingSchema);\r\n\r\n      const collectedSchemas: JsonSchema[] = [];\r\n      const seenObjects: Set<Object> = new Set<Object>();\r\n      const seenIds: Set<string> = new Set<string>();\r\n\r\n      JsonSchema._collectDependentSchemas(collectedSchemas, this._dependentSchemas, seenObjects, seenIds);\r\n\r\n      // Validate each schema in order.  We specifically do not supply them all together, because we want\r\n      // to make sure that circular references will fail to validate.\r\n      for (const collectedSchema of collectedSchemas) {\r\n        if (!newValidator.validateSchema(collectedSchema._schemaObject)) {\r\n          throw new Error(`Failed to validate schema \"${collectedSchema.shortName}\":` + os.EOL\r\n            + JsonSchema._formatErrorDetails(newValidator.getLastErrors()));\r\n        }\r\n      }\r\n\r\n      this._validator = newValidator;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates the specified JSON object against this JSON schema.  If the validation fails,\r\n   * an exception will be thrown.\r\n   * @param jsonObject - The JSON data to be validated\r\n   * @param filenameForErrors - The filename that the JSON data was available, or an empty string\r\n   *    if not applicable\r\n   * @param options - Other options that control the validation\r\n   */\r\n  public validateObject(jsonObject: Object, filenameForErrors: string, options?: IJsonSchemaValidateOptions): void {\r\n    this.validateObjectWithCallback(jsonObject, (errorInfo: IJsonSchemaErrorInfo) => {\r\n      const prefix: string = (options && options.customErrorHeader) ? options.customErrorHeader\r\n        : 'JSON validation failed:';\r\n\r\n      throw new Error(prefix + os.EOL +\r\n        filenameForErrors + os.EOL + errorInfo.details);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validates the specified JSON object against this JSON schema.  If the validation fails,\r\n   * a callback is called for each validation error.\r\n   */\r\n  public validateObjectWithCallback(jsonObject: Object,\r\n    errorCallback: (errorInfo: IJsonSchemaErrorInfo) => void): void {\r\n\r\n    this.ensureCompiled();\r\n\r\n    if (!this._validator!.validate(jsonObject, this._schemaObject)) {\r\n      const errorDetails: string = JsonSchema._formatErrorDetails(this._validator!.getLastErrors());\r\n\r\n      const args: IJsonSchemaErrorInfo = {\r\n        details: errorDetails\r\n      };\r\n      errorCallback(args);\r\n    }\r\n  }\r\n\r\n  private constructor() {\r\n  }\r\n\r\n  private _ensureLoaded(): string {\r\n    if (!this._schemaObject) {\r\n      this._schemaObject = JsonFile.load(this._filename);\r\n    }\r\n    return (this._schemaObject as ISchemaWithId).id || '';\r\n  }\r\n}\r\n"]}