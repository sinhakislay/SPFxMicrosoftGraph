/**
 * Parses the process start time from the contents of a linux /proc/[pid]/stat file.
 * @param stat The contents of a linux /proc/[pid]/stat file.
 * @returns The process start time in jiffies, or undefined if stat has an unexpected format.
 */
export declare function getProcessStartTimeFromProcStat(stat: string): string | undefined;
/**
 * Helper function that is exported for unit tests only.
 * Returns undefined if the process doesn't exist with that pid.
 */
export declare function getProcessStartTime(pid: number): string | undefined;
/**
 * A helper utility for working with file-based locks.
 * This class should only be used for locking resources across processes,
 * but should not be used for attempting to lock a resource in the same process.
 * @public
 */
export declare class LockFile {
    private _fileWriter;
    private _filePath;
    private _dirtyWhenAcquired;
    private static _getStartTime;
    /**
     * Returns the path to the lockfile, should it be created successfully.
     */
    static getLockFilePath(resourceDir: string, resourceName: string, pid?: number): string;
    /**
     * Attempts to create a lockfile with the given filePath.
     * If successful, returns a LockFile instance.
     * If unable to get a lock, returns undefined.
     * @param resourceName - the name of the resource we are locking on. Should be an alphabetic string.
     */
    static tryAcquire(resourceDir: string, resourceName: string): LockFile | undefined;
    /**
     * Attempts to create the lockfile.
     * Will continue to loop at every 100ms until the lock becomes available or the maxWaitMs is surpassed.
     * @remarks This function is subject to starvation, whereby it does not ensure that the process that has been
     *          waiting the longest to acquire the lock will get it first. This means that a process could theoretically
     *          wait for the lock forever, while other processes skipped it in line and acquired the lock first.
     */
    static acquire(resourceDir: string, resourceName: string, maxWaitMs?: number): Promise<LockFile>;
    private static _sleepForMs;
    /**
     * Attempts to acquire the lock on a Linux or OSX machine
     */
    private static _tryAcquireMacOrLinux;
    /**
     * Attempts to acquire the lock using Windows
     * This algorithm is much simpler since we can rely on the operating system
     */
    private static _tryAcquireWindows;
    /**
     * Unlocks a file and removes it from disk.
     * This can only be called once.
     */
    release(): void;
    /**
     * Returns the initial state of the lock.
     * This can be used to detect if the previous process was terminated before releasing the resource.
     */
    readonly dirtyWhenAcquired: boolean;
    /**
     * Returns the absolute path to the lockfile
     */
    readonly filePath: string;
    /**
     * Returns true if this lock is currently being held.
     */
    readonly isReleased: boolean;
    private constructor();
}
//# sourceMappingURL=LockFile.d.ts.map