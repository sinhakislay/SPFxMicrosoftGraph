{"version":3,"file":"Collector.js","sourceRoot":"","sources":["../../src/collector/Collector.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport * as tsdoc from '@microsoft/tsdoc';\r\nimport {\r\n  PackageJsonLookup,\r\n  Sort,\r\n  InternalError\r\n} from '@microsoft/node-core-library';\r\nimport {\r\n  ReleaseTag,\r\n  AedocDefinitions\r\n} from '@microsoft/api-extractor-model';\r\n\r\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\r\n\r\nimport { CollectorEntity } from './CollectorEntity';\r\nimport { AstSymbolTable, AstEntity } from '../analyzer/AstSymbolTable';\r\nimport { AstModule, AstModuleExportInfo } from '../analyzer/AstModule';\r\nimport { AstSymbol } from '../analyzer/AstSymbol';\r\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\r\nimport { TypeScriptHelpers } from '../analyzer/TypeScriptHelpers';\r\nimport { WorkingPackage } from './WorkingPackage';\r\nimport { PackageDocComment } from '../aedoc/PackageDocComment';\r\nimport { DeclarationMetadata } from './DeclarationMetadata';\r\nimport { SymbolMetadata } from './SymbolMetadata';\r\nimport { TypeScriptInternals } from '../analyzer/TypeScriptInternals';\r\nimport { MessageRouter } from './MessageRouter';\r\nimport { AstReferenceResolver } from '../analyzer/AstReferenceResolver';\r\nimport { ExtractorConfig } from '../api/ExtractorConfig';\r\n\r\n/**\r\n * Options for Collector constructor.\r\n */\r\nexport interface ICollectorOptions {\r\n  /**\r\n   * Configuration for the TypeScript compiler.  The most important options to set are:\r\n   *\r\n   * - target: ts.ScriptTarget.ES5\r\n   * - module: ts.ModuleKind.CommonJS\r\n   * - moduleResolution: ts.ModuleResolutionKind.NodeJs\r\n   * - rootDir: inputFolder\r\n   */\r\n  program: ts.Program;\r\n\r\n  messageRouter: MessageRouter;\r\n\r\n  extractorConfig: ExtractorConfig;\r\n}\r\n\r\n/**\r\n * The `Collector` manages the overall data set that is used by `ApiModelGenerator`,\r\n * `DtsRollupGenerator`, and `ApiReportGenerator`.  Starting from the working package's entry point,\r\n * the `Collector` collects all exported symbols, determines how to import any symbols they reference,\r\n * assigns unique names, and sorts everything into a normalized alphabetical ordering.\r\n */\r\nexport class Collector {\r\n  public readonly program: ts.Program;\r\n  public readonly typeChecker: ts.TypeChecker;\r\n  public readonly astSymbolTable: AstSymbolTable;\r\n  public readonly astReferenceResolver: AstReferenceResolver;\r\n\r\n  public readonly packageJsonLookup: PackageJsonLookup;\r\n  public readonly messageRouter: MessageRouter;\r\n\r\n  public readonly workingPackage: WorkingPackage;\r\n\r\n  public readonly extractorConfig: ExtractorConfig;\r\n\r\n  private readonly _program: ts.Program;\r\n\r\n  private readonly _tsdocParser: tsdoc.TSDocParser;\r\n\r\n  private _astEntryPoint: AstModule | undefined;\r\n\r\n  private readonly _entities: CollectorEntity[] = [];\r\n  private readonly _entitiesByAstEntity: Map<AstEntity, CollectorEntity> = new Map<AstEntity, CollectorEntity>();\r\n\r\n  private readonly _starExportedExternalModulePaths: string[] = [];\r\n\r\n  private readonly _dtsTypeReferenceDirectives: Set<string> = new Set<string>();\r\n  private readonly _dtsLibReferenceDirectives: Set<string> = new Set<string>();\r\n\r\n  constructor(options: ICollectorOptions) {\r\n    this.packageJsonLookup = new PackageJsonLookup();\r\n\r\n    this._program = options.program;\r\n    this.extractorConfig = options.extractorConfig;\r\n\r\n    const entryPointSourceFile: ts.SourceFile | undefined = options.program.getSourceFile(\r\n      this.extractorConfig.mainEntryPointFilePath);\r\n\r\n    if (!entryPointSourceFile) {\r\n      throw new Error('Unable to load file: ' + this.extractorConfig.mainEntryPointFilePath);\r\n    }\r\n\r\n    if (!this.extractorConfig.packageFolder || !this.extractorConfig.packageJson) {\r\n      // TODO: We should be able to analyze projects that don't have any package.json.\r\n      // The ExtractorConfig class is already designed to allow this.\r\n      throw new Error('Unable to find a package.json file for the project being analyzed');\r\n    }\r\n\r\n    this.workingPackage = new WorkingPackage({\r\n      packageFolder: this.extractorConfig.packageFolder,\r\n      packageJson: this.extractorConfig.packageJson,\r\n      entryPointSourceFile\r\n    });\r\n\r\n    this.messageRouter = options.messageRouter;\r\n\r\n    this.program = options.program;\r\n    this.typeChecker = options.program.getTypeChecker();\r\n\r\n    this._tsdocParser = new tsdoc.TSDocParser(AedocDefinitions.tsdocConfiguration);\r\n\r\n    const bundledPackageNames: Set<string> = new Set<string>(this.extractorConfig.bundledPackages);\r\n\r\n    this.astSymbolTable = new AstSymbolTable(this.program, this.typeChecker, this.packageJsonLookup,\r\n      bundledPackageNames, this.messageRouter);\r\n    this.astReferenceResolver = new AstReferenceResolver(this.astSymbolTable, this.workingPackage);\r\n  }\r\n\r\n  /**\r\n   * Returns a list of names (e.g. \"example-library\") that should appear in a reference like this:\r\n   *\r\n   * ```\r\n   * /// <reference types=\"example-library\" />\r\n   * ```\r\n   */\r\n  public get dtsTypeReferenceDirectives(): ReadonlySet<string> {\r\n    return this._dtsTypeReferenceDirectives;\r\n  }\r\n\r\n  /**\r\n   * A list of names (e.g. \"runtime-library\") that should appear in a reference like this:\r\n   *\r\n   * ```\r\n   * /// <reference lib=\"runtime-library\" />\r\n   * ```\r\n   */\r\n  public get dtsLibReferenceDirectives(): ReadonlySet<string> {\r\n    return this._dtsLibReferenceDirectives;\r\n  }\r\n\r\n  public get entities(): ReadonlyArray<CollectorEntity> {\r\n    return this._entities;\r\n  }\r\n\r\n  /**\r\n   * A list of module specifiers (e.g. `\"@microsoft/node-core-library/lib/FileSystem\"`) that should be emitted\r\n   * as star exports (e.g. `export * from \"@microsoft/node-core-library/lib/FileSystem\"`).\r\n   */\r\n  public get starExportedExternalModulePaths(): ReadonlyArray<string> {\r\n    return this._starExportedExternalModulePaths;\r\n  }\r\n\r\n  /**\r\n   * Perform the analysis.\r\n   */\r\n  public analyze(): void {\r\n    if (this._astEntryPoint) {\r\n      throw new Error('DtsRollupGenerator.analyze() was already called');\r\n    }\r\n\r\n    // This runs a full type analysis, and then augments the Abstract Syntax Tree (i.e. declarations)\r\n    // with semantic information (i.e. symbols).  The \"diagnostics\" are a subset of the everyday\r\n    // compile errors that would result from a full compilation.\r\n    for (const diagnostic of this._program.getSemanticDiagnostics()) {\r\n      this.messageRouter.addCompilerDiagnostic(diagnostic);\r\n    }\r\n\r\n    if (this.messageRouter.showDiagnostics) {\r\n      this.messageRouter.logDiagnosticHeader('Root filenames');\r\n      for (const fileName of this.program.getRootFileNames()) {\r\n        this.messageRouter.logDiagnostic(fileName);\r\n      }\r\n      this.messageRouter.logDiagnosticFooter();\r\n\r\n      this.messageRouter.logDiagnosticHeader('Files analyzed by compiler');\r\n      for (const sourceFile of this.program.getSourceFiles()) {\r\n        this.messageRouter.logDiagnostic(sourceFile.fileName);\r\n      }\r\n      this.messageRouter.logDiagnosticFooter();\r\n    }\r\n\r\n    // Build the entry point\r\n    const entryPointSourceFile: ts.SourceFile = this.workingPackage.entryPointSourceFile;\r\n\r\n    const astEntryPoint: AstModule = this.astSymbolTable.fetchAstModuleFromWorkingPackage(\r\n      entryPointSourceFile);\r\n    this._astEntryPoint = astEntryPoint;\r\n\r\n    const packageDocCommentTextRange: ts.TextRange | undefined = PackageDocComment.tryFindInSourceFile(\r\n      entryPointSourceFile, this);\r\n\r\n    if (packageDocCommentTextRange) {\r\n      const range: tsdoc.TextRange = tsdoc.TextRange.fromStringRange(entryPointSourceFile.text,\r\n        packageDocCommentTextRange.pos, packageDocCommentTextRange.end);\r\n\r\n      this.workingPackage.tsdocParserContext = this._tsdocParser.parseRange(range);\r\n\r\n      this.messageRouter.addTsdocMessages(this.workingPackage.tsdocParserContext,\r\n        entryPointSourceFile);\r\n\r\n      this.workingPackage.tsdocComment = this.workingPackage.tsdocParserContext!.docComment;\r\n    }\r\n\r\n    const exportedAstEntities: AstEntity[] = [];\r\n\r\n    // Create a CollectorEntity for each top-level export\r\n\r\n    const astModuleExportInfo: AstModuleExportInfo = this.astSymbolTable.fetchAstModuleExportInfo(astEntryPoint);\r\n    for (const [exportName, astEntity] of astModuleExportInfo.exportedLocalEntities) {\r\n      this._createCollectorEntity(astEntity, exportName);\r\n\r\n      exportedAstEntities.push(astEntity);\r\n    }\r\n\r\n    // Create a CollectorEntity for each indirectly referenced export.\r\n    // Note that we do this *after* the above loop, so that references to exported AstSymbols\r\n    // are encountered first as exports.\r\n    const alreadySeenAstSymbols: Set<AstSymbol> = new Set<AstSymbol>();\r\n    for (const exportedAstEntity of exportedAstEntities) {\r\n      this._createEntityForIndirectReferences(exportedAstEntity, alreadySeenAstSymbols);\r\n\r\n      if (exportedAstEntity instanceof AstSymbol) {\r\n        this.fetchMetadata(exportedAstEntity);\r\n      }\r\n    }\r\n\r\n    this._makeUniqueNames();\r\n\r\n    for (const starExportedExternalModule of astModuleExportInfo.starExportedExternalModules) {\r\n      if (starExportedExternalModule.externalModulePath !== undefined) {\r\n        this._starExportedExternalModulePaths.push(starExportedExternalModule.externalModulePath);\r\n      }\r\n    }\r\n\r\n    Sort.sortBy(this._entities, x => x.getSortKey());\r\n    Sort.sortSet(this._dtsTypeReferenceDirectives);\r\n    Sort.sortSet(this._dtsLibReferenceDirectives);\r\n    this._starExportedExternalModulePaths.sort();\r\n  }\r\n\r\n  /**\r\n   * For a given ts.Identifier that is part of an AstSymbol that we analyzed, return the CollectorEntity that\r\n   * it refers to.  Returns undefined if it doesn't refer to anything interesting.\r\n   * @remarks\r\n   * Throws an Error if the ts.Identifier is not part of node tree that was analyzed.\r\n   */\r\n  public tryGetEntityForIdentifierNode(identifier: ts.Identifier): CollectorEntity | undefined {\r\n    const astEntity: AstEntity | undefined = this.astSymbolTable.tryGetEntityForIdentifierNode(identifier);\r\n    if (astEntity) {\r\n      return this._entitiesByAstEntity.get(astEntity);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns the associated `CollectorEntity` for the given `astEntity`, if one was created during analysis.\r\n   */\r\n  public tryGetCollectorEntity(astEntity: AstEntity): CollectorEntity | undefined {\r\n    return this._entitiesByAstEntity.get(astEntity);\r\n  }\r\n\r\n  public fetchMetadata(astSymbol: AstSymbol): SymbolMetadata;\r\n  public fetchMetadata(astDeclaration: AstDeclaration): DeclarationMetadata;\r\n  public fetchMetadata(symbolOrDeclaration: AstSymbol | AstDeclaration): SymbolMetadata | DeclarationMetadata {\r\n    if (symbolOrDeclaration.metadata === undefined) {\r\n      const astSymbol: AstSymbol = symbolOrDeclaration instanceof AstSymbol\r\n        ? symbolOrDeclaration : symbolOrDeclaration.astSymbol;\r\n      this._fetchSymbolMetadata(astSymbol);\r\n    }\r\n    return symbolOrDeclaration.metadata as SymbolMetadata | DeclarationMetadata;\r\n  }\r\n\r\n  public tryFetchMetadataForAstEntity(astEntity: AstEntity): SymbolMetadata | undefined {\r\n    if (astEntity instanceof AstSymbol) {\r\n      return this.fetchMetadata(astEntity);\r\n    }\r\n    if (astEntity.astSymbol) { // astImport\r\n      return this.fetchMetadata(astEntity.astSymbol);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Removes the leading underscore, for example: \"_Example\" --> \"example*Example*_\"\r\n   *\r\n   * @remarks\r\n   * This causes internal definitions to sort alphabetically case-insensitive, then case-sensitive, and\r\n   * initially ignoring the underscore prefix, while still deterministically comparing it.\r\n   * The star is used as a delimiter because it is not a legal  identifier character.\r\n   */\r\n  public static getSortKeyIgnoringUnderscore(identifier: string): string {\r\n    let parts: string[];\r\n\r\n    if (identifier[0] === '_') {\r\n      const withoutUnderscore: string = identifier.substr(1);\r\n      parts = [withoutUnderscore.toLowerCase(), '*', withoutUnderscore, '*', '_'];\r\n    } else {\r\n      parts = [identifier.toLowerCase(), '*', identifier];\r\n    }\r\n\r\n    return parts.join('');\r\n  }\r\n\r\n  private _createCollectorEntity(astEntity: AstEntity, exportedName: string | undefined): void {\r\n    let entity: CollectorEntity | undefined = this._entitiesByAstEntity.get(astEntity);\r\n\r\n    if (!entity) {\r\n      entity = new CollectorEntity(astEntity);\r\n\r\n      this._entitiesByAstEntity.set(astEntity, entity);\r\n      this._entities.push(entity);\r\n\r\n      if (astEntity instanceof AstSymbol) {\r\n        this._collectReferenceDirectives(astEntity);\r\n      }\r\n    }\r\n\r\n    if (exportedName) {\r\n      entity.addExportName(exportedName);\r\n    }\r\n  }\r\n\r\n  private _createEntityForIndirectReferences(astEntity: AstEntity, alreadySeenAstEntities: Set<AstEntity>): void {\r\n    if (alreadySeenAstEntities.has(astEntity)) {\r\n      return;\r\n    }\r\n    alreadySeenAstEntities.add(astEntity);\r\n\r\n    if (astEntity instanceof AstSymbol) {\r\n      astEntity.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\r\n        for (const referencedAstEntity of astDeclaration.referencedAstEntities) {\r\n          if (referencedAstEntity instanceof AstSymbol) {\r\n            // We only create collector entities for root-level symbols.\r\n            // For example, if a symbols is nested inside a namespace, only the root-level namespace\r\n            // get a collector entity\r\n            if (referencedAstEntity.parentAstSymbol === undefined) {\r\n              this._createCollectorEntity(referencedAstEntity, undefined);\r\n            }\r\n          } else {\r\n            this._createCollectorEntity(referencedAstEntity, undefined);\r\n          }\r\n\r\n          this._createEntityForIndirectReferences(referencedAstEntity, alreadySeenAstEntities);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensures a unique name for each item in the package typings file.\r\n   */\r\n  private _makeUniqueNames(): void {\r\n    // The following examples illustrate the nameForEmit heuristics:\r\n    //\r\n    // Example 1:\r\n    //   class X { } <--- nameForEmit should be \"A\" to simplify things and reduce possibility of conflicts\r\n    //   export { X as A };\r\n    //\r\n    // Example 2:\r\n    //   class X { } <--- nameForEmit should be \"X\" because choosing A or B would be nondeterministic\r\n    //   export { X as A };\r\n    //   export { X as B };\r\n    //\r\n    // Example 3:\r\n    //   class X { } <--- nameForEmit should be \"X_1\" because Y has a stronger claim to the name\r\n    //   export { X as A };\r\n    //   export { X as B };\r\n    //   class Y { } <--- nameForEmit should be \"X\"\r\n    //   export { Y as X };\r\n\r\n    // Set of names that should NOT be used when generating a unique nameForEmit\r\n    const usedNames: Set<string> = new Set<string>();\r\n\r\n    // First collect the names of explicit package exports, and perform a sanity check.\r\n    for (const entity of this._entities) {\r\n      for (const exportName of entity.exportNames) {\r\n        if (usedNames.has(exportName)) {\r\n          // This should be impossible\r\n          throw new InternalError(`A package cannot have two exports with the name \"${exportName}\"`);\r\n        }\r\n        usedNames.add(exportName);\r\n      }\r\n    }\r\n\r\n    // Next, add in the global names\r\n    const globalNames: Set<string> = new Set<string>();\r\n    this._collectGlobalNames(globalNames);\r\n\r\n    for (const globalName of globalNames) {\r\n      // Note that globalName may conflict with an exported name.\r\n      // We'll check for this conflict below.\r\n      usedNames.add(globalName);\r\n    }\r\n\r\n    // Ensure that each entity has a unique nameForEmit\r\n    for (const entity of this._entities) {\r\n\r\n      // What name would we ideally want to emit it as?\r\n      let idealNameForEmit: string;\r\n\r\n      // If this entity is exported exactly once, then we prefer the exported name\r\n      if (entity.singleExportName !== undefined && entity.singleExportName !== ts.InternalSymbolName.Default) {\r\n        idealNameForEmit = entity.singleExportName;\r\n      } else {\r\n        // otherwise use the local name\r\n        idealNameForEmit = entity.astEntity.localName;\r\n      }\r\n\r\n      // If the idealNameForEmit happens to be the same as one of the exports, then we're safe to use that...\r\n      if (entity.exportNames.has(idealNameForEmit)) {\r\n        // ...except that if it conflicts with a global name, then the global name wins\r\n        if (!globalNames.has(idealNameForEmit)) {\r\n          entity.nameForEmit = idealNameForEmit;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Generate a unique name based on idealNameForEmit\r\n      let suffix: number = 1;\r\n      let nameForEmit: string = idealNameForEmit;\r\n\r\n      // Choose a name that doesn't conflict with usedNames\r\n      while (usedNames.has(nameForEmit)) {\r\n        nameForEmit = `${idealNameForEmit}_${++suffix}`;\r\n      }\r\n      entity.nameForEmit = nameForEmit;\r\n      usedNames.add(nameForEmit);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds global names to the usedNames set, to prevent API Extractor from emitting names that conflict with\r\n   * a global name.\r\n   */\r\n  private _collectGlobalNames(usedNames: Set<string>): void {\r\n    // As a temporary workaround, this a short list of names that appear in typical projects.\r\n    // The full solution is tracked by this issue:\r\n    // https://github.com/microsoft/rushstack/issues/1095\r\n    const globalNames: string[] = [\r\n      'Array',\r\n      'ArrayConstructor',\r\n      'Console',\r\n      'Date',\r\n      'DateConstructor',\r\n      'Error',\r\n      'ErrorConstructor',\r\n      'Float32Array',\r\n      'Float32ArrayConstructor',\r\n      'Float64Array',\r\n      'Float64ArrayConstructor',\r\n      'IArguments',\r\n      'Int16Array',\r\n      'Int16ArrayConstructor',\r\n      'Int32Array',\r\n      'Int32ArrayConstructor',\r\n      'Int8Array',\r\n      'Int8ArrayConstructor',\r\n      'Iterable',\r\n      'IterableIterator',\r\n      'Iterator',\r\n      'IteratorResult',\r\n      'Map',\r\n      'MapConstructor',\r\n      'Promise',\r\n      'PromiseConstructor',\r\n      'ReadonlyArray',\r\n      'ReadonlyMap',\r\n      'ReadonlySet',\r\n      'Set',\r\n      'SetConstructor',\r\n      'String',\r\n      'Symbol',\r\n      'SymbolConstructor',\r\n      'Uint16Array',\r\n      'Uint16ArrayConstructor',\r\n      'Uint32Array',\r\n      'Uint32ArrayConstructor',\r\n      'Uint8Array',\r\n      'Uint8ArrayConstructor',\r\n      'Uint8ClampedArray',\r\n      'Uint8ClampedArrayConstructor',\r\n      'WeakMap',\r\n      'WeakMapConstructor',\r\n      'WeakSet',\r\n      'WeakSetConstructor',\r\n      'clearInterval',\r\n      'clearTimeout',\r\n      'console',\r\n      'setInterval',\r\n      'setTimeout',\r\n      'undefined'\r\n    ];\r\n    for (const globalName of globalNames) {\r\n      usedNames.add(globalName);\r\n    }\r\n  }\r\n\r\n  private _fetchSymbolMetadata(astSymbol: AstSymbol): void {\r\n    if (astSymbol.metadata) {\r\n      return;\r\n    }\r\n\r\n    // When we solve an astSymbol, then we always also solve all of its parents and all of its declarations\r\n    if (astSymbol.parentAstSymbol && astSymbol.parentAstSymbol.metadata === undefined) {\r\n      this._fetchSymbolMetadata(astSymbol.parentAstSymbol);\r\n    }\r\n\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      this._calculateMetadataForDeclaration(astDeclaration);\r\n    }\r\n\r\n    // The most public effectiveReleaseTag for all declarations\r\n    let maxEffectiveReleaseTag: ReleaseTag = ReleaseTag.None;\r\n\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      // We know we solved this above\r\n      const declarationMetadata: DeclarationMetadata = astDeclaration.metadata as DeclarationMetadata;\r\n      const effectiveReleaseTag: ReleaseTag = declarationMetadata.effectiveReleaseTag;\r\n\r\n      if (effectiveReleaseTag > maxEffectiveReleaseTag) {\r\n        maxEffectiveReleaseTag = effectiveReleaseTag;\r\n      }\r\n    }\r\n\r\n    const symbolMetadata: SymbolMetadata = new SymbolMetadata();\r\n    symbolMetadata.maxEffectiveReleaseTag = maxEffectiveReleaseTag;\r\n\r\n    // Update this last when we're sure no exceptions were thrown\r\n    astSymbol.metadata = symbolMetadata;\r\n  }\r\n\r\n  private _calculateMetadataForDeclaration(astDeclaration: AstDeclaration): void {\r\n    const declarationMetadata: DeclarationMetadata = new DeclarationMetadata();\r\n    astDeclaration.metadata = declarationMetadata;\r\n\r\n    const parserContext: tsdoc.ParserContext | undefined = this._parseTsdocForAstDeclaration(astDeclaration);\r\n    if (parserContext) {\r\n      const modifierTagSet: tsdoc.StandardModifierTagSet = parserContext.docComment.modifierTagSet;\r\n\r\n      let declaredReleaseTag: ReleaseTag = ReleaseTag.None;\r\n      let extraReleaseTags: boolean = false;\r\n\r\n      if (modifierTagSet.isPublic()) {\r\n        declaredReleaseTag = ReleaseTag.Public;\r\n      }\r\n      if (modifierTagSet.isBeta()) {\r\n        if (declaredReleaseTag !== ReleaseTag.None) {\r\n          extraReleaseTags = true;\r\n        } else {\r\n          declaredReleaseTag = ReleaseTag.Beta;\r\n        }\r\n      }\r\n      if (modifierTagSet.isAlpha()) {\r\n        if (declaredReleaseTag !== ReleaseTag.None) {\r\n          extraReleaseTags = true;\r\n        } else {\r\n          declaredReleaseTag = ReleaseTag.Alpha;\r\n        }\r\n      }\r\n      if (modifierTagSet.isInternal()) {\r\n        if (declaredReleaseTag !== ReleaseTag.None) {\r\n          extraReleaseTags = true;\r\n        } else {\r\n          declaredReleaseTag = ReleaseTag.Internal;\r\n        }\r\n      }\r\n\r\n      if (extraReleaseTags) {\r\n        if (!astDeclaration.astSymbol.isExternal) { // for now, don't report errors for external code\r\n          this.messageRouter.addAnalyzerIssue(\r\n            ExtractorMessageId.ExtraReleaseTag,\r\n            'The doc comment should not contain more than one release tag',\r\n            astDeclaration);\r\n        }\r\n      }\r\n\r\n      declarationMetadata.tsdocParserContext = parserContext;\r\n      declarationMetadata.tsdocComment = parserContext.docComment;\r\n\r\n      declarationMetadata.declaredReleaseTag = declaredReleaseTag;\r\n\r\n      declarationMetadata.isEventProperty = modifierTagSet.isEventProperty();\r\n      declarationMetadata.isOverride = modifierTagSet.isOverride();\r\n      declarationMetadata.isSealed = modifierTagSet.isSealed();\r\n      declarationMetadata.isVirtual = modifierTagSet.isVirtual();\r\n\r\n      if (modifierTagSet.hasTag(AedocDefinitions.preapprovedTag)) {\r\n        // This feature only makes sense for potentially big declarations.\r\n        switch (astDeclaration.declaration.kind) {\r\n          case ts.SyntaxKind.ClassDeclaration:\r\n          case ts.SyntaxKind.EnumDeclaration:\r\n          case ts.SyntaxKind.InterfaceDeclaration:\r\n          case ts.SyntaxKind.ModuleDeclaration:\r\n            if (declaredReleaseTag === ReleaseTag.Internal) {\r\n              declarationMetadata.isPreapproved = true;\r\n            } else {\r\n              this.messageRouter.addAnalyzerIssue(\r\n                ExtractorMessageId.PreapprovedBadReleaseTag,\r\n                `The @preapproved tag cannot be applied to \"${astDeclaration.astSymbol.localName}\"`\r\n                  + ` without an @internal release tag`,\r\n                astDeclaration\r\n              );\r\n            }\r\n            break;\r\n          default:\r\n            this.messageRouter.addAnalyzerIssue(\r\n              ExtractorMessageId.PreapprovedUnsupportedType,\r\n              `The @preapproved tag cannot be applied to \"${astDeclaration.astSymbol.localName}\"`\r\n                + ` because it is not a supported declaration type`,\r\n              astDeclaration\r\n            );\r\n            break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // This needs to be set regardless of whether or not a parserContext exists\r\n    if (astDeclaration.parent) {\r\n      const parentDeclarationMetadata: DeclarationMetadata = this.fetchMetadata(astDeclaration.parent);\r\n      declarationMetadata.effectiveReleaseTag = declarationMetadata.declaredReleaseTag === ReleaseTag.None\r\n        ? parentDeclarationMetadata.effectiveReleaseTag\r\n        : declarationMetadata.declaredReleaseTag;\r\n\r\n      declarationMetadata.releaseTagSameAsParent =\r\n        parentDeclarationMetadata.effectiveReleaseTag === declarationMetadata.effectiveReleaseTag;\r\n    } else {\r\n      declarationMetadata.effectiveReleaseTag = declarationMetadata.declaredReleaseTag;\r\n    }\r\n\r\n    if (declarationMetadata.effectiveReleaseTag === ReleaseTag.None) {\r\n      if (!astDeclaration.astSymbol.isExternal) { // for now, don't report errors for external code\r\n        // Don't report missing release tags for forgotten exports\r\n        const astSymbol: AstSymbol = astDeclaration.astSymbol;\r\n        const entity: CollectorEntity | undefined = this._entitiesByAstEntity.get(astSymbol.rootAstSymbol);\r\n        if (entity && entity.exported) {\r\n          // We also don't report errors for the default export of an entry point, since its doc comment\r\n          // isn't easy to obtain from the .d.ts file\r\n          if (astSymbol.rootAstSymbol.localName !== '_default') {\r\n            this.messageRouter.addAnalyzerIssue(\r\n              ExtractorMessageId.MissingReleaseTag,\r\n              `\"${entity.astEntity.localName}\" is exported by the package, but it is missing `\r\n              + `a release tag (@alpha, @beta, @public, or @internal)`,\r\n              astSymbol\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      declarationMetadata.effectiveReleaseTag = ReleaseTag.Public;\r\n    }\r\n  }\r\n\r\n  private _parseTsdocForAstDeclaration(astDeclaration: AstDeclaration): tsdoc.ParserContext | undefined {\r\n    const declaration: ts.Declaration = astDeclaration.declaration;\r\n    let nodeForComment: ts.Node = declaration;\r\n\r\n    if (ts.isVariableDeclaration(declaration)) {\r\n      // Variable declarations are special because they can be combined into a list.  For example:\r\n      //\r\n      // /** A */ export /** B */ const /** C */ x = 1, /** D **/ [ /** E */ y, z] = [3, 4];\r\n      //\r\n      // The compiler will only emit comments A and C in the .d.ts file, so in general there isn't a well-defined\r\n      // way to document these parts.  API Extractor requires you to break them into separate exports like this:\r\n      //\r\n      // /** A */ export const x = 1;\r\n      //\r\n      // But _getReleaseTagForDeclaration() still receives a node corresponding to \"x\", so we need to walk upwards\r\n      // and find the containing statement in order for getJSDocCommentRanges() to read the comment that we expect.\r\n      const statement: ts.VariableStatement | undefined = TypeScriptHelpers.findFirstParent(declaration,\r\n        ts.SyntaxKind.VariableStatement) as ts.VariableStatement | undefined;\r\n      if (statement !== undefined) {\r\n        // For a compound declaration, fall back to looking for C instead of A\r\n        if (statement.declarationList.declarations.length === 1) {\r\n          nodeForComment = statement;\r\n        }\r\n      }\r\n    }\r\n\r\n    const sourceFileText: string = declaration.getSourceFile().text;\r\n    const ranges: ts.CommentRange[] = TypeScriptInternals.getJSDocCommentRanges(nodeForComment, sourceFileText) || [];\r\n\r\n    if (ranges.length === 0) {\r\n      return undefined;\r\n    }\r\n\r\n    // We use the JSDoc comment block that is closest to the definition, i.e.\r\n    // the last one preceding it\r\n    const range: ts.TextRange = ranges[ranges.length - 1];\r\n\r\n    const tsdocTextRange: tsdoc.TextRange = tsdoc.TextRange.fromStringRange(sourceFileText,\r\n      range.pos, range.end);\r\n\r\n    const parserContext: tsdoc.ParserContext = this._tsdocParser.parseRange(tsdocTextRange);\r\n\r\n    this.messageRouter.addTsdocMessages(parserContext, declaration.getSourceFile(), astDeclaration);\r\n\r\n    // We delete the @privateRemarks block as early as possible, to ensure that it never leaks through\r\n    // into one of the output files.\r\n    parserContext.docComment.privateRemarks = undefined;\r\n\r\n    return parserContext;\r\n  }\r\n\r\n  private _collectReferenceDirectives(astSymbol: AstSymbol): void {\r\n    const seenFilenames: Set<string> = new Set<string>();\r\n\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      const sourceFile: ts.SourceFile = astDeclaration.declaration.getSourceFile();\r\n      if (sourceFile && sourceFile.fileName) {\r\n        if (!seenFilenames.has(sourceFile.fileName)) {\r\n          seenFilenames.add(sourceFile.fileName);\r\n\r\n          for (const typeReferenceDirective of sourceFile.typeReferenceDirectives) {\r\n            const name: string = sourceFile.text.substring(typeReferenceDirective.pos, typeReferenceDirective.end);\r\n            this._dtsTypeReferenceDirectives.add(name);\r\n          }\r\n\r\n          for (const libReferenceDirective of sourceFile.libReferenceDirectives) {\r\n            const name: string = sourceFile.text.substring(libReferenceDirective.pos, libReferenceDirective.end);\r\n            this._dtsLibReferenceDirectives.add(name);\r\n          }\r\n\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}