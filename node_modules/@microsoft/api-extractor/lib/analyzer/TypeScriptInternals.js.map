{"version":3,"file":"TypeScriptInternals.js","sourceRoot":"","sources":["../../src/analyzer/TypeScriptInternals.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;AAE3D,wBAAwB;AAExB,iCAAiC;AAEjC,MAAa,mBAAmB;IAEvB,MAAM,CAAC,yBAAyB,CAAC,MAAiB,EAAE,WAA2B;QACpF,qBAAqB;QACrB,8EAA8E;QAC9E,OAAQ,WAAmB,CAAC,yBAAyB,CAAC,MAAM,CAAC,CAAC,CAAC,6BAA6B;IAC9F,CAAC;IAED;;;;;;;OAOG;IACI,MAAM,CAAC,0BAA0B,CAAC,WAA2B,EAAE,OAAuB;QAE3F,IAAI,MAAM,GAA2B,WAAmB,CAAC,MAAM,CAAC;QAChE,IAAI,MAAM,IAAI,MAAM,CAAC,WAAW,KAAK,EAAE,CAAC,kBAAkB,CAAC,QAAQ,EAAE;YACnE,MAAM,IAAI,GAAmC,EAAE,CAAC,oBAAoB,CAAC,WAAW,CAAC,CAAC;YAClF,MAAM,GAAG,IAAI,IAAI,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC;SAC9D;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,iBAAiB,CAAC,MAAiB;QAC/C,sCAAsC;QACtC,IAAI,MAAM,CAAC,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,SAAS;YACtC,MAAc,CAAC,UAAU,KAAM,EAAU,CAAC,UAAU,CAAC,IAAI,EAAE;YAC9D,OAAO,IAAI,CAAC;SACb;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,qBAAqB,CAAC,IAAa,EAAE,IAAY;QAC7D,qBAAqB;QACrB,qFAAqF;QAErF,OAAQ,EAAU,CAAC,qBAAqB,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IAClE,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,4BAA4B,CAAC,IAA8D;QACvG,qBAAqB;QACrB,sFAAsF;QAEtF,OAAQ,EAAU,CAAC,4BAA4B,CAAC,IAAI,CAAC,CAAC;IACxD,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,iBAAiB,CAAC,UAAyB,EAAE,cAAsB;QAG/E,qBAAqB;QACrB,qFAAqF;QAErF,OAAQ,EAAU,CAAC,iBAAiB,CAAC,UAAU,EAAE,cAAc,CAAC,CAAC;IACnE,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,eAAe,CAAC,MAAiB;QAC7C,OAAQ,MAAc,CAAC,MAAM,CAAC;IAChC,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,iBAAiB,CAAC,WAA2B;QACzD,OAAQ,WAAmB,CAAC,WAAW,CAAC;IAC1C,CAAC;CAEF;AAvFD,kDAuFC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n// tslint:disable:no-any\r\n\r\nimport * as ts from 'typescript';\r\n\r\nexport class TypeScriptInternals {\r\n\r\n  public static getImmediateAliasedSymbol(symbol: ts.Symbol, typeChecker: ts.TypeChecker): ts.Symbol {\r\n    // Compiler internal:\r\n    // https://github.com/microsoft/TypeScript/blob/v3.2.2/src/compiler/checker.ts\r\n    return (typeChecker as any).getImmediateAliasedSymbol(symbol); // tslint:disable-line:no-any\r\n  }\r\n\r\n  /**\r\n   * Returns the Symbol for the provided Declaration.  This is a workaround for a missing\r\n   * feature of the TypeScript Compiler API.   It is the only apparent way to reach\r\n   * certain data structures, and seems to always work, but is not officially documented.\r\n   *\r\n   * @returns The associated Symbol.  If there is no semantic information (e.g. if the\r\n   * declaration is an extra semicolon somewhere), then \"undefined\" is returned.\r\n   */\r\n  public static tryGetSymbolForDeclaration(declaration: ts.Declaration, checker: ts.TypeChecker): ts.Symbol\r\n    | undefined {\r\n    let symbol: ts.Symbol | undefined = (declaration as any).symbol;\r\n    if (symbol && symbol.escapedName === ts.InternalSymbolName.Computed) {\r\n      const name: ts.DeclarationName | undefined = ts.getNameOfDeclaration(declaration);\r\n      symbol = name && checker.getSymbolAtLocation(name) || symbol;\r\n    }\r\n    return symbol;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the provided Symbol is a TypeScript \"late-bound\" Symbol (i.e. was created by the Checker\r\n   * for a computed property based on its type, rather than by the Binder).\r\n   */\r\n  public static isLateBoundSymbol(symbol: ts.Symbol): boolean {\r\n    // tslint:disable-next-line:no-bitwise\r\n    if (symbol.flags & ts.SymbolFlags.Transient &&\r\n        (symbol as any).checkFlags === (ts as any).CheckFlags.Late) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the comment ranges associated with the specified node.\r\n   */\r\n  public static getJSDocCommentRanges(node: ts.Node, text: string): ts.CommentRange[] | undefined {\r\n    // Compiler internal:\r\n    // https://github.com/microsoft/TypeScript/blob/v2.4.2/src/compiler/utilities.ts#L616\r\n\r\n    return (ts as any).getJSDocCommentRanges.apply(this, arguments);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the (unescaped) value of an string literal, numeric literal, or identifier.\r\n   */\r\n  public static getTextOfIdentifierOrLiteral(node: ts.Identifier | ts.StringLiteralLike | ts.NumericLiteral): string {\r\n    // Compiler internal:\r\n    // https://github.com/microsoft/TypeScript/blob/v3.2.2/src/compiler/utilities.ts#L2721\r\n\r\n    return (ts as any).getTextOfIdentifierOrLiteral(node);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the (cached) module resolution information for a module name that was exported from a SourceFile.\r\n   * The compiler populates this cache as part of analyzing the source file.\r\n   */\r\n  public static getResolvedModule(sourceFile: ts.SourceFile, moduleNameText: string): ts.ResolvedModuleFull\r\n    | undefined {\r\n\r\n    // Compiler internal:\r\n    // https://github.com/microsoft/TypeScript/blob/v3.2.2/src/compiler/utilities.ts#L218\r\n\r\n    return (ts as any).getResolvedModule(sourceFile, moduleNameText);\r\n  }\r\n\r\n  /**\r\n   * Returns ts.Symbol.parent if it exists.\r\n   */\r\n  public static getSymbolParent(symbol: ts.Symbol): ts.Symbol | undefined {\r\n    return (symbol as any).parent;\r\n  }\r\n\r\n  /**\r\n   * In an statement like `export default class X { }`, the `Symbol.name` will be `default`\r\n   * whereas the `localSymbol` is `X`.\r\n   */\r\n  public static tryGetLocalSymbol(declaration: ts.Declaration): ts.Symbol | undefined {\r\n    return (declaration as any).localSymbol;\r\n  }\r\n\r\n}\r\n"]}