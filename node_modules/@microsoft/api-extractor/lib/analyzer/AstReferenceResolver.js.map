{"version":3,"file":"AstReferenceResolver.js","sourceRoot":"","sources":["../../src/analyzer/AstReferenceResolver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport * as tsdoc from '@microsoft/tsdoc';\r\n\r\nimport { AstSymbolTable, AstEntity } from './AstSymbolTable';\r\nimport { AstDeclaration } from './AstDeclaration';\r\nimport { WorkingPackage } from '../collector/WorkingPackage';\r\nimport { AstModule } from './AstModule';\r\nimport { AstImport } from './AstImport';\r\n\r\n/**\r\n * Used by `AstReferenceResolver` to report a failed resolution.\r\n *\r\n * @privateRemarks\r\n * This class is similar to an `Error` object, but the intent of `ResolverFailure` is to describe\r\n * why a reference could not be resolved.  This information could be used to throw an actual `Error` object,\r\n * but normally it is handed off to the `MessageRouter` instead.\r\n */\r\nexport class ResolverFailure {\r\n  /**\r\n   * Details about why the failure occurred.\r\n   */\r\n  public readonly reason: string;\r\n\r\n  public constructor(reason: string) {\r\n    this.reason = reason;\r\n  }\r\n}\r\n\r\n/**\r\n * This resolves a TSDoc declaration reference by walking the `AstSymbolTable` compiler state.\r\n *\r\n * @remarks\r\n *\r\n * This class is analogous to `ModelReferenceResolver` from the `@microsoft/api-extractor-model` project,\r\n * which resolves declaration references by walking the hierarchy loaded from an .api.json file.\r\n */\r\nexport class AstReferenceResolver {\r\n  private readonly _astSymbolTable: AstSymbolTable;\r\n  private readonly _workingPackage: WorkingPackage;\r\n\r\n  public constructor(astSymbolTable: AstSymbolTable, workingPackage: WorkingPackage) {\r\n    this._astSymbolTable = astSymbolTable;\r\n    this._workingPackage = workingPackage;\r\n  }\r\n\r\n  public resolve(declarationReference: tsdoc.DocDeclarationReference): AstDeclaration | ResolverFailure {\r\n    // Is it referring to the working package?\r\n    if (declarationReference.packageName !== undefined\r\n      && declarationReference.packageName !== this._workingPackage.name) {\r\n      return new ResolverFailure('External package references are not supported');\r\n    }\r\n\r\n    // Is it a path-based import?\r\n    if (declarationReference.importPath) {\r\n      return new ResolverFailure('Import paths are not supported');\r\n    }\r\n\r\n    const astModule: AstModule = this._astSymbolTable.fetchAstModuleFromWorkingPackage(\r\n      this._workingPackage.entryPointSourceFile);\r\n\r\n    if (declarationReference.memberReferences.length === 0) {\r\n      return new ResolverFailure('Package references are not supported');\r\n    }\r\n\r\n    const rootMemberReference: tsdoc.DocMemberReference = declarationReference.memberReferences[0];\r\n\r\n    const exportName: string | ResolverFailure = this._getMemberReferenceIdentifier(rootMemberReference);\r\n    if (exportName instanceof ResolverFailure) {\r\n      return exportName;\r\n    }\r\n\r\n    const rootAstEntity: AstEntity | undefined = this._astSymbolTable.tryGetExportOfAstModule(\r\n      exportName, astModule);\r\n\r\n    if (rootAstEntity === undefined) {\r\n      return new ResolverFailure(`The package \"${this._workingPackage.name}\" does not have an export \"${exportName}\"`);\r\n    }\r\n\r\n    if (rootAstEntity instanceof AstImport) {\r\n      return new ResolverFailure('Reexported declarations are not supported');\r\n    }\r\n\r\n    let currentDeclaration: AstDeclaration | ResolverFailure = this._selectDeclaration(rootAstEntity.astDeclarations,\r\n      rootMemberReference, rootAstEntity.localName);\r\n\r\n    if (currentDeclaration instanceof ResolverFailure) {\r\n      return currentDeclaration;\r\n    }\r\n\r\n    for (let index: number = 1; index < declarationReference.memberReferences.length; ++index) {\r\n      const memberReference: tsdoc.DocMemberReference = declarationReference.memberReferences[index];\r\n\r\n      const memberName: string | ResolverFailure = this._getMemberReferenceIdentifier(memberReference);\r\n      if (memberName instanceof ResolverFailure) {\r\n        return memberName;\r\n      }\r\n\r\n      const matchingChildren: ReadonlyArray<AstDeclaration> = currentDeclaration.findChildrenWithName(memberName);\r\n      if (matchingChildren.length === 0) {\r\n        return new ResolverFailure(`No member was found with name \"${memberName}\"`);\r\n      }\r\n\r\n      const selectedDeclaration: AstDeclaration | ResolverFailure = this._selectDeclaration(matchingChildren,\r\n        memberReference, memberName);\r\n\r\n      if (selectedDeclaration instanceof ResolverFailure) {\r\n        return selectedDeclaration;\r\n      }\r\n\r\n      currentDeclaration = selectedDeclaration;\r\n    }\r\n\r\n    return currentDeclaration;\r\n  }\r\n\r\n  private _getMemberReferenceIdentifier(memberReference: tsdoc.DocMemberReference): string | ResolverFailure {\r\n    if (memberReference.memberSymbol !== undefined) {\r\n      return new ResolverFailure('ECMAScript symbol selectors are not supported');\r\n    }\r\n    if (memberReference.memberIdentifier === undefined) {\r\n      return new ResolverFailure('The member identifier is missing in the root member reference');\r\n    }\r\n    return memberReference.memberIdentifier.identifier;\r\n  }\r\n\r\n  private _selectDeclaration(astDeclarations: ReadonlyArray<AstDeclaration>,\r\n    memberReference: tsdoc.DocMemberReference, astSymbolName: string): AstDeclaration | ResolverFailure {\r\n\r\n    if (memberReference.selector === undefined) {\r\n      if (astDeclarations.length === 1) {\r\n        return astDeclarations[0];\r\n      } else {\r\n        return new ResolverFailure(`The reference is ambiguous because \"${astSymbolName}\"`\r\n          + ` has more than one declaration; you need to add a TSDoc member reference selector`);\r\n      }\r\n    }\r\n\r\n    const selectorName: string = memberReference.selector.selector;\r\n\r\n    if (memberReference.selector.selectorKind !== tsdoc.SelectorKind.System) {\r\n      return new ResolverFailure(`The selector \"${selectorName}\" is not a supported selector type`);\r\n    }\r\n\r\n    let selectorSyntaxKind: ts.SyntaxKind;\r\n\r\n    switch (selectorName) {\r\n      case 'class':\r\n        selectorSyntaxKind = ts.SyntaxKind.ClassDeclaration;\r\n        break;\r\n      case 'enum':\r\n        selectorSyntaxKind = ts.SyntaxKind.EnumDeclaration;\r\n        break;\r\n      case 'function':\r\n        selectorSyntaxKind = ts.SyntaxKind.FunctionDeclaration;\r\n        break;\r\n      case 'interface':\r\n        selectorSyntaxKind = ts.SyntaxKind.InterfaceDeclaration;\r\n        break;\r\n      case 'namespace':\r\n        selectorSyntaxKind = ts.SyntaxKind.ModuleDeclaration;\r\n        break;\r\n      case 'type':\r\n        selectorSyntaxKind = ts.SyntaxKind.TypeAliasDeclaration;\r\n        break;\r\n      case 'variable':\r\n        selectorSyntaxKind = ts.SyntaxKind.VariableDeclaration;\r\n        break;\r\n      default:\r\n        return new ResolverFailure(`Unsupported system selector \"${selectorName}\"`);\r\n    }\r\n\r\n    const matches: AstDeclaration[] = astDeclarations.filter(x => x.declaration.kind === selectorSyntaxKind);\r\n    if (matches.length === 0) {\r\n      return new ResolverFailure(`A declaration for \"${astSymbolName}\" was not found that matches the`\r\n        + ` TSDoc selector \"${selectorName}\"`);\r\n    }\r\n    if (matches.length > 1) {\r\n      return new ResolverFailure(`More than one declaration \"${astSymbolName}\" matches the`\r\n        + ` TSDoc selector \"${selectorName}\"`);\r\n    }\r\n    return matches[0];\r\n  }\r\n}\r\n"]}