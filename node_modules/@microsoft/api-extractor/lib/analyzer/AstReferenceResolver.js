"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const AstImport_1 = require("./AstImport");
/**
 * Used by `AstReferenceResolver` to report a failed resolution.
 *
 * @privateRemarks
 * This class is similar to an `Error` object, but the intent of `ResolverFailure` is to describe
 * why a reference could not be resolved.  This information could be used to throw an actual `Error` object,
 * but normally it is handed off to the `MessageRouter` instead.
 */
class ResolverFailure {
    constructor(reason) {
        this.reason = reason;
    }
}
exports.ResolverFailure = ResolverFailure;
/**
 * This resolves a TSDoc declaration reference by walking the `AstSymbolTable` compiler state.
 *
 * @remarks
 *
 * This class is analogous to `ModelReferenceResolver` from the `@microsoft/api-extractor-model` project,
 * which resolves declaration references by walking the hierarchy loaded from an .api.json file.
 */
class AstReferenceResolver {
    constructor(astSymbolTable, workingPackage) {
        this._astSymbolTable = astSymbolTable;
        this._workingPackage = workingPackage;
    }
    resolve(declarationReference) {
        // Is it referring to the working package?
        if (declarationReference.packageName !== undefined
            && declarationReference.packageName !== this._workingPackage.name) {
            return new ResolverFailure('External package references are not supported');
        }
        // Is it a path-based import?
        if (declarationReference.importPath) {
            return new ResolverFailure('Import paths are not supported');
        }
        const astModule = this._astSymbolTable.fetchAstModuleFromWorkingPackage(this._workingPackage.entryPointSourceFile);
        if (declarationReference.memberReferences.length === 0) {
            return new ResolverFailure('Package references are not supported');
        }
        const rootMemberReference = declarationReference.memberReferences[0];
        const exportName = this._getMemberReferenceIdentifier(rootMemberReference);
        if (exportName instanceof ResolverFailure) {
            return exportName;
        }
        const rootAstEntity = this._astSymbolTable.tryGetExportOfAstModule(exportName, astModule);
        if (rootAstEntity === undefined) {
            return new ResolverFailure(`The package "${this._workingPackage.name}" does not have an export "${exportName}"`);
        }
        if (rootAstEntity instanceof AstImport_1.AstImport) {
            return new ResolverFailure('Reexported declarations are not supported');
        }
        let currentDeclaration = this._selectDeclaration(rootAstEntity.astDeclarations, rootMemberReference, rootAstEntity.localName);
        if (currentDeclaration instanceof ResolverFailure) {
            return currentDeclaration;
        }
        for (let index = 1; index < declarationReference.memberReferences.length; ++index) {
            const memberReference = declarationReference.memberReferences[index];
            const memberName = this._getMemberReferenceIdentifier(memberReference);
            if (memberName instanceof ResolverFailure) {
                return memberName;
            }
            const matchingChildren = currentDeclaration.findChildrenWithName(memberName);
            if (matchingChildren.length === 0) {
                return new ResolverFailure(`No member was found with name "${memberName}"`);
            }
            const selectedDeclaration = this._selectDeclaration(matchingChildren, memberReference, memberName);
            if (selectedDeclaration instanceof ResolverFailure) {
                return selectedDeclaration;
            }
            currentDeclaration = selectedDeclaration;
        }
        return currentDeclaration;
    }
    _getMemberReferenceIdentifier(memberReference) {
        if (memberReference.memberSymbol !== undefined) {
            return new ResolverFailure('ECMAScript symbol selectors are not supported');
        }
        if (memberReference.memberIdentifier === undefined) {
            return new ResolverFailure('The member identifier is missing in the root member reference');
        }
        return memberReference.memberIdentifier.identifier;
    }
    _selectDeclaration(astDeclarations, memberReference, astSymbolName) {
        if (memberReference.selector === undefined) {
            if (astDeclarations.length === 1) {
                return astDeclarations[0];
            }
            else {
                return new ResolverFailure(`The reference is ambiguous because "${astSymbolName}"`
                    + ` has more than one declaration; you need to add a TSDoc member reference selector`);
            }
        }
        const selectorName = memberReference.selector.selector;
        if (memberReference.selector.selectorKind !== "system" /* System */) {
            return new ResolverFailure(`The selector "${selectorName}" is not a supported selector type`);
        }
        let selectorSyntaxKind;
        switch (selectorName) {
            case 'class':
                selectorSyntaxKind = ts.SyntaxKind.ClassDeclaration;
                break;
            case 'enum':
                selectorSyntaxKind = ts.SyntaxKind.EnumDeclaration;
                break;
            case 'function':
                selectorSyntaxKind = ts.SyntaxKind.FunctionDeclaration;
                break;
            case 'interface':
                selectorSyntaxKind = ts.SyntaxKind.InterfaceDeclaration;
                break;
            case 'namespace':
                selectorSyntaxKind = ts.SyntaxKind.ModuleDeclaration;
                break;
            case 'type':
                selectorSyntaxKind = ts.SyntaxKind.TypeAliasDeclaration;
                break;
            case 'variable':
                selectorSyntaxKind = ts.SyntaxKind.VariableDeclaration;
                break;
            default:
                return new ResolverFailure(`Unsupported system selector "${selectorName}"`);
        }
        const matches = astDeclarations.filter(x => x.declaration.kind === selectorSyntaxKind);
        if (matches.length === 0) {
            return new ResolverFailure(`A declaration for "${astSymbolName}" was not found that matches the`
                + ` TSDoc selector "${selectorName}"`);
        }
        if (matches.length > 1) {
            return new ResolverFailure(`More than one declaration "${astSymbolName}" matches the`
                + ` TSDoc selector "${selectorName}"`);
        }
        return matches[0];
    }
}
exports.AstReferenceResolver = AstReferenceResolver;
//# sourceMappingURL=AstReferenceResolver.js.map