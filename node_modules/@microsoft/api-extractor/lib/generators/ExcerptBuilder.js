"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const Span_1 = require("../analyzer/Span");
class ExcerptBuilder {
    static build(options) {
        const span = new Span_1.Span(options.startingNode);
        const tokenRangesByNode = new Map();
        for (const excerpt of options.nodesToCapture || []) {
            if (excerpt.node) {
                tokenRangesByNode.set(excerpt.node, excerpt.tokenRange);
            }
        }
        const excerptTokens = [];
        ExcerptBuilder._buildSpan(excerptTokens, span, {
            referenceGenerator: options.referenceGenerator,
            startingNode: options.startingNode,
            stopBeforeChildKind: options.stopBeforeChildKind,
            tokenRangesByNode,
            disableMergingForNextToken: false
        });
        return excerptTokens;
    }
    static createEmptyTokenRange() {
        return { startIndex: 0, endIndex: 0 };
    }
    static _buildSpan(excerptTokens, span, state) {
        if (span.kind === ts.SyntaxKind.JSDocComment) {
            // Discard any comments
            return true;
        }
        // Can this node start a excerpt?
        const capturedTokenRange = state.tokenRangesByNode.get(span.node);
        let excerptStartIndex = 0;
        if (capturedTokenRange) {
            // We will assign capturedTokenRange.startIndex to be the index of the next token to be appended
            excerptStartIndex = excerptTokens.length;
            state.disableMergingForNextToken = true;
        }
        if (span.prefix) {
            let canonicalReference = undefined;
            if (span.kind === ts.SyntaxKind.Identifier) {
                const name = span.node;
                if (!isDeclarationName(name)) {
                    canonicalReference = state.referenceGenerator.getDeclarationReferenceForIdentifier(name);
                }
            }
            if (canonicalReference) {
                ExcerptBuilder._appendToken(excerptTokens, "Reference" /* Reference */, span.prefix, state, canonicalReference);
            }
            else {
                ExcerptBuilder._appendToken(excerptTokens, "Content" /* Content */, span.prefix, state);
            }
        }
        for (const child of span.children) {
            if (span.node === state.startingNode) {
                if (state.stopBeforeChildKind && child.kind === state.stopBeforeChildKind) {
                    // We reached the a child whose kind is stopBeforeChildKind, so stop traversing
                    return false;
                }
            }
            if (!this._buildSpan(excerptTokens, child, state)) {
                return false;
            }
        }
        if (span.suffix) {
            ExcerptBuilder._appendToken(excerptTokens, "Content" /* Content */, span.suffix, state);
        }
        if (span.separator) {
            ExcerptBuilder._appendToken(excerptTokens, "Content" /* Content */, span.separator, state);
        }
        // Are we building a excerpt?  If so, set its range
        if (capturedTokenRange) {
            capturedTokenRange.startIndex = excerptStartIndex;
            // We will assign capturedTokenRange.startIndex to be the index after the last token that was appended so far
            capturedTokenRange.endIndex = excerptTokens.length;
            state.disableMergingForNextToken = true;
        }
        return true;
    }
    static _appendToken(excerptTokens, excerptTokenKind, text, state, canonicalReference) {
        if (text.length === 0) {
            return;
        }
        if (excerptTokenKind !== "Content" /* Content */) {
            if (excerptTokenKind === "Reference" /* Reference */ && excerptTokens.length > 1
                && !state.disableMergingForNextToken) {
                // If the previous two tokens were a Reference and a '.', then concatenate
                // all three tokens as a qualified name Reference.
                const previousTokenM1 = excerptTokens[excerptTokens.length - 1];
                const previousTokenM2 = excerptTokens[excerptTokens.length - 2];
                if (previousTokenM1.kind === "Content" /* Content */
                    && previousTokenM1.text.trim() === '.'
                    && previousTokenM2.kind === "Reference" /* Reference */) {
                    previousTokenM2.text += '.' + text;
                    if (canonicalReference !== undefined) {
                        previousTokenM2.canonicalReference = canonicalReference.toString();
                    }
                    excerptTokens.pop(); // remove previousTokenM1;
                    return;
                }
            }
        }
        else {
            // If someone referenced this index, then we need to start a new token
            if (excerptTokens.length > 0 && !state.disableMergingForNextToken) {
                // Otherwise, can we merge with the previous token?
                const previousToken = excerptTokens[excerptTokens.length - 1];
                if (previousToken.kind === excerptTokenKind) {
                    previousToken.text += text;
                    return;
                }
            }
        }
        const excerptToken = { kind: excerptTokenKind, text: text };
        if (canonicalReference !== undefined) {
            excerptToken.canonicalReference = canonicalReference.toString();
        }
        excerptTokens.push(excerptToken);
        state.disableMergingForNextToken = false;
    }
}
exports.ExcerptBuilder = ExcerptBuilder;
function isDeclaration(node) {
    switch (node.kind) {
        case ts.SyntaxKind.FunctionDeclaration:
        case ts.SyntaxKind.FunctionExpression:
        case ts.SyntaxKind.VariableDeclaration:
        case ts.SyntaxKind.Parameter:
        case ts.SyntaxKind.EnumDeclaration:
        case ts.SyntaxKind.ClassDeclaration:
        case ts.SyntaxKind.ClassExpression:
        case ts.SyntaxKind.ModuleDeclaration:
        case ts.SyntaxKind.MethodDeclaration:
        case ts.SyntaxKind.MethodSignature:
        case ts.SyntaxKind.PropertyDeclaration:
        case ts.SyntaxKind.PropertySignature:
        case ts.SyntaxKind.GetAccessor:
        case ts.SyntaxKind.SetAccessor:
        case ts.SyntaxKind.InterfaceDeclaration:
        case ts.SyntaxKind.TypeAliasDeclaration:
        case ts.SyntaxKind.TypeParameter:
        case ts.SyntaxKind.EnumMember:
        case ts.SyntaxKind.BindingElement:
            return true;
        default:
            return false;
    }
}
function isDeclarationName(name) {
    return isDeclaration(name.parent) && name.parent.name === name;
}
//# sourceMappingURL=ExcerptBuilder.js.map