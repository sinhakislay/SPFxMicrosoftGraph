{"version":3,"file":"ExcerptBuilder.js","sourceRoot":"","sources":["../../src/generators/ExcerptBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport { DeclarationReference } from '@microsoft/tsdoc/lib/beta/DeclarationReference';\r\nimport {\r\n  ExcerptTokenKind,\r\n  IExcerptToken,\r\n  IExcerptTokenRange\r\n} from '@microsoft/api-extractor-model';\r\n\r\nimport { Span } from '../analyzer/Span';\r\nimport { DeclarationReferenceGenerator } from './DeclarationReferenceGenerator';\r\n\r\n/**\r\n * Used to provide ExcerptBuilder with a list of nodes whose token range we want to capture.\r\n */\r\nexport interface IExcerptBuilderNodeToCapture {\r\n  /**\r\n   * The node to capture\r\n   */\r\n  node: ts.Node | undefined;\r\n  /**\r\n   * The token range whose startIndex/endIndex will be overwritten with the indexes for the\r\n   * tokens corresponding to IExcerptBuilderNodeToCapture.node\r\n   */\r\n  tokenRange: IExcerptTokenRange;\r\n}\r\n\r\n/**\r\n * Options for ExcerptBuilder\r\n */\r\nexport interface ISignatureBuilderOptions {\r\n  referenceGenerator: DeclarationReferenceGenerator;\r\n  /**\r\n   * The AST node that we will traverse to extract tokens\r\n   */\r\n  startingNode: ts.Node;\r\n\r\n  /**\r\n   * Normally, the excerpt will include all child nodes for `startingNode`; whereas if `childKindToStopBefore`\r\n   * is specified, then the node traversal will stop before (i.e. excluding) the first immediate child\r\n   * of `startingNode` with the specified syntax kind.\r\n   *\r\n   * @remarks\r\n   * For example, suppose the signature is `interface X: Y { z: string }`.  The token `{` has syntax kind\r\n   * `ts.SyntaxKind.FirstPunctuation`, so we can specify that to truncate the excerpt to `interface X: Y`.\r\n   */\r\n  stopBeforeChildKind?: ts.SyntaxKind;\r\n\r\n  /**\r\n   * A list of child nodes whose token ranges we want to capture\r\n   */\r\n  nodesToCapture?: IExcerptBuilderNodeToCapture[];\r\n}\r\n\r\n/**\r\n * Internal state for ExcerptBuilder\r\n */\r\ninterface IBuildSpanState {\r\n  referenceGenerator: DeclarationReferenceGenerator;\r\n  startingNode: ts.Node;\r\n  stopBeforeChildKind: ts.SyntaxKind | undefined;\r\n\r\n  tokenRangesByNode: Map<ts.Node, IExcerptTokenRange>;\r\n\r\n  /**\r\n   * Normally adjacent tokens of the same kind get merged, to avoid creating lots of unnecessary extra tokens.\r\n   * However when an captured excerpt needs to start/end at a specific character, we temporarily disable merging by\r\n   * setting this flag.  After the new token is added, this flag is cleared.\r\n   */\r\n  disableMergingForNextToken: boolean;\r\n}\r\n\r\nexport class ExcerptBuilder {\r\n  public static build(options: ISignatureBuilderOptions): IExcerptToken[] {\r\n    const span: Span = new Span(options.startingNode);\r\n\r\n    const tokenRangesByNode: Map<ts.Node, IExcerptTokenRange> = new Map<ts.Node, IExcerptTokenRange>();\r\n    for (const excerpt of options.nodesToCapture || []) {\r\n      if (excerpt.node) {\r\n        tokenRangesByNode.set(excerpt.node, excerpt.tokenRange);\r\n      }\r\n    }\r\n\r\n    const excerptTokens: IExcerptToken[] = [];\r\n\r\n    ExcerptBuilder._buildSpan(excerptTokens, span, {\r\n      referenceGenerator: options.referenceGenerator,\r\n      startingNode: options.startingNode,\r\n      stopBeforeChildKind: options.stopBeforeChildKind,\r\n      tokenRangesByNode,\r\n      disableMergingForNextToken: false\r\n    });\r\n\r\n    return excerptTokens;\r\n  }\r\n\r\n  public static createEmptyTokenRange(): IExcerptTokenRange {\r\n    return { startIndex: 0, endIndex: 0 };\r\n  }\r\n\r\n  private static _buildSpan(excerptTokens: IExcerptToken[], span: Span, state: IBuildSpanState): boolean {\r\n    if (span.kind === ts.SyntaxKind.JSDocComment) {\r\n      // Discard any comments\r\n      return true;\r\n    }\r\n\r\n    // Can this node start a excerpt?\r\n    const capturedTokenRange: IExcerptTokenRange | undefined = state.tokenRangesByNode.get(span.node);\r\n    let excerptStartIndex: number = 0;\r\n\r\n    if (capturedTokenRange) {\r\n      // We will assign capturedTokenRange.startIndex to be the index of the next token to be appended\r\n      excerptStartIndex = excerptTokens.length;\r\n      state.disableMergingForNextToken = true;\r\n    }\r\n\r\n    if (span.prefix) {\r\n      let canonicalReference: DeclarationReference | undefined = undefined;\r\n\r\n      if (span.kind === ts.SyntaxKind.Identifier) {\r\n        const name: ts.Identifier = span.node as ts.Identifier;\r\n        if (!isDeclarationName(name)) {\r\n          canonicalReference = state.referenceGenerator.getDeclarationReferenceForIdentifier(name);\r\n        }\r\n      }\r\n\r\n      if (canonicalReference) {\r\n        ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Reference,\r\n          span.prefix, state, canonicalReference);\r\n      } else {\r\n        ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Content,\r\n          span.prefix, state);\r\n      }\r\n    }\r\n\r\n    for (const child of span.children) {\r\n      if (span.node === state.startingNode) {\r\n        if (state.stopBeforeChildKind && child.kind === state.stopBeforeChildKind) {\r\n          // We reached the a child whose kind is stopBeforeChildKind, so stop traversing\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!this._buildSpan(excerptTokens, child, state)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (span.suffix) {\r\n      ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Content, span.suffix, state);\r\n    }\r\n    if (span.separator) {\r\n      ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Content, span.separator, state);\r\n    }\r\n\r\n    // Are we building a excerpt?  If so, set its range\r\n    if (capturedTokenRange) {\r\n      capturedTokenRange.startIndex = excerptStartIndex;\r\n\r\n      // We will assign capturedTokenRange.startIndex to be the index after the last token that was appended so far\r\n      capturedTokenRange.endIndex = excerptTokens.length;\r\n\r\n      state.disableMergingForNextToken = true;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private static _appendToken(excerptTokens: IExcerptToken[], excerptTokenKind: ExcerptTokenKind,\r\n    text: string, state: IBuildSpanState, canonicalReference?: DeclarationReference): void {\r\n\r\n    if (text.length === 0) {\r\n      return;\r\n    }\r\n\r\n    if (excerptTokenKind !== ExcerptTokenKind.Content) {\r\n      if (excerptTokenKind === ExcerptTokenKind.Reference && excerptTokens.length > 1\r\n        && !state.disableMergingForNextToken) {\r\n        // If the previous two tokens were a Reference and a '.', then concatenate\r\n        // all three tokens as a qualified name Reference.\r\n        const previousTokenM1: IExcerptToken = excerptTokens[excerptTokens.length - 1];\r\n        const previousTokenM2: IExcerptToken = excerptTokens[excerptTokens.length - 2];\r\n        if (previousTokenM1.kind === ExcerptTokenKind.Content\r\n          && previousTokenM1.text.trim() === '.'\r\n          && previousTokenM2.kind === ExcerptTokenKind.Reference) {\r\n\r\n          previousTokenM2.text += '.' + text;\r\n          if (canonicalReference !== undefined) {\r\n            previousTokenM2.canonicalReference = canonicalReference.toString();\r\n          }\r\n          excerptTokens.pop(); // remove previousTokenM1;\r\n          return;\r\n        }\r\n      }\r\n    } else {\r\n      // If someone referenced this index, then we need to start a new token\r\n      if (excerptTokens.length > 0 && !state.disableMergingForNextToken) {\r\n        // Otherwise, can we merge with the previous token?\r\n        const previousToken: IExcerptToken = excerptTokens[excerptTokens.length - 1];\r\n        if (previousToken.kind === excerptTokenKind) {\r\n          previousToken.text += text;\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    const excerptToken: IExcerptToken = { kind: excerptTokenKind, text: text };\r\n    if (canonicalReference !== undefined) {\r\n      excerptToken.canonicalReference = canonicalReference.toString();\r\n    }\r\n    excerptTokens.push(excerptToken);\r\n    state.disableMergingForNextToken = false;\r\n  }\r\n\r\n}\r\n\r\nfunction isDeclaration(node: ts.Node): node is ts.NamedDeclaration {\r\n  switch (node.kind) {\r\n    case ts.SyntaxKind.FunctionDeclaration:\r\n    case ts.SyntaxKind.FunctionExpression:\r\n    case ts.SyntaxKind.VariableDeclaration:\r\n    case ts.SyntaxKind.Parameter:\r\n    case ts.SyntaxKind.EnumDeclaration:\r\n    case ts.SyntaxKind.ClassDeclaration:\r\n    case ts.SyntaxKind.ClassExpression:\r\n    case ts.SyntaxKind.ModuleDeclaration:\r\n    case ts.SyntaxKind.MethodDeclaration:\r\n    case ts.SyntaxKind.MethodSignature:\r\n    case ts.SyntaxKind.PropertyDeclaration:\r\n    case ts.SyntaxKind.PropertySignature:\r\n    case ts.SyntaxKind.GetAccessor:\r\n    case ts.SyntaxKind.SetAccessor:\r\n    case ts.SyntaxKind.InterfaceDeclaration:\r\n    case ts.SyntaxKind.TypeAliasDeclaration:\r\n    case ts.SyntaxKind.TypeParameter:\r\n    case ts.SyntaxKind.EnumMember:\r\n    case ts.SyntaxKind.BindingElement:\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\nfunction isDeclarationName(name: ts.Identifier): boolean {\r\n  return isDeclaration(name.parent) && name.parent.name === name;\r\n}"]}