{"version":3,"file":"DeclarationReferenceGenerator.js","sourceRoot":"","sources":["../../src/generators/DeclarationReferenceGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n// tslint:disable:no-bitwise\r\nimport * as ts from 'typescript';\r\nimport {\r\n  DeclarationReference,\r\n  ModuleSource,\r\n  GlobalSource,\r\n  Navigation,\r\n  Meaning\r\n} from '@microsoft/tsdoc/lib/beta/DeclarationReference';\r\nimport { PackageJsonLookup, INodePackageJson, InternalError } from '@microsoft/node-core-library';\r\nimport { TypeScriptHelpers } from '../analyzer/TypeScriptHelpers';\r\nimport { TypeScriptInternals } from '../analyzer/TypeScriptInternals';\r\n\r\nexport class DeclarationReferenceGenerator {\r\n  public static readonly unknownReference: string = '?';\r\n\r\n  private _packageJsonLookup: PackageJsonLookup;\r\n  private _workingPackageName: string;\r\n  private _program: ts.Program;\r\n  private _typeChecker: ts.TypeChecker;\r\n\r\n  constructor(packageJsonLookup: PackageJsonLookup, workingPackageName: string, program: ts.Program,\r\n    typeChecker: ts.TypeChecker) {\r\n\r\n    this._packageJsonLookup = packageJsonLookup;\r\n    this._workingPackageName = workingPackageName;\r\n    this._program = program;\r\n    this._typeChecker = typeChecker;\r\n  }\r\n\r\n  /**\r\n   * Gets the UID for a TypeScript Identifier that references a type.\r\n   */\r\n  public getDeclarationReferenceForIdentifier(node: ts.Identifier): DeclarationReference | undefined {\r\n    const symbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(node);\r\n    if (symbol !== undefined) {\r\n      const isExpression: boolean = isInExpressionContext(node);\r\n      return this.getDeclarationReferenceForSymbol(symbol, isExpression ? ts.SymbolFlags.Value : ts.SymbolFlags.Type)\r\n        || this.getDeclarationReferenceForSymbol(symbol, isExpression ? ts.SymbolFlags.Type : ts.SymbolFlags.Value)\r\n        || this.getDeclarationReferenceForSymbol(symbol, ts.SymbolFlags.Namespace);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the DeclarationReference for a TypeScript Symbol for a given meaning.\r\n   */\r\n  public getDeclarationReferenceForSymbol(symbol: ts.Symbol, meaning: ts.SymbolFlags\r\n    ): DeclarationReference | undefined {\r\n    return this._symbolToDeclarationReference(symbol, meaning, /*includeModuleSymbols*/ false);\r\n  }\r\n\r\n  private _symbolToDeclarationReference(symbol: ts.Symbol, meaning: ts.SymbolFlags, includeModuleSymbols: boolean\r\n    ): DeclarationReference | undefined {\r\n    if (symbol.flags & ts.SymbolFlags.ExportValue) {\r\n      symbol = this._typeChecker.getExportSymbolOfSymbol(symbol);\r\n    }\r\n    if (symbol.flags & ts.SymbolFlags.Alias) {\r\n      symbol = this._typeChecker.getAliasedSymbol(symbol);\r\n    }\r\n\r\n    if (isExternalModuleSymbol(symbol)) {\r\n      if (!includeModuleSymbols) {\r\n        return undefined;\r\n      }\r\n      const sourceFile: ts.SourceFile | undefined =\r\n        symbol.declarations\r\n        && symbol.declarations[0]\r\n        && symbol.declarations[0].getSourceFile();\r\n      return new DeclarationReference(this._sourceFileToModuleSource(sourceFile));\r\n    }\r\n\r\n    // Do not generate a declaration reference for a type parameter.\r\n    if (symbol.flags & ts.SymbolFlags.TypeParameter) {\r\n      return undefined;\r\n    }\r\n\r\n    const parent: ts.Symbol | undefined = TypeScriptInternals.getSymbolParent(symbol);\r\n    let parentRef: DeclarationReference | undefined;\r\n    if (parent) {\r\n      parentRef = this._symbolToDeclarationReference(parent, ts.SymbolFlags.Namespace, /*includeModuleSymbols*/ true);\r\n    } else {\r\n      // this may be a local symbol in a module...\r\n      const sourceFile: ts.SourceFile | undefined =\r\n        symbol.declarations\r\n        && symbol.declarations[0]\r\n        && symbol.declarations[0].getSourceFile();\r\n      if (ts.isExternalModule(sourceFile)) {\r\n        parentRef = new DeclarationReference(this._sourceFileToModuleSource(sourceFile));\r\n      } else {\r\n        parentRef = new DeclarationReference(GlobalSource.instance);\r\n      }\r\n    }\r\n\r\n    if (parentRef === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    let localName: string = symbol.name;\r\n    if (symbol.escapedName === ts.InternalSymbolName.Constructor) {\r\n      localName = 'constructor';\r\n    } else {\r\n      const wellKnownName: string | undefined = TypeScriptHelpers.tryDecodeWellKnownSymbolName(symbol.escapedName);\r\n      if (wellKnownName) {\r\n        // TypeScript binds well-known ECMAScript symbols like 'Symbol.iterator' as '__@iterator'.\r\n        // This converts a string like '__@iterator' into the property name '[Symbol.iterator]'.\r\n        localName = wellKnownName;\r\n      } else if (TypeScriptHelpers.isUniqueSymbolName(symbol.escapedName)) {\r\n        for (const decl of symbol.declarations || []) {\r\n          const declName: ts.DeclarationName | undefined = ts.getNameOfDeclaration(decl);\r\n          if (declName && ts.isComputedPropertyName(declName)) {\r\n            const lateName: string | undefined = TypeScriptHelpers.tryGetLateBoundName(declName);\r\n            if (lateName !== undefined) {\r\n              localName = lateName;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let navigation: Navigation | 'global' = getNavigationToSymbol(symbol);\r\n    if (navigation === 'global') {\r\n      if (parentRef.source !== GlobalSource.instance) {\r\n        parentRef = new DeclarationReference(GlobalSource.instance);\r\n      }\r\n      navigation = Navigation.Exports;\r\n    }\r\n\r\n    return parentRef\r\n      .addNavigationStep(navigation, localName)\r\n      .withMeaning(getMeaningOfSymbol(symbol, meaning));\r\n  }\r\n\r\n  private _getPackageName(sourceFile: ts.SourceFile): string {\r\n    if (this._program.isSourceFileFromExternalLibrary(sourceFile)) {\r\n      const packageJson: INodePackageJson | undefined = this._packageJsonLookup\r\n        .tryLoadNodePackageJsonFor(sourceFile.fileName);\r\n\r\n      if (packageJson && packageJson.name) {\r\n        return packageJson.name;\r\n      }\r\n      return DeclarationReferenceGenerator.unknownReference;\r\n    }\r\n    return this._workingPackageName;\r\n  }\r\n\r\n  private _sourceFileToModuleSource(sourceFile: ts.SourceFile | undefined): GlobalSource | ModuleSource {\r\n    if (sourceFile && ts.isExternalModule(sourceFile)) {\r\n      return new ModuleSource(this._getPackageName(sourceFile));\r\n    }\r\n    return GlobalSource.instance;\r\n  }\r\n}\r\n\r\nfunction isExternalModuleSymbol(symbol: ts.Symbol): boolean {\r\n  return !!(symbol.flags & ts.SymbolFlags.ValueModule)\r\n    && symbol.valueDeclaration !== undefined\r\n    && ts.isSourceFile(symbol.valueDeclaration);\r\n}\r\n\r\nfunction isSameSymbol(left: ts.Symbol | undefined, right: ts.Symbol): boolean {\r\n  return left === right\r\n    || !!(left && left.valueDeclaration && right.valueDeclaration && left.valueDeclaration === right.valueDeclaration);\r\n}\r\n\r\nfunction getNavigationToSymbol(symbol: ts.Symbol): Navigation | 'global' {\r\n  const parent: ts.Symbol | undefined = TypeScriptInternals.getSymbolParent(symbol);\r\n  // First, try to determine navigation to symbol via its parent.\r\n  if (parent) {\r\n    if (parent.exports && isSameSymbol(parent.exports.get(symbol.escapedName), symbol)) {\r\n      return Navigation.Exports;\r\n    }\r\n    if (parent.members && isSameSymbol(parent.members.get(symbol.escapedName), symbol)) {\r\n      return Navigation.Members;\r\n    }\r\n    if (parent.globalExports && isSameSymbol(parent.globalExports.get(symbol.escapedName), symbol)) {\r\n      return 'global';\r\n    }\r\n  }\r\n\r\n  // Next, try determining navigation to symbol by its node\r\n  if (symbol.valueDeclaration) {\r\n    const declaration: ts.Declaration = ts.isBindingElement(symbol.valueDeclaration)\r\n      ? ts.walkUpBindingElementsAndPatterns(symbol.valueDeclaration)\r\n      : symbol.valueDeclaration;\r\n    if (ts.isClassElement(declaration) && ts.isClassLike(declaration.parent)) {\r\n      // class members are an \"export\" if they have the static modifier.\r\n      return ts.getCombinedModifierFlags(declaration) & ts.ModifierFlags.Static\r\n        ? Navigation.Exports\r\n        : Navigation.Members;\r\n    }\r\n    if (ts.isTypeElement(declaration) || ts.isObjectLiteralElement(declaration)) {\r\n      // type and object literal element members are just members\r\n      return Navigation.Members;\r\n    }\r\n    if (ts.isEnumMember(declaration)) {\r\n      // enum members are exports\r\n      return Navigation.Exports;\r\n    }\r\n    if (ts.isExportSpecifier(declaration)\r\n      || ts.isExportAssignment(declaration)\r\n      || ts.isExportSpecifier(declaration)\r\n      || ts.isExportDeclaration(declaration)\r\n      || ts.isNamedExports(declaration)\r\n    ) {\r\n      return Navigation.Exports;\r\n    }\r\n    // declarations are exports if they have an `export` modifier.\r\n    if (ts.getCombinedModifierFlags(declaration) & ts.ModifierFlags.Export) {\r\n      return Navigation.Exports;\r\n    }\r\n    if (ts.isSourceFile(declaration.parent) && !ts.isExternalModule(declaration.parent)) {\r\n      // declarations in a source file are global if the source file is not a module.\r\n      return 'global';\r\n    }\r\n  }\r\n  // all other declarations are locals\r\n  return Navigation.Locals;\r\n}\r\n\r\nfunction getMeaningOfSymbol(symbol: ts.Symbol, meaning: ts.SymbolFlags): Meaning | undefined {\r\n  if (symbol.flags & meaning & ts.SymbolFlags.Class) {\r\n    return Meaning.Class;\r\n  }\r\n  if (symbol.flags & meaning & ts.SymbolFlags.Enum) {\r\n    return Meaning.Enum;\r\n  }\r\n  if (symbol.flags & meaning & ts.SymbolFlags.Interface) {\r\n    return Meaning.Interface;\r\n  }\r\n  if (symbol.flags & meaning & ts.SymbolFlags.TypeAlias) {\r\n    return Meaning.TypeAlias;\r\n  }\r\n  if (symbol.flags & meaning & ts.SymbolFlags.Function) {\r\n    return Meaning.Function;\r\n  }\r\n  if (symbol.flags & meaning & ts.SymbolFlags.Variable) {\r\n    return Meaning.Variable;\r\n  }\r\n  if (symbol.flags & meaning & ts.SymbolFlags.Module) {\r\n    return Meaning.Namespace;\r\n  }\r\n  if (symbol.flags & meaning & ts.SymbolFlags.ClassMember) {\r\n    return Meaning.Member;\r\n  }\r\n  if (symbol.flags & meaning & ts.SymbolFlags.Constructor) {\r\n    return Meaning.Constructor;\r\n  }\r\n  if (symbol.flags & meaning & ts.SymbolFlags.EnumMember) {\r\n    return Meaning.Member;\r\n  }\r\n  if (symbol.flags & meaning & ts.SymbolFlags.Signature) {\r\n    if (symbol.escapedName === ts.InternalSymbolName.Call) {\r\n      return Meaning.CallSignature;\r\n    }\r\n    if (symbol.escapedName === ts.InternalSymbolName.New) {\r\n      return Meaning.ConstructSignature;\r\n    }\r\n    if (symbol.escapedName === ts.InternalSymbolName.Index) {\r\n      return Meaning.IndexSignature;\r\n    }\r\n  }\r\n  if (symbol.flags & meaning & ts.SymbolFlags.TypeParameter) {\r\n    // This should have already been handled in `getDeclarationReferenceOfSymbol`.\r\n    throw new InternalError('Not supported.');\r\n  }\r\n  return undefined;\r\n}\r\n\r\nfunction isInExpressionContext(node: ts.Node): boolean {\r\n  switch (node.parent.kind) {\r\n    case ts.SyntaxKind.TypeQuery: return true;\r\n    case ts.SyntaxKind.QualifiedName: return isInExpressionContext(node.parent);\r\n    default: return false;\r\n  }\r\n}"]}