"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash = require("lodash");
const path = require("path");
const webpack = require("webpack");
const TerserPlugin = require("terser-webpack-plugin");
const fsx = require("fs-extra");
const os_1 = require("os");
const node_core_library_1 = require("@microsoft/node-core-library");
const set_webpack_public_path_plugin_1 = require("@microsoft/set-webpack-public-path-plugin");
const ExternalsProcessor_1 = require("./ExternalsProcessor");
const OdspGulpTask_1 = require("./../OdspGulpTask");
const FileUtils_1 = require("./../utilities/FileUtils");
function getComponentsBundleId(manifests) {
    return manifests.map((manifest) => `${manifest.id}_${manifest.version}`).join('+');
}
exports.getComponentsBundleId = getComponentsBundleId;
function getBundleId(bundle) {
    const manifests = [];
    Object.keys(bundle.components).forEach((id) => manifests.push(bundle.components[id].manifestData));
    return getComponentsBundleId(manifests);
}
exports.getBundleId = getBundleId;
exports.fileLoaderExts = ['jpg', 'png', 'woff', 'eot', 'ttf', 'svg', 'gif', 'dds'];
/**
 * Configures the @microsoft/gulp-core-build-webpack task with some smart defaults based on the package configuration.
 *
 * Example:
 *  IN:
 *    setConfig({
 *      webpack: <reference to webpack task>,
 *      webpackPublicPathOptions: <options for @microsoft/loader-set-webpack-public-path>,
 *      libraryName: <optional library name - set this if the library should be a global on the window>,
 *      configureExternalBundlingWebpackTask: <optional reference to ConfigureExternalBundlingWebpackTask task>
 *    })
 *    buildConfig.properties.entries = [{
 *      "entry": "./lib/App.js",
 *      "manifest": "./src/app.manifest.json",
 *      "outputPath": "dist/app.bundle.js"
 *    }]
 *    buildConfig.properties.externals = {
 *      "react-dom": "node_modules/react-dom/dist/react-dom.js",
 *      "react": "node_modules/react/dist/react.js",
 *      "flux": "node_modules/flux/dist/flux.js",
 *    }
 *
 *  OUT:
 *    set webpack config to (approximately):
 *    {
 *        context: ... root path ...,
 *        entry: { ... mapping of names to entries ... },
 *        resolve: {
 *          modules: [ ... root path + /node_modules ],
 *          alias: { }
 *        },
 *        output: {
 *          library: <library name, if provided>,
 *          libraryTarget: <library target, if specified> or 'amd',
 *          path: ... dist folder ...,
 *          filename: '[name].js',
 *          devtoolModuleFilenameTemplate: 'webpack:///../[resource-path]',
 *          devtoolFallbackModuleFilenameTemplate: 'webpack:///../[resource-path]?[hash]'
 *        },
 *        externals: [ ... externals names ... ],
 *        module: {
 *          noParse: [ /\.map$/ ],
 *          rules: [
 *            {
 *              test: /\.css$/,
 *              use: [
 *                {
 *                  loader: `@microsoft/load-themed-styles'
 *                },
 *                {
 *                  loader: 'css-loader',
 *                  options: {
 *                    minimize: true
 *                  }
 *                }
 *              ]
 *            },
 *            {
 *              test: /\.(jpg|png|woff|eot|ttf|svg|gif)$/,
 *              use: [
 *                {
 *                  loader: '@microsoft/loader-cased-file',
 *                  options: {
 *                    name: '[name:lower]_[hash].[ext]'
 *                  }
 *                }
 *              ]
 *            },
 *            {
 *              test: /\.html$/,
 *              use: [
 *                {
 *                  loader: 'html-loader'
 *                }
 *              ]
 *            }
 *          ]
 *        },
 *        plugins: []
 *      }
 */
class ConfigureWebpackTask extends OdspGulpTask_1.default {
    constructor() {
        super('configure-webpack', {
            libraryName: undefined,
            webpack: undefined,
            webpackPublicPathOptions: undefined,
            additionalConfiguration: undefined,
            configureExternalBundlingWebpackTask: undefined
        });
        this._baseConfig = {
            module: {
                rules: [
                    {
                        use: [
                            {
                                loader: require.resolve('@microsoft/loader-load-themed-styles'),
                                options: {
                                    async: true
                                }
                            },
                            {
                                loader: require.resolve('css-loader')
                            },
                            {
                                loader: require.resolve('postcss-loader'),
                                options: {
                                    ident: 'postcss',
                                    minimize: true,
                                    plugins: [
                                        require('cssnano')({ preset: 'default' })
                                    ]
                                }
                            }
                        ],
                        test: /\.css$/
                    },
                    {
                        use: [
                            {
                                loader: require.resolve('@microsoft/loader-cased-file'),
                                options: {
                                    name: '[name:lower]_[hash].[ext]'
                                }
                            }
                        ],
                        test: new RegExp(`\.(${exports.fileLoaderExts.map((e) => lodash.escapeRegExp(e)).join('|')})((\\?|\\#).+)?$`)
                    },
                    {
                        use: [
                            {
                                loader: require.resolve('html-loader')
                            }
                        ],
                        test: /\.html$/
                    }
                ],
                noParse: [/\.map$/]
            },
            resolve: {
                alias: {},
                modules: [
                    'node_modules',
                    'lib'
                ]
            }
        };
    }
    loadSchema() {
        return node_core_library_1.JsonFile.load(path.join(__dirname, 'configure-webpack.schema.json'));
    }
    setConfig(config) {
        if (config.webpack && config.webpack.name !== 'webpack') {
            this.logWarning('Setting webpack property to non-"@microsoft/gulp-core-build-webpack"-type will ' +
                'prevent configuration');
        }
        super.mergeConfig(config);
    }
    executeTask(gulp, completeCallback) {
        if (!this.taskConfig.webpack) {
            this.logWarning('"webpack" is not defined in the task configuration. Nothing to configure.');
            completeCallback();
            return;
        }
        const configValidationResult = this._validateEntries();
        if (configValidationResult) {
            completeCallback(configValidationResult);
            return;
        }
        if (!this.buildConfig.properties) {
            this._logNoEntriesWarning();
            this._setWebpackConfig({});
            completeCallback();
            return;
        }
        // The ConfigureExternalBundlingWebpackTask will disable the second webpack task
        // when doing a dev build or in a project without localized resources.
        // This, however, breaks gulp serve. Therefore, we should ensure the webpack task is activated.
        // @todo 261553 - this should be removed when we do this refactor
        this.taskConfig.webpack.isEnabled = () => true;
        const configBundleEntries = this.properties.bundles || {};
        const externalsKeys = ExternalsProcessor_1.getExternalsKeys(this);
        // Remove the specified linked externals to ensure they're bundled
        if (this.taskConfig.linkedExternalsToBundle && this.taskConfig.linkedExternalsToBundle.length) {
            for (const linkedExternalToBundle of this.taskConfig.linkedExternalsToBundle) {
                const linkedExternalToBundleIndex = externalsKeys.indexOf(linkedExternalToBundle);
                if (linkedExternalToBundleIndex !== -1) {
                    externalsKeys.splice(linkedExternalToBundleIndex, 1);
                }
            }
        }
        const localizedResources = this.properties.localizedResources || {};
        const localizedResourcesKeys = Object.keys(localizedResources);
        const configBundleEntriesCount = Object.keys(configBundleEntries).length;
        if (configBundleEntriesCount === 0) {
            this._logNoEntriesWarning();
            this.taskConfig.webpack.isEnabled = () => false;
            completeCallback();
            return;
        }
        this.logVerbose(`${configBundleEntriesCount} entries specified.`);
        this.logVerbose(`${externalsKeys.length} externals specified.`);
        this.logVerbose(`${localizedResourcesKeys.length} localized resources specified.`);
        localizedResourcesKeys.forEach((key) => {
            if (externalsKeys.indexOf(key) !== -1) {
                this.logError(`Invalid Configuration: Key "${key}" is specified in both externals and localizedResources.`);
            }
        });
        const webpackPublicPathOptions = lodash.clone(this.taskConfig.webpackPublicPathOptions) || {};
        if (!webpackPublicPathOptions.systemJs) {
            lodash.merge(webpackPublicPathOptions, {
                scriptName: {
                    // This will become a regex that matches:
                    // - a forward slash ("/")
                    // - the bundle name ("[name]" is replaced with the bundle name)
                    // - zero or more sequences of:
                    //   - an underscore ("_")
                    //   - one or more alphanumeric characters or dashes
                    // - ".js"
                    name: '\\\/[name](_[a-z0-9-]+)*\\\\.js',
                    isTokenized: true
                }
            });
        }
        // Users can use the --entry to control which entries actually get bundled
        // This value can match the GUID or the alias
        const entryParam = this.buildConfig.args['entry']; // tslint:disable-line:no-string-literal
        this.properties.bundleEntries = [];
        const webpackEntries = {};
        let foundEntry;
        for (const bundleName in configBundleEntries) {
            if (configBundleEntries.hasOwnProperty(bundleName)) {
                const configEntry = configBundleEntries[bundleName];
                let shouldBundleEntry = entryParam === undefined;
                const bundleEntry = {
                    bundleName,
                    nonLocalizedEntrypointPath: path.join(this.outputDirectory, `${bundleName}.js`),
                    components: {}
                };
                for (const componentEntry of configEntry.components) {
                    const manifestData = this.getManifest(componentEntry.manifest);
                    // If the manifest version is "*", replace it with the package version. Do this here to make sure the
                    //  bundle's name doesn't contain the "*" version
                    if (manifestData.version === '*') {
                        const manifestVersion = this.getPackageVersion();
                        manifestData.version = manifestVersion;
                    }
                    shouldBundleEntry = shouldBundleEntry ||
                        (entryParam && manifestData &&
                            (manifestData.id.toLowerCase() === entryParam.toLowerCase() ||
                                manifestData.alias.toLowerCase() === entryParam.toLowerCase()));
                    if (entryParam === undefined || shouldBundleEntry) {
                        foundEntry = true;
                        // Keep a counter of the manifests inside the bundle so we can set the exportName property in the produced
                        //  manifest(s) and generate a JS file to bundle both components' entrypoints
                        bundleEntry.components[manifestData.id] = Object.assign({}, componentEntry, { manifestData, manifestPath: path.join(this.buildConfig.rootPath, componentEntry.manifest) });
                    }
                }
                if (shouldBundleEntry) {
                    const componentKeys = Object.keys(bundleEntry.components);
                    if (componentKeys.length === 1) {
                        // Single component, just point to its entrypoint in the webpack config
                        webpackEntries[bundleName] = path.join(this.buildConfig.rootPath, bundleEntry.components[componentKeys[0]].entrypoint);
                    }
                    else {
                        // Multiple components, we need to generate an entry to point the webpack config at
                        webpackEntries[bundleName] = this._generateBundleEntrypointFile(bundleEntry);
                    }
                    this.properties.bundleEntries.push(bundleEntry);
                }
            }
        }
        if (entryParam && !foundEntry) {
            completeCallback(`The "--entry" flag was specified, but "${entryParam}" did not match ` +
                `the id or alias of any entries listed in config.json`);
            return;
        }
        this.properties.webpackLibraryName = this.taskConfig.libraryName || (() => {
            if (this.properties.bundleEntries.length === 0) {
                // We're not producing any bundles, so we don't need to worry about the library name
                return undefined;
            }
            else if (this.properties.bundleEntries.length === 1) {
                // We're producing one bundle, so we can generate a simple name
                return getBundleId(this.properties.bundleEntries[0]);
            }
            else {
                // There are multiple bundles. Because we need something unique for the webpack JSONP function, we'll just
                //  concatenate the IDs and then hash them. In the post-bundle steps, we'll replace the "define(<name>, ..."
                //  name with the real IDs. When we update this task to support multiple webpack configurations, we can
                //  separate each bundle to have its own library name.
                this.properties.webpackLibraryNameIsTemporary = true;
                return FileUtils_1.getFullHash(this.properties.bundleEntries.map(bundle => getBundleId(bundle)).join(''));
            }
        })();
        const configAddons = {
            context: this.buildConfig.rootPath,
            devtool: this.buildConfig.production ? undefined : 'source-map',
            mode: this.buildConfig.production ? 'production' : 'development',
            entry: webpackEntries,
            externals: externalsKeys.concat(localizedResourcesKeys),
            module: {
                rules: [
                    {
                        test: /\.js$/,
                        enforce: 'pre',
                        use: require.resolve('source-map-loader'),
                        exclude: [
                            /node_modules/
                        ]
                    }
                ]
            },
            output: {
                hashFunction: 'md5',
                chunkFilename: 'chunk.[name]_[contenthash].js',
                filename: '[name].js',
                library: this.properties.webpackLibraryName,
                libraryTarget: this.taskConfig.libraryTarget || 'amd',
                path: this.outputDirectory,
                devtoolModuleFilenameTemplate: 'webpack:///../[resource-path]',
                devtoolFallbackModuleFilenameTemplate: 'webpack:///../[resource-path]?[hash]'
            },
            optimization: {
                moduleIds: 'hashed'
            },
            plugins: [
                new set_webpack_public_path_plugin_1.SetPublicPathPlugin(webpackPublicPathOptions),
                new webpack.DefinePlugin({
                    'process.env.NODE_ENV': JSON.stringify(this.buildConfig.production ? 'production' : 'dev'),
                    DEBUG: !this.buildConfig.production,
                    DEPRECATED_UNIT_TEST: false,
                    DATACENTER: !this.buildConfig.args['on-prem']
                })
            ]
        };
        if (this.buildConfig.production) {
            configAddons.optimization.minimizer = [
                new TerserPlugin({
                    terserOptions: {
                        compress: {
                            warnings: false
                        },
                        mangle: true,
                        output: {
                            comments: false
                        }
                    }
                })
            ];
        }
        let config = this._appendToBaseConfig(configAddons);
        if (this.taskConfig.configureExternalBundlingWebpackTask) {
            this.taskConfig.configureExternalBundlingWebpackTask.tinkerWithBaseWebpackConfig(config);
        }
        if (this.taskConfig.additionalConfiguration) {
            config = this.taskConfig.additionalConfiguration(config);
        }
        this._setWebpackConfig(config);
        completeCallback();
        return;
    }
    /**
     * Modify the localized webpack config to make sure the end result is correct.
     *
     * @internal
     */
    tinkerWithLocConfig(config) {
        config.output.libraryTarget = this.taskConfig.libraryTarget || 'amd';
    }
    _appendToBaseConfig(config) {
        return lodash.mergeWith({}, this._baseConfig, config, (value1, value2) => {
            if (lodash.isArray(value1) && lodash.isArray(value2)) {
                return lodash.concat(value1, value2);
            }
            else {
                return undefined;
            }
        });
    }
    _logNoEntriesWarning() {
        this.logWarning('No entries are defined, so no bundles will be produced.');
    }
    _setWebpackConfig(config) {
        const webpackTask = this.taskConfig.webpack;
        const sourceMapWarningSuppression = /Cannot find SourceMap \'.+\'\: Error\:/;
        // Disable Performance hints.
        const performanceHintSuppression = /(asset|entrypoint) size limit.*/;
        const performanceRecommendationSuppression = /webpack performance recommendations.*/;
        const suppressedWarnings = webpackTask.taskConfig.suppressWarnings || [];
        if (webpackTask) {
            webpackTask.setConfig({
                config: config,
                configPath: null,
                suppressWarnings: suppressedWarnings.concat([
                    sourceMapWarningSuppression,
                    performanceHintSuppression,
                    performanceRecommendationSuppression
                ])
            });
        }
    }
    _validateEntries() {
        if (this.properties.bundles) {
            const entrypointPaths = new Set();
            const manifestPaths = new Set();
            for (const bundleName in this.properties.bundles) {
                if (this.properties.bundles.hasOwnProperty(bundleName)) {
                    const bundleEntry = this.properties.bundles[bundleName];
                    for (const component of bundleEntry.components) {
                        const entrypointPath = path.resolve(path.join(this.buildConfig.rootPath, component.entrypoint)).toUpperCase();
                        if (entrypointPaths.has(entrypointPath)) {
                            return `Entry path "${entrypointPath}" occurs in multiple config.json components. This is not supported.`;
                        }
                        else {
                            entrypointPaths.add(entrypointPath);
                        }
                        const manifestPath = path.resolve(path.join(this.buildConfig.rootPath, component.manifest)).toUpperCase();
                        if (manifestPaths.has(manifestPath)) {
                            return `Manifest path "${manifestPath}" occurs in multiple config.json components. This is not ` +
                                'supported.';
                        }
                        else {
                            manifestPaths.add(manifestPath);
                        }
                    }
                }
            }
        }
    }
    /**
     * Writes the entrypoint file to the temp directory and returns the path to the file.
     */
    _generateBundleEntrypointFile(bundleEntry) {
        const filePath = path.join(this.buildConfig.rootPath, this.buildConfig.tempFolder, 'bundle-entries', `${bundleEntry.bundleName}.js`);
        const fileContents = [
            'Object.defineProperty(exports, "__esModule", { value: true });',
            ...Object.keys(bundleEntry.components).map((id) => {
                const fullEntrypointPath = path.join(this.buildConfig.rootPath, bundleEntry.components[id].entrypoint);
                return `exports['${id}'] = require('${fullEntrypointPath.replace(/\\/g, '\\\\')}');`;
            })
        ].join(os_1.EOL);
        fsx.ensureDirSync(path.dirname(filePath));
        fsx.writeFileSync(filePath, fileContents);
        return filePath;
    }
}
exports.ConfigureWebpackTask = ConfigureWebpackTask;
//# sourceMappingURL=ConfigureWebpackTask.js.map