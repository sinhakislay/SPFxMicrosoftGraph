"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash = require("lodash");
const path = require("path");
const node_core_library_1 = require("@microsoft/node-core-library");
const ExternalsProcessor_1 = require("./ExternalsProcessor");
const OdspGulpTask_1 = require("./../OdspGulpTask");
const CopyAssetsTask_1 = require("./../copyAssets/CopyAssetsTask");
/**
 * Configures the @microsoft/gulp-core-build-webpack task to bundle localized externals into another, pre-built package.
 *
 * Example:
 *  IN:
 *    setConfig({
 *      webpack: <reference to webpack task>,
 *      localizedResources: <optional - list of localized externals>
 *      configureWebpackTask: <reference to the ConfigureWebpackTask task>,
 *      debugLocale: <optional - locale to use for a debug build>,
 *      additionalLoaders: <optional - additional loaders for localized resources>
 *    })
 *
 *  OUT:
 *    If any resources are specified and found, set webpack config to:
 *      {
 *        entry: <entries with locales>,
 *        module: {
 *          rules: ([
 *          ] <and additional loaders, if specified>,
 *          noParse: [ /\.map$/ ],
 *        },
 *        resolve: {
 *          alias: <localized resources>,
 *          modulesDirectories: [
 *            '',
 *            'node_modules',
 *            'lib'
 *          ]
 *        },
 *        context: <dist directory>,
 *        devtool: 'source-map',
 *        externals: <externals and non-specified locales>,
 *        entry: webpackEntries,
 *        output: {
 *          libraryTarget: <library target from configureWebpackTask, if specified> or 'amd',
 *          path: this.outputDirectory
 *        },
 *        plugins: []
 *      }
 */
class ConfigureExternalBundlingWebpackTask extends OdspGulpTask_1.default {
    constructor() {
        super('configure-webpack-external-bundling', {
            webpack: undefined,
            localizedResources: undefined,
            bundleAllLocalizedResources: false,
            minifyInProduction: false
        });
    }
    loadSchema() {
        return node_core_library_1.JsonFile.load(path.join(__dirname, 'configure-webpack-external-bundling.schema.json'));
    }
    setConfig(config) {
        if (config.webpack && config.webpack.name !== 'webpack') {
            this.logWarning('Setting webpack property to non-"@microsoft/gulp-core-build-webpack"-type will ' +
                'prevent configuration');
        }
        super.mergeConfig(config);
    }
    executeTask(gulp, completeCallback) {
        if (!this.taskConfig.webpack) {
            this.logWarning('"webpack" is not defined in the task configuration. Nothing to configure.');
            completeCallback();
            return;
        }
        if (!this.taskConfig.configureWebpackTask) {
            this.logError('"configureWebpackTask" is not defined in the task configuration.');
            this._setWebpackConfig(undefined);
            completeCallback();
            return;
        }
        if (!this._shouldBeEnabled) {
            this.logVerbose('No localized resources specified, nothing to do.');
            this._setWebpackConfig(undefined);
            completeCallback();
            return;
        }
        if (!this.properties.webpackStats) {
            this.logError('Missing webpack stats object. Unable to configure.');
            this._setWebpackConfig(undefined);
            completeCallback();
            return;
        }
        const resourcesToBundle = this._pruneLocalizedResources();
        if (resourcesToBundle.length === 0) {
            this.logVerbose('None of the specified localized resources were present in the webpack stats object. Nothing ' +
                'to do.');
            this._setWebpackConfig(undefined);
            completeCallback();
            return;
        }
        // When we run webpack again, it'll overwrite this.properties.webpackStats, and we want to remember the
        //  webpack stats object from the first webpack run.
        this.properties.initialWebpackStats = this.properties.webpackStats;
        let resolveResult;
        try {
            resolveResult = this.resolveResources(resourcesToBundle, this.taskConfig.buildSingleLocale);
        }
        catch (error) {
            completeCallback(error);
            return;
        }
        const locales = resolveResult.locales;
        const localizedResourcesToBundle = resolveResult.localizedResourcesToBundle;
        const externalsKeys = ExternalsProcessor_1.getExternalsKeys(this);
        const localizedResources = this.properties.localizedResources || {};
        const localizedResourcesKeys = Object.keys(localizedResources).filter((key) => {
            return localizedResourcesToBundle.indexOf(key) === -1;
        });
        if (!this.properties.bundledExternals) {
            this.properties.bundledExternals = [];
        }
        this.properties.bundledExternals.push(...localizedResourcesToBundle);
        const webpackEntries = this._generateWebpackEntries(locales);
        const config = {
            module: {
                rules: [
                    {
                        use: require.resolve('source-map-loader'),
                        enforce: 'pre',
                        test: /\.js$/,
                        exclude: [
                            /node_modules/
                        ]
                    }
                ].concat(this.taskConfig.additionalLoaders || []),
                noParse: [/\.map$/]
            },
            resolve: {
                alias: {},
                modules: [
                    'node_modules',
                    'lib'
                ]
            },
            context: this.outputDirectory,
            devtool: this.buildConfig.production ? undefined : 'source-map',
            mode: this.buildConfig.production ? 'production' : 'development',
            externals: externalsKeys.concat(localizedResourcesKeys),
            entry: webpackEntries,
            output: {
                library: this.properties.webpackLibraryName,
                libraryTarget: 'amd',
                path: this.outputDirectory,
                devtoolModuleFilenameTemplate: 'webpack:///../[resource-path]',
                devtoolFallbackModuleFilenameTemplate: 'webpack:///../[resource-path]?[hash]'
            }
        };
        this.taskConfig.configureWebpackTask.tinkerWithLocConfig(config);
        const configs = [];
        for (const locale of locales) {
            const localeWebpackConfig = lodash.cloneDeep(config);
            for (const resourceName of localizedResourcesToBundle) {
                const resourcePath = this.properties.discoveredLocalizedResources[resourceName][locale];
                localeWebpackConfig.resolve.alias[resourceName] = resourcePath;
            }
            localeWebpackConfig.output.filename = `[name]_${locale}.js`;
            localeWebpackConfig.output.chunkFilename = `chunk.[name]_${locale}_[contenthash].js`;
            configs.push(localeWebpackConfig);
        }
        this._setWebpackConfig(configs);
        completeCallback();
    }
    /**
     * Modify the base webpack config to make sure we get what we need after that webpack instance runs.
     *
     * @internal
     */
    tinkerWithBaseWebpackConfig(config) {
        if (this._shouldBeEnabled) {
            config.output.libraryTarget = 'amd';
        }
    }
    _generateWebpackEntries(locales) {
        const entries = this.properties.bundleEntries || [];
        const webpackEntries = {};
        entries.forEach((entry) => {
            const entryName = path.basename(entry.nonLocalizedEntrypointPath, '.js');
            webpackEntries[entryName] = path.join(this.outputDirectory, `${entryName}.js`);
            entry.nonLocalizedEntrypointPath = undefined;
            entry.localizedEntrypointPaths = {};
            locales.forEach((locale) => {
                entry.localizedEntrypointPaths[locale] = path.join(this.outputDirectory, `${entryName}_${locale}.js`);
            });
        });
        return webpackEntries;
    }
    _pruneLocalizedResources() {
        const { modules } = this.properties.webpackStats.toJson({ modules: true });
        const filteredResources = [];
        for (const module of modules) {
            const matches = module.name.match(CopyAssetsTask_1.externalsRegex);
            if (matches) {
                const externalName = matches[1];
                if ((this.taskConfig.bundleAllLocalizedResources &&
                    this.properties.discoveredLocalizedResources[externalName]) ||
                    (this.taskConfig.localizedResources && this.taskConfig.localizedResources.indexOf(externalName) !== -1)) {
                    filteredResources.push(externalName);
                }
            }
        }
        return filteredResources;
    }
    get _shouldBeEnabled() {
        return this.taskConfig.configureWebpackTask &&
            (this.taskConfig.bundleAllLocalizedResources &&
                this.taskConfig.configureWebpackTask.properties.discoveredLocalizedResources &&
                Object.keys(this.taskConfig.configureWebpackTask.properties.discoveredLocalizedResources).length !== 0) ||
            (this.taskConfig.localizedResources &&
                this.taskConfig.localizedResources.length !== 0);
    }
    _setWebpackConfig(config) {
        const webpackTask = this.taskConfig.webpack;
        if (webpackTask) {
            if (!config) {
                // We're just going to disable the second webpack task
                webpackTask.isEnabled = () => false;
            }
            else {
                webpackTask.setConfig({
                    config: config,
                    configPath: null // tslint:disable-line:no-null-keyword
                });
            }
        }
    }
}
exports.ConfigureExternalBundlingWebpackTask = ConfigureExternalBundlingWebpackTask;
//# sourceMappingURL=ConfigureExternalBundlingWebpackTask.js.map