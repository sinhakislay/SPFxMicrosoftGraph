"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const merge = require("merge2");
const gulpReplace = require("gulp-replace");
const lodash_1 = require("lodash");
const fsx = require("fs-extra");
const node_core_library_1 = require("@microsoft/node-core-library");
const OdspGulpTask_1 = require("./../OdspGulpTask");
const ConfigureWebpackTask_1 = require("./../configureWebpack/ConfigureWebpackTask");
const constants_1 = require("../constants");
const url_1 = require("../utilities/url");
const FileUtils_1 = require("./../utilities/FileUtils");
// If we change the type of bundle we're producing, we need to update this
const escapedStringsName = lodash_1.escapeRegExp(constants_1.default.stringsExternalBundleName);
const defaultStringsModuleRegex = new RegExp(`^(define\\(.*\\[.*(\\"|\\'))(?:${escapedStringsName})((?:\\2).*\])`);
exports.externalsRegex = /external \"(.+)\"$/;
/**
 * Prepares deployment to CDNs and the manifest server.
 *
 * Example:
 *  IN:
 *   webpack stats
 *   deployCdnPath - a path where files should be placed for upload to CDNs and the manifest server
 *
 *  OUT:
 *   all assets for the package copied to {deployCdnPath}
 *   all externals for the package copied to {deployCdnPath}
 *   data required to produce manifests in the properties object
 */
class CopyAssetsTask extends OdspGulpTask_1.default {
    constructor() {
        super('copy-assets', {
            deployCdnPath: undefined,
            extsToIgnore: ['.map', '.stats.json', '.stats.html'],
            excludeHashFromFileNames: false,
            localeInDirectoryName: false
        });
    }
    loadSchema() {
        return node_core_library_1.JsonFile.load(path.join(__dirname, 'copy-assets.schema.json'));
    }
    executeTask(gulp, completeCallback) {
        let shouldPrepareProductionDeployment = this.buildConfig.production;
        if (!this.taskConfig.deployCdnPath && this.buildConfig.production) {
            shouldPrepareProductionDeployment = false;
            // Suppressed warning for now to unblock CI. VSO#219493
            this.log /*Warning*/('No deploy CDN path specified. Unable to prepare production deployment.');
        }
        const webpackStats = this.properties.initialWebpackStats || this.properties.webpackStats;
        if (!webpackStats) {
            if (this.properties.bundles && Object.keys(this.properties.bundles).length > 0) {
                // Only warn if webpack should have done something
                this.logWarning('Missing webpack stats object. Nothing to prepare for deployment.');
            }
            completeCallback();
            return;
        }
        const bundleEntries = this.properties.bundleEntries;
        if (!bundleEntries || !bundleEntries.length || bundleEntries.length === 0) {
            this.logWarning('Missing config entries list. Nothing to prepare for deployment.');
            completeCallback();
            return;
        }
        const tasks = [];
        const webpackEntryChunks = new Map();
        const externalModules = [];
        const webpackStatsJson = webpackStats.toJson();
        const { assets: webpackAssets, chunks: webpackChunks, modules: webpackModules } = webpackStatsJson;
        webpackChunks.forEach((webpackChunk) => {
            if (webpackChunk.entry) {
                webpackChunk.names.forEach((name) => {
                    webpackEntryChunks.set(name, webpackChunk);
                });
            }
        });
        const configExternals = this.properties.externals || {};
        webpackModules.forEach((webpackModule) => {
            const matches = webpackModule.name.match(exports.externalsRegex);
            if (matches) {
                const externalName = matches[1];
                const configExternal = configExternals[externalName];
                const linkedExternal = (this.properties.linkedExternals || {})[externalName];
                let configExternalPath;
                if (configExternal) {
                    if (linkedExternal) {
                        this.logError(`External "${externalName}" is specified both as a linked package in the node_modules ` +
                            'dependency tree and as an external in in the config.json file. Remove one of the external ' +
                            'references. Only one external reference type is allowed per external package.');
                        return;
                    }
                    else {
                        if (typeof configExternal === 'string') {
                            // it is an AMD external
                            configExternalPath = configExternal;
                        }
                        else {
                            // it is a non-AMD external
                            configExternalPath = configExternal.path;
                            if (!configExternal.globalName) {
                                this.logError(`External "${externalName}" is defined as a Non-AMD script,` +
                                    `but is missing a globalName property.`);
                                return;
                            }
                            webpackModule.nonAmdConfig = configExternal;
                            (configExternal.globalDependencies || []).forEach((nonAMDDependency) => {
                                const dependencyConfig = configExternals[nonAMDDependency];
                                if (!dependencyConfig) {
                                    this.logError(`External "${externalName}" is referencing dependency "${nonAMDDependency}" which is ` +
                                        'not defined.');
                                    return;
                                }
                                else if (!dependencyConfig.globalName) {
                                    this.logError(`External "${externalName}" is referencing dependency "${nonAMDDependency}", ` +
                                        'which is not defined as a global, non-AMD external.');
                                    return;
                                }
                                else if (this.properties.bundledExternals &&
                                    this.properties.bundledExternals.indexOf(nonAMDDependency) !== -1) {
                                    this.logError(`External "${externalName}" is referencing dependency "${nonAMDDependency}", which ` +
                                        'has been bundled.');
                                    return;
                                }
                            });
                        }
                    }
                }
                if (configExternalPath) {
                    // Keep the whole path if it is a full URL
                    webpackModule.isExternalUrl = url_1.isUrl(configExternalPath);
                    const configExternalFullPath = webpackModule.isExternalUrl
                        ? configExternalPath
                        : path.join(this.buildConfig.rootPath, configExternalPath);
                    if (!webpackModule.isExternalUrl && !fsx.existsSync(configExternalFullPath)) {
                        this.logError(`Specified path "${configExternalFullPath}" for external "${externalName}" does not exist.`);
                    }
                    webpackModule.configExternalFullPath = configExternalFullPath;
                }
                else if (!this.properties.discoveredLocalizedResources[externalName] &&
                    !linkedExternal) {
                    // Make sure if we haven't found other references to this external, it's been discovered as a localized
                    // external
                    this.logError(`External "${externalName}" is not correctly referenced in config.json. Deployed ` +
                        'modules will produce unexpected behavior.');
                }
                if (!this.properties.bundledExternals || this.properties.bundledExternals.indexOf(externalName) === -1) {
                    // Only record the external it if hasn't been bundled by a second webpack run
                    webpackModule.externalName = externalName; // Add the external name as a new property
                    webpackModule.renameCallbacks = []; // Create a list of callbacks here
                    externalModules.push(webpackModule);
                }
            }
        });
        // Copy non-entry assets to the CDN deploy directory
        if (shouldPrepareProductionDeployment) {
            const assetsToCopy = [];
            for (const webpackAsset of webpackAssets) {
                const notIgnoredExt = !this.taskConfig.extsToIgnore ||
                    this.taskConfig.extsToIgnore.reduce((state, ext) => state && webpackAsset.name.slice(-ext.length) !== ext, true);
                const notEntryChunk = webpackAsset.chunks.reduce((state, chunkId) => state && !webpackChunks[chunkId].entry, true);
                if (notIgnoredExt && notEntryChunk) {
                    // If we make it here, we aren't ignoring this chunk's extension and it isn't an entrypoint asset
                    // so we should copy it to the CDN deploy directory
                    if (!this.taskConfig.excludeHashFromFileNames) {
                        // Try to ensure the file has a checksum in the filename
                        let checksumFound = false;
                        // Split the filename by "-", "_", and ".", and test each part to see if it looks like a
                        //  5+ character hex digest
                        const name = webpackAsset.name;
                        const filenameParts = path.basename(name, path.extname(name)).split(/[-_.]/);
                        checksumFound = filenameParts.reduce((state, filenamePart) => state || !!filenamePart.match(/[a-fA-F0-9]{5,}/), false);
                        if (!checksumFound) {
                            this.logError(`Webpack-produced asset "${webpackAsset.name}" does not appear to have a checksum ` +
                                'in its filename, meaning that it is not safe to deploy to the CDN.');
                        }
                    }
                    const assetPath = path.join(this.outputDirectory, webpackAsset.name);
                    assetsToCopy.push(assetPath);
                    if (webpackAsset.name.toLowerCase() !== webpackAsset.name) {
                        this.logWarning(`Asset "${webpackAsset.name}"'s name is not all lowercase and will likely not be ` +
                            'accessible after being copied to the CDN. Ensure that its name is all lowercase, ' +
                            'and consider using the "@microsoft/loader-cased-file" loader.');
                    }
                }
            }
            // Copy the assets we've queued
            tasks.push(gulp.src(assetsToCopy).pipe(gulp.dest(this.taskConfig.deployCdnPath)));
        }
        const deployEntries = [];
        const stringsCopyCallbackMap = new Map();
        bundleEntries.forEach((bundleEntry) => {
            const deployEntry = {
                bundleEntry: bundleEntry,
                entryName: bundleEntry.bundleName
            };
            deployEntries.push(deployEntry);
            deployEntry.debugModules = {
                localizedPathModules: new Map(),
                pathModules: new Map(),
                componentModules: new Map()
            };
            deployEntry.productionModules = {
                localizedPathModules: new Map(),
                pathModules: new Map(),
                componentModules: new Map()
            };
            const manifestIds = [];
            Object.keys(bundleEntry.components).forEach((id) => {
                const manifest = bundleEntry.components[id].manifestData;
                if (manifest) {
                    manifestIds.push(manifest.id);
                }
            });
            if (manifestIds.length === 0) {
                this.logWarning(`Missing manifest for entry "${bundleEntry.components[0].entrypoint}". ` +
                    'Unable to prepare deployment for this entry.');
                return;
            }
            const stringsBaseName = manifestIds.length === 1 ? manifestIds[0] : FileUtils_1.getFullHash(manifestIds.join(''));
            const stringsModuleId = `${stringsBaseName}_strings`;
            this._processEntry(gulp, deployEntry, shouldPrepareProductionDeployment, stringsModuleId, tasks);
            const entryWebpackChunk = webpackEntryChunks.get(bundleEntry.bundleName);
            const webpackChunkId = entryWebpackChunk.id;
            this._processExternalsForEntry(webpackChunkId, deployEntry, externalModules, stringsModuleId, shouldPrepareProductionDeployment, stringsCopyCallbackMap);
        });
        this._copyStrings(gulp, stringsCopyCallbackMap, tasks);
        this._processExternals(gulp, externalModules, tasks);
        // Save the deploy entries so they can be picked up by the WriteManifests task.
        this.properties.deployEntries = deployEntries;
        return merge(tasks).on('finish', () => completeCallback());
    }
    _copyStrings(gulp, stringsCopyCallbackMap, tasks) {
        const moduleBaseName = path.basename(this.buildConfig.rootPath).toLowerCase();
        stringsCopyCallbackMap.forEach((callbacks, key) => {
            const isStandardStringsModule = key === constants_1.default.stringsExternalBundleName;
            const baseFilename = isStandardStringsModule
                ? moduleBaseName
                : `${moduleBaseName}-${key.toLowerCase().replace(/\//g, '_')}`;
            const localizedFiles = this.properties.discoveredLocalizedResources[key];
            for (const locale in localizedFiles) {
                if (localizedFiles.hasOwnProperty(locale)) {
                    const filenameCallback = (filename) => callbacks.forEach((callback) => callback(locale, filename));
                    const gulpStream = this.taskConfig.excludeHashFromFileNames ?
                        FileUtils_1.rename(gulp.src(localizedFiles[locale]), (hash) => `${baseFilename}_${locale}.js`, filenameCallback) :
                        FileUtils_1.renameWithHash(gulp.src(localizedFiles[locale]), (hash) => `${baseFilename}_${locale}_${hash}.js`, filenameCallback);
                    tasks.push(gulpStream.pipe(gulp.dest(this.taskConfig.deployCdnPath)));
                }
            }
        });
    }
    _processEntry(gulp, deployEntry, shouldPrepareProductionDeployment, stringsModuleId, tasks) {
        const bundleEntry = deployEntry.bundleEntry;
        if (bundleEntry.nonLocalizedEntrypointPath && bundleEntry.localizedEntrypointPaths) {
            this.logError('Both localized and non-localized entrypoint files are specified for ' +
                `entry ${deployEntry.bundleEntry}. Only one may be specified.`);
            return false;
        }
        const entryName = deployEntry.entryName;
        let entrypointFilesGlob;
        let productionRenameCallback;
        let getFilenameWithHashCallback;
        let getFilenameCallback;
        if (bundleEntry.nonLocalizedEntrypointPath) {
            const entryBundlePath = bundleEntry.nonLocalizedEntrypointPath;
            entrypointFilesGlob = [entryBundlePath];
            // Record the debug entry module
            const debugModules = deployEntry.debugModules;
            const debugEntryModule = {
                type: 'path',
                path: entryBundlePath
            };
            debugModules.pathModules.set(entryName, debugEntryModule);
            debugModules.entryModuleId = entryName;
            if (shouldPrepareProductionDeployment) {
                // Record the production entry module
                const productionModules = deployEntry.productionModules;
                const productionEntryModule = {
                    type: 'path',
                    path: undefined
                };
                productionModules.pathModules.set(entryName, productionEntryModule);
                productionModules.entryModuleId = entryName;
                productionRenameCallback = (filename) => productionEntryModule.path = filename;
                getFilenameWithHashCallback = (hash) => `${entryName.toLowerCase()}_${hash}.js`;
                getFilenameCallback = () => `${entryName.toLowerCase()}.js`;
            }
        }
        else if (bundleEntry.localizedEntrypointPaths) {
            const reverseEntrypointLookup = {};
            entrypointFilesGlob = [];
            for (const locale in bundleEntry.localizedEntrypointPaths) {
                if (bundleEntry.localizedEntrypointPaths.hasOwnProperty(locale)) {
                    const entrypointPath = bundleEntry.localizedEntrypointPaths[locale];
                    reverseEntrypointLookup[entrypointPath] = locale;
                    entrypointFilesGlob.push(entrypointPath);
                }
            }
            const defaultLocale = this._selectDefaultLocaleForResource(bundleEntry.localizedEntrypointPaths, entryName);
            // Record the debug entry module
            const debugModules = deployEntry.debugModules;
            const debugEntryModule = {
                type: 'localizedPath',
                paths: {},
                defaultPath: undefined
            };
            debugModules.localizedPathModules.set(entryName, debugEntryModule);
            debugModules.entryModuleId = entryName;
            this._fillLocalizedPaths(bundleEntry.localizedEntrypointPaths, defaultLocale, debugEntryModule);
            if (shouldPrepareProductionDeployment) {
                // Record the production entry module
                const productionModules = deployEntry.productionModules;
                const productionEntryModule = {
                    type: 'localizedPath',
                    paths: {},
                    defaultPath: undefined
                };
                productionModules.localizedPathModules.set(entryName, productionEntryModule);
                productionModules.entryModuleId = entryName;
                productionRenameCallback = (filename, originalFilename) => {
                    const locale = reverseEntrypointLookup[originalFilename];
                    this._fillLocalizedPath(filename, locale, defaultLocale, productionEntryModule);
                };
                getFilenameWithHashCallback = (hash, originalFilename) => {
                    const locale = reverseEntrypointLookup[originalFilename];
                    if (this.taskConfig.localeInDirectoryName) {
                        let filePath = path.posix.join(locale, `${entryName.toLowerCase()}_${hash}.js`);
                        if (this.buildConfig.args['on-prem'] && locale !== 'default') {
                            filePath = path.posix.join('localization', filePath);
                        }
                        return filePath;
                    }
                    else {
                        return `${entryName.toLowerCase()}_${locale}_${hash}.js`;
                    }
                };
                getFilenameCallback = (originalFilename) => {
                    const locale = reverseEntrypointLookup[originalFilename];
                    if (this.taskConfig.localeInDirectoryName) {
                        let filePath = path.posix.join(locale, `${entryName.toLowerCase()}.js`);
                        // the default locale should't be put into a localized MSI package,
                        // so it shouldn't go in the localization folder
                        if (this.buildConfig.args['on-prem'] && locale !== 'default') {
                            filePath = path.posix.join('localization', filePath);
                        }
                        return filePath;
                    }
                    else {
                        return `${entryName.toLowerCase()}_${locale}.js`;
                    }
                };
            }
        }
        else {
            this.logError('Neither a localized entrypoint file nor non-localized entrypoint files are specified for ' +
                `entry ${deployEntry.bundleEntry}. One must be specified.`);
            return false;
        }
        // Initialize the entry gulp stream and make a few initial transformations
        let entryGulpStream = gulp.src(entrypointFilesGlob)
            .pipe(gulpReplace(defaultStringsModuleRegex, `$1${stringsModuleId}$3`));
        entryGulpStream = this._transformBundleHeader(entryGulpStream, bundleEntry);
        // Write entry file(s) back to 'dist'
        entryGulpStream = entryGulpStream.pipe(gulp.dest(this.outputDirectory));
        if (shouldPrepareProductionDeployment) {
            // conditionally rename files with hashes
            entryGulpStream = this.taskConfig.excludeHashFromFileNames ?
                FileUtils_1.rename(entryGulpStream, getFilenameCallback, productionRenameCallback) :
                FileUtils_1.renameWithHash(entryGulpStream, getFilenameWithHashCallback, productionRenameCallback);
            // Write production file(s) to the CDN deploy path
            entryGulpStream = entryGulpStream.pipe(gulp.dest(this.taskConfig.deployCdnPath));
        }
        tasks.push(entryGulpStream);
    }
    _transformBundleHeader(entryGulpStream, bundleEntry) {
        const escapedName = lodash_1.escapeRegExp(this.properties.webpackLibraryName);
        if (Object.keys(bundleEntry.components).length > 1) {
            // If there are multiple components, clear out the name to make sure the bundle can be correctly loaded.
            const bundleTemporaryNameRegex = new RegExp(`^(define\\()(\\"|\\')${escapedName}\\2,\\s*`);
            return entryGulpStream.pipe(gulpReplace(bundleTemporaryNameRegex, '$1'));
        }
        else if (this.properties.webpackLibraryNameIsTemporary) {
            // If webpackLibraryNameIsTemporary is true, we need to create a regex to find it and replace it in the
            //  "define(<name>, ..." statement
            // If we change the type of bundle we're producing, we need to update this
            const bundleTemporaryNameRegex = new RegExp(`^(define\\((\\"|\\'))(?:${escapedName})((?:\\2)\,)`);
            const correctName = ConfigureWebpackTask_1.getBundleId(bundleEntry);
            return entryGulpStream.pipe(gulpReplace(bundleTemporaryNameRegex, `$1${correctName}$3`));
        }
        else {
            return entryGulpStream;
        }
    }
    _processExternals(gulp, externalModules, tasks) {
        externalModules.forEach((externalModule) => {
            if (externalModule.renameCallbacks.length > 0) {
                // Replace slashes in the filename with dashes so we don't end up with unexpected subfolders
                const baseFilename = externalModule.externalName.replace(/[\/\\]/, '-');
                const fileCallback = (filename) => externalModule.renameCallbacks.forEach((renameCallback) => renameCallback(filename));
                const gulpStream = this.taskConfig.excludeHashFromFileNames ?
                    FileUtils_1.rename(gulp.src(externalModule.configExternalFullPath), () => `${baseFilename.toLowerCase()}.js`, fileCallback) :
                    FileUtils_1.renameWithHash(gulp.src(externalModule.configExternalFullPath), (hash) => `${baseFilename.toLowerCase()}_${hash}.js`, fileCallback);
                tasks.push(gulpStream.pipe(gulp.dest(this.taskConfig.deployCdnPath)));
            }
        });
    }
    _processExternalsForEntry(webpackChunkId, deployEntry, externalModules, stringsModuleId, shouldPrepareProductionDeployment, stringsCopyCallbackMap) {
        externalModules.forEach((externalModule) => {
            // Determine if this external is referenced by the entry chunk
            if (externalModule.chunks.reduce((state, chunkId) => state || webpackChunkId === chunkId, false)) {
                const externalName = externalModule.externalName;
                const localizedResource = this.properties.discoveredLocalizedResources[externalName];
                if (localizedResource) {
                    // This is a localized resource
                    const isStandardStringsModule = externalName === constants_1.default.stringsExternalBundleName;
                    const resourceName = isStandardStringsModule ? stringsModuleId : externalName;
                    const debugModule = {
                        defaultPath: undefined,
                        type: 'localizedPath',
                        paths: {}
                    };
                    deployEntry.debugModules.localizedPathModules.set(resourceName, debugModule);
                    const defaultLocale = this._selectDefaultLocaleForResource(localizedResource, resourceName);
                    this._fillLocalizedPaths(localizedResource, defaultLocale, debugModule);
                    if (shouldPrepareProductionDeployment) {
                        const productionModule = {
                            defaultPath: undefined,
                            type: 'localizedPath',
                            paths: {}
                        };
                        deployEntry.productionModules.localizedPathModules.set(resourceName, productionModule);
                        if (!stringsCopyCallbackMap.has(externalName)) {
                            stringsCopyCallbackMap.set(externalName, []);
                        }
                        const callbacks = stringsCopyCallbackMap.get(externalName);
                        callbacks.push(((locale, filename) => {
                            this._fillLocalizedPath(filename, locale, defaultLocale, productionModule);
                        }));
                    }
                }
                else if ((this.properties.linkedExternals || {})[externalName]) {
                    // This is a component module, so we need to record that this entry is using it, but we don't need to
                    // copy it to the CDN directory
                    const linkedExternal = this.properties.linkedExternals[externalName];
                    const debugModule = {
                        type: 'component',
                        version: linkedExternal.version,
                        id: linkedExternal.id,
                        failoverPath: linkedExternal.failoverPath
                    };
                    deployEntry.debugModules.componentModules.set(externalName, debugModule);
                    if (shouldPrepareProductionDeployment) {
                        const productionModule = {
                            type: 'component',
                            version: linkedExternal.version,
                            id: linkedExternal.id
                        };
                        deployEntry.productionModules.componentModules.set(externalName, productionModule);
                    }
                    if (this.properties.asyncComponents && this.properties.asyncComponents.indexOf(externalName) !== -1) {
                        // This component should only be loaded async
                        this.logWarning(`Async-only component "${externalName}" required synchronously. This component is ` +
                            'listed as async-only in the config.json file, but it has been referenced in a ' +
                            'synchronous way. Ensure all imports from this component are only used as types.');
                    }
                }
                else if (!externalModule.configExternalFullPath) {
                    this.logError(`External "${externalName}" was specified without a path, and it is neither a ` +
                        'component nor a localized module. The produced manifest will likely not load.');
                    return;
                }
                else {
                    // This is a plain path module, so we do need to copy it to the CDN directory if we're in production
                    // mode and it is not a fully qualified URL
                    deployEntry.debugModules.pathModules.set(externalName, externalModule.nonAmdConfig ?
                        {
                            type: 'path',
                            path: externalModule.configExternalFullPath,
                            globalDependencies: externalModule.nonAmdConfig.globalDependencies,
                            globalName: externalModule.nonAmdConfig.globalName
                        } : {
                        type: 'path',
                        path: externalModule.configExternalFullPath
                    });
                    if (shouldPrepareProductionDeployment) {
                        const productionModule = externalModule.nonAmdConfig ?
                            {
                                type: 'path',
                                path: undefined,
                                globalDependencies: externalModule.nonAmdConfig.globalDependencies,
                                globalName: externalModule.nonAmdConfig.globalName
                            } : {
                            type: 'path',
                            path: undefined
                        };
                        deployEntry.productionModules.pathModules.set(externalName, productionModule);
                        if (externalModule.isExternalUrl) {
                            // There won't be a rename since this is not on the local filesystem
                            productionModule.path = externalModule.configExternalFullPath;
                        }
                        else {
                            externalModule.renameCallbacks.push((filename) => productionModule.path = filename);
                        }
                    }
                }
            }
        });
    }
    _selectDefaultLocaleForResource(paths, externalName) {
        let defaultLocale;
        let defaultLocaleInPaths = false;
        const localeKeys = Object.keys(paths);
        if (localeKeys.length === 1) {
            // We only have one locale, so pick that one as the default
            defaultLocale = localeKeys[0];
        }
        else if ('default' in paths) {
            // We have a "default" default locale, so make "default" the default
            defaultLocale = 'default';
        }
        else if (constants_1.default.defaultLocale in paths) {
            // We have the constants.defaultLocale locale ("en-us"), so pick that one as the default
            defaultLocale = constants_1.default.defaultLocale;
            defaultLocaleInPaths = true; // In this case, the default locale is en-us, but that's also a regular path
        }
        else {
            // We couldn't pick a default locale, so issue a warning
            this.logWarning(`Unable to select a default locale for external resource "${externalName}". ` +
                'Packaging a production build will fail.');
        }
        return { defaultLocale, defaultLocaleInPaths };
    }
    _fillLocalizedPaths(paths, defaultLocale, moduleConfig) {
        for (const locale in paths) {
            if (paths.hasOwnProperty(locale)) {
                const localizedPath = paths[locale];
                this._fillLocalizedPath(localizedPath, locale, defaultLocale, moduleConfig);
            }
        }
    }
    _fillLocalizedPath(localizedPath, locale, defaultLocale, moduleConfig) {
        const isDefaultLocale = locale === defaultLocale.defaultLocale;
        if (isDefaultLocale) {
            moduleConfig.defaultPath = localizedPath;
        }
        if (!isDefaultLocale || defaultLocale.defaultLocaleInPaths) {
            moduleConfig.paths[locale] = localizedPath;
        }
    }
}
exports.CopyAssetsTask = CopyAssetsTask;
//# sourceMappingURL=CopyAssetsTask.js.map