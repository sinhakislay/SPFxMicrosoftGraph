"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const node_core_library_1 = require("@microsoft/node-core-library");
const gulp_core_build_1 = require("@microsoft/gulp-core-build");
const constants_1 = require("./constants");
class OdspGulpTask extends gulp_core_build_1.GulpTask {
    get properties() {
        if (!this.buildConfig.properties) {
            this.buildConfig.properties = this.getDefaultProperties();
        }
        return this.buildConfig.properties;
    }
    get outputDirectory() {
        if (!this._outputDirectory) {
            this._outputDirectory = path.join(this.buildConfig.rootPath, this.buildConfig.distFolder);
        }
        return this._outputDirectory;
    }
    getManifest(manifestPath) {
        if (!this.properties.manifests) {
            this.properties.manifests = {};
        }
        const manifests = this.properties.manifests;
        if (manifests[manifestPath] === undefined) {
            if (!manifestPath) {
                manifests[manifestPath] = null; // tslint:disable-line:no-null-keyword
            }
            else {
                const fullManifestPath = path.join(this.buildConfig.rootPath, manifestPath);
                manifests[manifestPath] = node_core_library_1.JsonFile.load(fullManifestPath);
            }
        }
        return manifests[manifestPath];
    }
    getPackageVersion() {
        const packageJson = require(path.join(this.buildConfig.rootPath, 'package.json'));
        let version = packageJson.version;
        // Remove pre-release name if any, because pre-release is not handled by SPFx yet.
        const indexOfDelimiter = version.indexOf('-');
        if (indexOfDelimiter > 0) {
            version = version.substr(0, indexOfDelimiter);
        }
        return version;
    }
    resolveResources(localizedResources, buildSingleLocale = undefined, parentTask = this // tslint:disable-line:no-any
    ) {
        // Ensure that all localized resources specified exist.
        const localizedResourcesToBundle = [];
        const notFoundResources = [];
        const mismatchResources = [];
        let locales;
        for (const resourceName of localizedResources) {
            const discoveredResources = (this.properties.discoveredLocalizedResources || {})[resourceName];
            if (!discoveredResources || Object.keys(discoveredResources).length === 0) {
                notFoundResources.push(resourceName);
            }
            else {
                const resourcesKeys = Object.keys(discoveredResources);
                const resourceLocales = this._filterLocales(resourcesKeys, buildSingleLocale, parentTask);
                if (!locales) {
                    locales = resourceLocales;
                    localizedResourcesToBundle.push(resourceName);
                    continue;
                }
                let notMatch = resourceLocales.length !== locales.length;
                for (let i = 0; i < resourceLocales.length && !notMatch; i++) {
                    notMatch = notMatch || (locales.indexOf(resourceLocales[i]) === -1);
                }
                if (notMatch) {
                    mismatchResources.push(resourceName);
                }
                else {
                    localizedResourcesToBundle.push(resourceName);
                }
            }
        }
        if (notFoundResources.length > 0) {
            throw `Specified resources not found: ${notFoundResources.join(', ')}.`;
        }
        if (mismatchResources.length > 0) {
            throw 'All resources must have exactly the same locales. Some resources do not match the locales ' +
                `specified by the first (${locales.join(', ')}): ${mismatchResources.join(', ')}`;
        }
        return { locales: locales || [], localizedResourcesToBundle };
    }
    getDefaultProperties() {
        return {};
    }
    _filterLocales(locales, buildSingleLocale, parentTask // tslint:disable-line:no-any
    ) {
        if (buildSingleLocale) {
            if (locales.indexOf(buildSingleLocale) === -1) {
                throw new Error(`Required locale ${buildSingleLocale} is missing.`);
            }
            else {
                return [buildSingleLocale];
            }
        }
        if (!this.buildConfig.production || (this.buildConfig.args || {}).lite) {
            // If this is a non-production build, don't build every locale. Just build the default locale.
            if (locales.indexOf(constants_1.default.defaultLocale) !== -1) {
                return [constants_1.default.defaultLocale];
            }
            else {
                parentTask.logError(`Unable to find a default locale (${constants_1.default.defaultLocale}). All locales will be built. ` +
                    'This may be time-consuming.');
            }
        }
        return locales;
    }
}
exports.default = OdspGulpTask;
//# sourceMappingURL=OdspGulpTask.js.map