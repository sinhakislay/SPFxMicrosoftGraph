"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const rush_lib_1 = require("@microsoft/rush-lib");
const node_core_library_1 = require("@microsoft/node-core-library");
const OdspGulpTask_1 = require("./../OdspGulpTask");
const deployToAzure_1 = require("./../deployAzureStorage/uploadCDN/deployToAzure");
const ensureBlobService_1 = require("./../utilities/azureStorage/ensureBlobService");
const ensureContainer_1 = require("./../utilities//azureStorage/ensureContainer");
const uploadFilesToAzure_1 = require("./../utilities//azureStorage/uploadFilesToAzure");
const url_1 = require("./../utilities/url");
const RetryablePromise_1 = require("./../utilities/RetryablePromise");
const DevDeployLinkPrinter_1 = require("./DevDeployLinkPrinter");
const DevDeploy_1 = require("./DevDeploy");
const GulpTaskTerminalProvider_1 = require("../utilities/GulpTaskTerminalProvider");
const MAX_UPLOAD_RETRIES = 3;
const RETRY_DELAY_MS = 250;
const SOURCE_BRANCH_ENV_VAR_NAME = 'BUILD_SOURCEBRANCH';
class DevDeployTask extends OdspGulpTask_1.default {
    constructor() {
        super('dev-deploy', {
            useRush: false,
            isolateProjects: true,
            batchSize: uploadFilesToAzure_1.DEFAULT_BATCH_SIZE,
            maxRetries: MAX_UPLOAD_RETRIES,
            retryDelayMs: RETRY_DELAY_MS
        });
    }
    executeTask(gulp, completeCallback) {
        if (this.taskConfig.requireContainerDirectoryName &&
            (!this.taskConfig.containerDirectoryName || this.taskConfig.containerDirectoryName.trim() === '')) {
            completeCallback('containerDirectoryName must be set to ensure files aren\'t deployed to the same directory as another user');
        }
        const metadataFilePath = this._getMetadataDropPath();
        // Proactively delete the metadata file so we aren't left with invalid metadata from a previous deploy if
        // this deploy fails
        node_core_library_1.FileSystem.deleteFile(metadataFilePath);
        if (!this.taskConfig.account) {
            completeCallback('Azure storage account not set.');
            return;
        }
        if (!this.taskConfig.accessKey) {
            completeCallback('Azure storage account access key not set.');
            return;
        }
        if (!this.taskConfig.container) {
            completeCallback('Azure container name not set.');
            return;
        }
        if (!this.taskConfig.containerDirectoryName) {
            this.logWarning('It is strongly recommended a directory inside the container be used to avoid clobbering other ' +
                'users\' dev deployments.');
        }
        this.taskConfig.useRush = this.taskConfig.useRush || (process.argv.indexOf('--rush') !== -1);
        const ciMode = process.argv.indexOf('--ciMode') !== -1;
        if (this.buildConfig.args.batchSize && typeof this.buildConfig.args.batchSize === 'number') {
            this.taskConfig.batchSize = this.buildConfig.args.batchSize;
        }
        if (this.buildConfig.args.maxRetries && typeof this.buildConfig.args.maxRetries === 'number') {
            this.taskConfig.maxRetries = this.buildConfig.args.maxRetries;
        }
        if (this.buildConfig.args.retryDelayMs && typeof this.buildConfig.args.retryDelayMs === 'number') {
            this.taskConfig.retryDelayMs = this.buildConfig.args.retryDelayMs;
        }
        if (ciMode) {
            const branchName = process.env[SOURCE_BRANCH_ENV_VAR_NAME];
            const containerDirectoryName = branchName
                ? branchName.replace(/[^A-Za-z0-9\-]+/g, '_')
                : `${this.taskConfig.containerDirectoryName}_tab`;
            this.setConfig({
                containerDirectoryName,
                useRush: true,
                isolateProjects: false
            });
        }
        return ensureBlobService_1.default(this.taskConfig.account, this.taskConfig.accessKey).then((blobService) => {
            return ensureContainer_1.default(blobService, this.taskConfig.container, 
            /* createContainerOptions */ undefined, this.log.bind(this));
        }).then((blobService) => {
            const terminal = new node_core_library_1.Terminal(new GulpTaskTerminalProvider_1.GulpTaskTerminalProvider(this));
            const devDeployProcessor = new DevDeploy_1.DevDeploy({
                useRush: this.taskConfig.useRush,
                isolateProjects: this.taskConfig.isolateProjects,
                rootPath: this.buildConfig.rootPath,
                terminal,
                _additionalDirectoriesToInclude: this.taskConfig._additionalDirectoriesToInclude,
                deployPathsFunction: (filesToUpload) => {
                    const containerSubfolderName = this._getContainerSubfolderName();
                    const rawUploadPromise = uploadFilesToAzure_1.uploadFilesToAzure(blobService, this.taskConfig.container, filesToUpload.map((fileToUpload) => {
                        return {
                            azurePath: url_1.joinUrlSegments(containerSubfolderName, fileToUpload.deployPath),
                            localPath: fileToUpload.localPath
                        };
                    }), this.taskConfig.batchSize, this.log.bind(this));
                    return RetryablePromise_1.default.allWithRetries([new RetryablePromise_1.default(rawUploadPromise)], this.taskConfig.maxRetries, this.taskConfig.retryDelayMs).then(() => { });
                }
            });
            return devDeployProcessor.execute();
        }).then((metadata) => {
            const deployBaseUrl = this.getDeployBaseUrl();
            const debugManifestUrl = url_1.joinUrlSegments(deployBaseUrl, metadata.debugManifestPath);
            const loaderUrl = url_1.joinUrlSegments(deployBaseUrl, metadata.loaderPath);
            this._devDeployMetadata = {
                loaderUrl,
                debugManifestUrl,
                deployUrl: deployBaseUrl
            };
            DevDeployLinkPrinter_1.printDevDeployLink(this.log.bind(this), this._devDeployMetadata);
            this.properties.devDeployManifestFileUrl = debugManifestUrl;
            this.properties.devDeployModuleLoaderUrl = loaderUrl;
            const dropPath = this._getMetadataDropPath();
            node_core_library_1.JsonFile.save(this._devDeployMetadata, dropPath, { ensureFolderExists: true });
            completeCallback();
            return {};
        }).catch((error) => {
            completeCallback(error.message);
            return {};
        });
    }
    getDeployBaseUrl() {
        return url_1.joinUrlSegments(this._getContainerUrl(), this._getContainerSubfolderName());
    }
    getExistingDeployMetadata() {
        if (this._devDeployMetadata) {
            return this._devDeployMetadata;
        }
        else {
            const dropPath = this._getMetadataDropPath();
            if (node_core_library_1.FileSystem.exists(dropPath)) {
                return node_core_library_1.JsonFile.load(dropPath);
            }
            else {
                return undefined;
            }
        }
    }
    _getMetadataDropPath() {
        const METADATA_FILENAME = 'dev-deploy-metadata.json';
        const rushConfig = this._getRushConfig();
        if (rushConfig) {
            const commonTempDirectory = rushConfig.commonTempFolder;
            return path.join(commonTempDirectory, METADATA_FILENAME);
        }
        else {
            return path.join(this.buildConfig.rootPath, this.buildConfig.tempFolder, METADATA_FILENAME);
        }
    }
    _getContainerUrl() {
        return deployToAzure_1.getAzureStorageUrl(this.taskConfig.account, this.taskConfig.container);
    }
    _getContainerSubfolderName() {
        return this.taskConfig.containerDirectoryName || '';
    }
    _getRushConfig() {
        if (!this._rushConfig) {
            this._rushConfig = rush_lib_1.RushConfiguration.loadFromDefaultLocation();
        }
        return this._rushConfig;
    }
}
exports.DevDeployTask = DevDeployTask;
//# sourceMappingURL=DevDeployTask.js.map