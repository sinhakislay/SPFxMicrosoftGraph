"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Url = require("url");
const path = require("path");
const glob = require("glob");
const Webpack = require("webpack");
const lodash = require("lodash");
const rush_lib_1 = require("@microsoft/rush-lib");
const node_core_library_1 = require("@microsoft/node-core-library");
const cumulativeManifestProcessor_1 = require("./../cumulativeManifestProcessor");
const url_1 = require("./../utilities/url");
const WriteManifestsTask_1 = require("../writeManifests/WriteManifestsTask");
const constants_1 = require("../constants");
const MANIFESTS_JS_FILENAME = 'manifests.js';
const SP_LOADER_ASSEMBLY_ID = '44bae1a2-d2eb-4e10-8c21-a1dbdce1036f';
class DevDeploy {
    constructor(options) {
        this._options = Object.assign({ useRush: false, isolateProjects: true, ignoreCollisions: false, _additionalDirectoriesToInclude: [], _projectDiscoveryMode: cumulativeManifestProcessor_1.ForceSearch.deepSparse }, options);
        if (!this._options._additionalDirectoriesToInclude) {
            this._options._additionalDirectoriesToInclude = [];
        }
        if (!this._options.rootPath) {
            throw new Error('rootPath must be provided');
        }
        if (!this._options.terminal) {
            throw new Error('Terminal must be provided.');
        }
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            const cumulativeManifestProcessor = new cumulativeManifestProcessor_1.default({
                explicitInclude: [SP_LOADER_ASSEMBLY_ID],
                rootPath: this._options.rootPath,
                tempFolderName: 'temp',
                distFolderName: 'dist',
                logVerbose: this._options.terminal.writeVerboseLine.bind(this._options.terminal),
                logWarning: this._options.terminal.writeWarningLine.bind(this._options.terminal),
                logError: this._options.terminal.writeErrorLine.bind(this._options.terminal)
            });
            const manifests = this._getManifests(cumulativeManifestProcessor);
            const manifestsArray = [];
            this._options.terminal.writeVerboseLine(`Discovered ${Object.keys(manifests).length} projects.`);
            const filesToUpload = [];
            const foldersToUpload = new Map();
            const projectContainerNames = new Map(); // Ensure we don't reuse a name
            let spLoaderFolderPath;
            let debugSPLoader;
            // Loop through the manifests and collect files and directories to be uploaded, and fix up manifest fields
            for (const id in manifests) {
                if (manifests.hasOwnProperty(id)) {
                    for (const version in manifests[id]) {
                        if (manifests[id].hasOwnProperty(version)) {
                            const referencedProject = manifests[id][version];
                            const manifest = referencedProject.manifestData;
                            const loaderConfig = manifest.loaderConfig;
                            this._options.terminal.writeVerboseLine(`Processing ${id}@${version} (${manifest.alias}) in "${referencedProject.packagePath}"...`);
                            manifestsArray.push(manifest);
                            const projectContainerName = this._options.isolateProjects
                                ? this._getDestinationDirName(projectContainerNames, referencedProject.packagePath)
                                : '.';
                            // A relative base URL applies when the paths are based on the tenant URL.
                            // This applies, for example, in the JSOM library, that takes the JS files from a known place
                            // available on every tenant.
                            const isBaseUrlRelative = loaderConfig.internalModuleBaseUrls.length > 0
                                && !Url.parse(loaderConfig.internalModuleBaseUrls[0]).protocol;
                            // If the Base URL is a relative path, keep the relative path
                            if (!isBaseUrlRelative) {
                                loaderConfig.internalModuleBaseUrls = undefined;
                            }
                            const processPath = (resourcePath) => {
                                // If the base URL was relative, a relative path for a resource doesn't need to be fixed up
                                if (url_1.isUrl(resourcePath) || isBaseUrlRelative) {
                                    return resourcePath; // Do not deal with fully-qualified URL.
                                }
                                else {
                                    this._options.terminal.writeVerboseLine(`    Processing resource path ${resourcePath}`);
                                    const filesystemPath = path.join(referencedProject.packagePath, resourcePath);
                                    const filename = path.basename(resourcePath);
                                    // Path resources are in the 'dist' directory by default and usually have some secondary
                                    // references, so let's just upload the whole directory.
                                    const filesystemFolder = path.dirname(filesystemPath);
                                    this._options.terminal.writeVerboseLine(`    Added ${filesystemFolder} to folders to upload`);
                                    foldersToUpload.set(filesystemFolder, projectContainerName);
                                    if (!spLoaderFolderPath && id === SP_LOADER_ASSEMBLY_ID) {
                                        spLoaderFolderPath = projectContainerName;
                                        debugSPLoader = filename;
                                    }
                                    return url_1.joinUrlSegments(projectContainerName, filename);
                                }
                            };
                            this._doComponentTypeSpecificFixup(manifest, processPath);
                            this._processAllPathsInManifest(manifest, processPath);
                            for (const additionalDirectoryToInclude of this._options._additionalDirectoriesToInclude) {
                                const resolvedFolder = path.join(referencedProject.packagePath, additionalDirectoryToInclude);
                                this._options.terminal.writeVerboseLine(`  Added ${resolvedFolder} to folders to upload`);
                                foldersToUpload.set(resolvedFolder, projectContainerName);
                            }
                            this._options.terminal.writeVerboseLine(`Processing ${id}@${version} (${manifest.alias})...DONE`);
                        }
                    }
                }
            }
            // Expand directories to individual files
            const directoryExpandPromises = [];
            const collisionDetectionMap = new Map();
            for (const [localDirName, deployDirName] of foldersToUpload) {
                directoryExpandPromises.push(this._getFilesInDirectory(localDirName).then((files) => {
                    this._options.terminal.writeVerboseLine(`Found ${files.length} items in ${localDirName}`);
                    for (const file of files) {
                        const deployPath = url_1.joinUrlSegments(deployDirName, file.replace(/\\/g, '/'));
                        const localPath = path.join(localDirName, file);
                        if (node_core_library_1.FileSystem.getStatistics(localPath).isDirectory()) {
                            this._options.terminal.writeVerboseLine(`  Skipping folder ${localPath}`);
                            continue; // Continue on directories
                        }
                        if (!this._options.isolateProjects) {
                            if (collisionDetectionMap.has(deployPath)) {
                                collisionDetectionMap.get(deployPath).push(localPath);
                            }
                            else {
                                collisionDetectionMap.set(deployPath, [localPath]);
                            }
                        }
                        filesToUpload.push({
                            localPath,
                            deployPath
                        });
                    }
                }));
            }
            const webpackConfig = cumulativeManifestProcessor.getManifestsFileWebpackConfig(manifestsArray, MANIFESTS_JS_FILENAME);
            const manifestsFilename = 'devDeployManifests.js';
            const manifestsFileFullPath = path.join(webpackConfig.output.path, manifestsFilename);
            webpackConfig.output.filename = manifestsFilename;
            const debugManifestPath = MANIFESTS_JS_FILENAME;
            yield Promise.all(directoryExpandPromises);
            yield node_core_library_1.LegacyAdapters.convertCallbackToPromise(Webpack, [webpackConfig]);
            filesToUpload.push({
                localPath: manifestsFileFullPath,
                deployPath: debugManifestPath
            });
            yield this._options.deployPathsFunction(filesToUpload);
            this._options.terminal.writeLine('DEPLOYMENT COMPLETE.');
            if (!this._options.ignoreCollisions) {
                // Warn about collisions
                collisionDetectionMap.forEach((localPaths, url) => {
                    if (localPaths.length > 1 && !this._doesFilenameAppearToContainHash(localPaths[0])) {
                        this._options.terminal.writeWarningLine(`COLLISION DETECTED: [${localPaths.join(',')}] all deployed to the same URL (${url}). ` +
                            `It is very probable that the dev-deploy will not work as expected. This may indicate a ` +
                            `serious issue for production environments as well.`);
                    }
                });
            }
            return {
                loaderPath: url_1.joinUrlSegments(spLoaderFolderPath, debugSPLoader),
                debugManifestPath
            };
        });
    }
    _getRushConfig() {
        if (!this._rushConfig) {
            this._rushConfig = rush_lib_1.RushConfiguration.loadFromDefaultLocation();
        }
        return this._rushConfig;
    }
    _processAllPathsInManifest({ loaderConfig }, pathProcessFunction) {
        for (const scriptResourceId in loaderConfig.scriptResources) {
            if (loaderConfig.scriptResources.hasOwnProperty(scriptResourceId)) {
                const scriptResource = loaderConfig.scriptResources[scriptResourceId];
                switch (scriptResource.type) {
                    case 'path': {
                        // Path script resource, we need to fix up its path and upload it
                        const pathResource = scriptResource;
                        pathResource.path = pathProcessFunction(this._disambiguatePath(pathResource.path));
                        break;
                    }
                    case 'component': {
                        // We probably don't need to upload the fallback file, and it's nigh-impossible to tell if we'll
                        // miss secondary dependencies by only uploading the file at the failoverPath, so we'll just clear
                        // it out and hope this dependency is either satisfied by another dev-deploy manifest or by the OOB
                        // framework
                        const componentResource = scriptResource;
                        componentResource.failoverPath = undefined;
                        break;
                    }
                    case 'localizedPath': {
                        // Localized path script resource, we need to fix up the paths for each locale and upload each file
                        const localizedPathResource = scriptResource;
                        // Select en-us if it exists, otherwise pass through the default path.
                        const pathToProcess = (localizedPathResource.paths
                            ? localizedPathResource.paths[constants_1.default.defaultLocale]
                            : localizedPathResource.defaultPath) || localizedPathResource.defaultPath;
                        localizedPathResource.defaultPath = pathProcessFunction(this._disambiguatePath(pathToProcess));
                        if (localizedPathResource.paths) {
                            for (const locale in localizedPathResource.paths) {
                                if (localizedPathResource.paths.hasOwnProperty(locale)) {
                                    localizedPathResource.paths[locale] = pathProcessFunction(this._disambiguatePath(localizedPathResource.paths[locale]));
                                }
                            }
                        }
                        break;
                    }
                }
            }
        }
    }
    _disambiguatePath(pathToDisambiguate) {
        return typeof pathToDisambiguate === 'string'
            ? pathToDisambiguate
            : pathToDisambiguate.default;
    }
    _getFilesInDirectory(dirName) {
        return node_core_library_1.LegacyAdapters.convertCallbackToPromise(glob, path.join('**', '*.*'), { cwd: dirName });
    }
    /**
     * This function returns a directory name to be used in a directory in the destination, ensuring that the name does
     * not collide with another directory's name. It also ensures that if the specified filesystem path has already
     * been mapped to a destination directory, the same name is used in the destination.
     */
    _getDestinationDirName(directoryMap, filesystemPath) {
        let destinationDirName = path.basename(filesystemPath).toLowerCase();
        if (directoryMap.has(destinationDirName)) {
            const existingPaths = directoryMap.get(destinationDirName);
            const currentPathId = existingPaths.indexOf(filesystemPath);
            if (currentPathId === -1) {
                destinationDirName = `${destinationDirName}_${existingPaths.length}`;
                existingPaths.push(filesystemPath);
            }
            else if (currentPathId > 0) {
                destinationDirName = `${destinationDirName}_${currentPathId}`;
            }
        }
        else {
            directoryMap.set(destinationDirName, [filesystemPath]);
        }
        return destinationDirName;
    }
    _getManifests(cumulativeManifestProcessor) {
        if (this._options.useRush) {
            const rushConfig = this._getRushConfig();
            if (!rushConfig) {
                throw 'Unable to find the rush configuration file.';
            }
            let manifests;
            const directories = rushConfig.projects.map((proj) => proj.projectFolder);
            manifests = cumulativeManifestProcessor.discoverManifests(directories[0], this._options._projectDiscoveryMode);
            for (let i = 1; i < directories.length; i++) {
                const projectManifests = cumulativeManifestProcessor.discoverManifests(directories[i], this._options._projectDiscoveryMode);
                manifests = this._mergeReferencedProjectLists(manifests, projectManifests);
            }
            return manifests;
        }
        else {
            return cumulativeManifestProcessor.discoverManifests(this._options.rootPath, this._options._projectDiscoveryMode);
        }
    }
    _mergeReferencedProjectLists(list1, list2) {
        const ids = new Set();
        Object.keys(list1).concat(Object.keys(list2)).forEach((id) => ids.add(id));
        const result = {};
        ids.forEach((id) => {
            const list1Versions = list1[id];
            const list2Versions = list2[id];
            if (!list1Versions || !list2Versions) {
                // Element is only present in one list
                result[id] = list1Versions || list2Versions;
            }
            else {
                // Arrays are present in both lists, merge them together
                const versionMapping = {};
                function addVersionsToMapping(referencedVersions) {
                    for (const version in referencedVersions) {
                        if (!versionMapping[version] ||
                            referencedVersions[version].manifestCreationTime > versionMapping[version].manifestCreationTime) {
                            versionMapping[version] = referencedVersions[version];
                        }
                    }
                }
                addVersionsToMapping(list1Versions);
                addVersionsToMapping(list2Versions);
                result[id] = versionMapping;
            }
        });
        return result;
    }
    _doComponentTypeSpecificFixup(manifest, processPath) {
        switch (manifest.componentType) {
            case 'WebPart':
                // tslint:disable-next-line:no-any
                const webpartManifest = manifest;
                for (const preconfiguredEntry of webpartManifest.preconfiguredEntries) {
                    if (preconfiguredEntry.iconImageUrl) {
                        preconfiguredEntry.iconImageUrl = this._fixupIconPath(preconfiguredEntry.iconImageUrl, processPath);
                    }
                }
                break;
            case 'Extension':
                const extensionManifest = manifest;
                switch (extensionManifest.extensionType) {
                    case 'ListViewCommandSet':
                        const commandSetManifest = extensionManifest;
                        for (const itemId in commandSetManifest.items) {
                            if (commandSetManifest.items.hasOwnProperty(itemId)) {
                                const item = commandSetManifest.items[itemId];
                                if (item.iconImageUrl) {
                                    item.iconImageUrl = this._fixupIconPath(item.iconImageUrl, processPath);
                                }
                            }
                        }
                        break;
                    default:
                        // Nothing to do for the other extension types
                        break;
                }
                break;
            default:
                // Nothing to do for the other component types
                break;
        }
    }
    _fixupIconPath(iconPath, processPath) {
        if (WriteManifestsTask_1.getIconPathType(iconPath) === WriteManifestsTask_1.IconPathType.RelativeUrl) {
            const relativeIconPath = lodash.trimStart(iconPath, '/');
            return processPath(relativeIconPath);
        }
        else {
            return iconPath;
        }
    }
    _doesFilenameAppearToContainHash(filePath) {
        const filename = path.basename(filePath, path.extname(filePath));
        // Look for a hexadecimal string at the end of the filename that is at least 5 characters long and
        // starts with an underscore (_) or a hyphen (-).
        return !!filename.match(/[_-][a-f0-9]{5,}$/i);
    }
}
exports.DevDeploy = DevDeploy;
//# sourceMappingURL=DevDeploy.js.map