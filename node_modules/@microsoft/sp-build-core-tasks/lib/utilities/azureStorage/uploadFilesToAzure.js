"use strict";
/**
 * @file uploadFilesToAzure.ts
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * Uploads a list of files to an Azure Blob Service instance
 */
Object.defineProperty(exports, "__esModule", { value: true });
const RetryablePromise_1 = require("./../RetryablePromise");
exports.DEFAULT_BATCH_SIZE = 50;
function uploadFileToAzure(blobService, containerName, localFilename, serverFilename, log = console.log) {
    serverFilename = serverFilename || localFilename;
    return new RetryablePromise_1.default((resolve, reject) => {
        try {
            blobService.createBlockBlobFromLocalFile(containerName, serverFilename, localFilename, (error, result, response) => {
                if (error) {
                    reject(new Error(`Unable to upload file: ${serverFilename} from ${localFilename}`));
                }
                if (result) {
                    log(`Uploaded file: ${serverFilename}`);
                }
                resolve(blobService);
            });
        }
        catch (error) {
            reject(new Error(error));
        }
    });
}
exports.uploadFileToAzure = uploadFileToAzure;
function uploadFilesToAzure(blobService, containerName, files, batchSize, log = console.log) {
    log(`Uploading [${files.length}] files...`);
    return batchPromise(batchSize, files, log, (file) => {
        return uploadFileToAzure(blobService, containerName, file.localPath, file.azurePath, log);
    }).then(() => blobService);
}
exports.uploadFilesToAzure = uploadFilesToAzure;
/**
 * Helper function to run promises in batches
 * @param batchSize - the number of promises to run at a single time
 * @param items - the list of items that are inputs to the createPromise function
 * @param log - a helper function for performing logging
 * @param createPromise - a function which takes an item and returns a promise to do something
 */
function batchPromise(batchSize, items, log, createPromise) {
    return Promise.resolve(items)
        .then((arr) => {
        let batchNumber = 0;
        return arr
            // create a list of batches and empty arrays
            .map((item, index) => {
            // if this is the start of a batch boundary, take the next batchSize elements
            // otherwise return an empty array that will be filtered in the next step
            return index % batchSize === 0
                ? arr.slice(index, index + batchSize)
                : [];
        })
            // remove any of the empty arrays
            .filter((batch) => {
            return batch.length > 0;
        })
            // turn the array of items into callbacks which create promises
            .map((batch) => {
            return () => {
                return Promise.all(batch.map(createPromise));
            };
        })
            // then create the serial promise chain
            .reduce((chain, work) => {
            return chain
                .then(work)
                .then((data) => {
                log(`Finished batch #${++batchNumber}`);
            });
        }, Promise.resolve(undefined));
    });
}
exports.batchPromise = batchPromise;
//# sourceMappingURL=uploadFilesToAzure.js.map