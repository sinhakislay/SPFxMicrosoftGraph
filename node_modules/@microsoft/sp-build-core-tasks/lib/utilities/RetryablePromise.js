"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class RetryablePromise {
    constructor(_promiseFn) {
        this._promiseFn = _promiseFn;
        if (typeof _promiseFn === 'function') {
            this._innerPromise = new Promise(_promiseFn);
        }
        else {
            this._innerPromise = _promiseFn;
        }
    }
    static setTimeoutMock(setTimeout) {
        RetryablePromise._setTimeout = setTimeout;
    }
    static allWithRetries(promises, maxRetries, retryDelayInMs = 0) {
        return new Promise((resolve, reject) => {
            let successCount = 0;
            const results = [];
            const failureCounts = [];
            function attachPromiseHandler(promise, index) {
                promise.then((value) => {
                    results[index] = value;
                    successCount++;
                    if (successCount === promises.length) {
                        resolve(results);
                    }
                }).catch(() => {
                    if (maxRetries > 0 && (failureCounts[index] === undefined || failureCounts[index] < maxRetries)) {
                        failureCounts[index] = !failureCounts[index] ? 1 : failureCounts[index] + 1;
                        if (!retryDelayInMs) {
                            attachPromiseHandler(promise.retry(), index);
                        }
                        else {
                            RetryablePromise._setTimeout(() => attachPromiseHandler(promise.retry(), index), retryDelayInMs);
                        }
                    }
                    else {
                        reject(new Error(`Maximum retries (${maxRetries}) exceeded.`));
                    }
                });
            }
            for (let i = 0; i < promises.length; i++) {
                attachPromiseHandler(promises[i], i);
            }
        });
    }
    retry() {
        return new RetryablePromise(this._promiseFn);
    }
    then(onFulfilled, onRejected) {
        return this._innerPromise.then(onFulfilled, onRejected);
    }
    catch(onRejected) {
        return this._innerPromise.catch(onRejected);
    }
}
RetryablePromise._setTimeout = setTimeout;
exports.default = RetryablePromise;
//# sourceMappingURL=RetryablePromise.js.map