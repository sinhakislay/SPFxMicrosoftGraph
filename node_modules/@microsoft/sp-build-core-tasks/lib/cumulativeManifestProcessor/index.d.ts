import * as Webpack from 'webpack';
import { IClientSideComponentManifest } from '@microsoft/sp-module-interfaces';
import { GulpTask } from '@microsoft/gulp-core-build';
export declare enum ForceSearch {
    /**
     * Don't force a manifest search anywhere. Use the manifests.json file everywhere if it's found.
     */
    none = 0,
    /**
     * Don't force a manifest search in the first project, but use the manifests.json file in other packages.
     */
    shallow = 1,
    /**
     * Don't use the manifests.json file anywhere, and search every single package.
     */
    deep = 2,
    /**
     * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found.
     */
    deepSparse = 3,
    /**
     * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found,
     * except for the first project. Always recurse from the first project. This option is useful if it's uncertain
     * whether the first project has been built, but otherwise "deepSparse" is intended behavior.
     */
    deepSparseIgnoreFirstProject = 4
}
export interface ICumulativeManifestEnvironmentOptions {
    logVerbose: (message: string) => void;
    logWarning: (message: string) => void;
    logError: (message: string) => void;
    rootPath: string;
    tempFolderName: string;
    distFolderName: string;
}
export interface ICumulativeManifestOptions {
    /**
     * IDs of manifests to exclude from the manifest map file.
     */
    ignoreOutputManifestIds?: string[];
    /**
     * The base path for debug manifests. Expected to match the result of the "debugBasePath" function passed to the
     *  WriteManifestsTask task.
     */
    baseUrl?: string;
    /**
     * Optional array of IDs to ensure aren't filtered out of the results if they are discovered.
     */
    explicitInclude?: string[];
}
export interface IReferencedProject {
    /**
     * The creation time of the newest version of this manifest we've found
     */
    manifestCreationTime: number;
    /**
     * The ID of the manifest.
     */
    id: string;
    /**
     * The version of the manifest.
     */
    version: string;
    /**
     * The project's manifest data
     */
    manifestData: IClientSideComponentManifest;
    /**
     * The root path of the project.
     */
    packagePath: string;
    /**
     * The name of the package, if it can be inferred. The name can only be inferred if it's in a project with only
     *  one manifest.
     */
    packageName: string;
}
export interface IVersionMap<TMember> {
    [version: string]: TMember;
}
export interface IVersionedIdMap<TMember> {
    [id: string]: IVersionMap<TMember>;
}
export declare type IReferencedProjectMap = IVersionedIdMap<IReferencedProject>;
export interface IDiscoverManifestsOptions {
    /**
     * The directory in each project's directory where we should search for manifests. Defaults to "dist"
     */
    projectTargetFolder?: string;
    /**
     * The regex to use to search for manifest files. Defaults to /^[^\.\\\/]+\.manifest\.json$/
     */
    manifestFileRegex?: RegExp;
}
export default class CumulativeManifestProcessor {
    private _options;
    private _discoveryCache;
    static initializeFromGulpTask(parentTask: GulpTask<any>, // tslint:disable-line:no-any
    options?: ICumulativeManifestOptions): CumulativeManifestProcessor;
    constructor(options: ICumulativeManifestOptions & ICumulativeManifestEnvironmentOptions);
    /**
     * Ths function:
     *  1. discovers all packages referenced in package.json
     *  2a. looks for a file in each discovered project's temp folder called manifests.json
     *  2b. looks for <id>.manifest.json files in the dist folder
     *  3. keeps a record of all of the manifests discovered in the referenced projects, and resolves duplicates by
     *      taking the newest file
     *  4. generates new base URLs for each of the referenced projects' manifests to make them valid when "gulp serve"
     *      is run from this current project's directory
     *  5. collects all of these discovered manifests and the debugManifests parameter and generates an array of all
     *      manifests
     *  6. filters this array by the ignoreOutputManifestIds options
     *  7. drops a JSON file in the temp directory called manifests.json containing this array
     *  8. drops an initialization script in the temp directory called manifests.js that
     *      exports two functions. One that returns the array with the manifests' base URLs as fully-qualified, and the
     *      other with manifests' base URLs as relative to the page root.
     */
    generateCumulativeManifest(debugManifests: IClientSideComponentManifest[]): Promise<void>;
    readonly manifestsFilePath: string;
    getManifestsFileWebpackConfig(manifestsArray: IClientSideComponentManifest[], filename: string): Webpack.Configuration;
    reset(): void;
    discoverManifests(packagePath: string, forceSearchMode: ForceSearch, options?: IDiscoverManifestsOptions): IReferencedProjectMap;
    private _insertManifestIntoMap;
    private _getTransformedManifest;
}
//# sourceMappingURL=index.d.ts.map