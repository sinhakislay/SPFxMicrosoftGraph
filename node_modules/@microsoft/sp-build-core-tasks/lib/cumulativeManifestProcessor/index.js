"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Url = require("url");
const path = require("path");
const lodash_1 = require("lodash");
const Webpack = require("webpack");
const set_webpack_public_path_plugin_1 = require("@microsoft/set-webpack-public-path-plugin");
const node_core_library_1 = require("@microsoft/node-core-library");
const Resolve_1 = require("./../utilities/Resolve");
const url_1 = require("./../utilities/url");
const CUMULATIVE_MANIFEST_FILENAME = 'manifests';
var ForceSearch;
(function (ForceSearch) {
    /**
     * Don't force a manifest search anywhere. Use the manifests.json file everywhere if it's found.
     */
    ForceSearch[ForceSearch["none"] = 0] = "none";
    /**
     * Don't force a manifest search in the first project, but use the manifests.json file in other packages.
     */
    ForceSearch[ForceSearch["shallow"] = 1] = "shallow";
    /**
     * Don't use the manifests.json file anywhere, and search every single package.
     */
    ForceSearch[ForceSearch["deep"] = 2] = "deep";
    /**
     * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found.
     */
    ForceSearch[ForceSearch["deepSparse"] = 3] = "deepSparse";
    /**
     * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found,
     * except for the first project. Always recurse from the first project. This option is useful if it's uncertain
     * whether the first project has been built, but otherwise "deepSparse" is intended behavior.
     */
    ForceSearch[ForceSearch["deepSparseIgnoreFirstProject"] = 4] = "deepSparseIgnoreFirstProject";
})(ForceSearch = exports.ForceSearch || (exports.ForceSearch = {}));
class CumulativeManifestProcessor {
    static initializeFromGulpTask(parentTask, // tslint:disable-line:no-any
    options = {}) {
        const fullOptions = Object.assign({ logVerbose: parentTask.logVerbose.bind(parentTask), logWarning: parentTask.logWarning.bind(parentTask), logError: parentTask.logError.bind(parentTask), rootPath: parentTask.buildConfig.rootPath, tempFolderName: parentTask.buildConfig.tempFolder, distFolderName: parentTask.buildConfig.distFolder }, options);
        return new CumulativeManifestProcessor(fullOptions);
    }
    constructor(options) {
        this._options = options;
        this._discoveryCache = new Map();
    }
    /**
     * Ths function:
     *  1. discovers all packages referenced in package.json
     *  2a. looks for a file in each discovered project's temp folder called manifests.json
     *  2b. looks for <id>.manifest.json files in the dist folder
     *  3. keeps a record of all of the manifests discovered in the referenced projects, and resolves duplicates by
     *      taking the newest file
     *  4. generates new base URLs for each of the referenced projects' manifests to make them valid when "gulp serve"
     *      is run from this current project's directory
     *  5. collects all of these discovered manifests and the debugManifests parameter and generates an array of all
     *      manifests
     *  6. filters this array by the ignoreOutputManifestIds options
     *  7. drops a JSON file in the temp directory called manifests.json containing this array
     *  8. drops an initialization script in the temp directory called manifests.js that
     *      exports two functions. One that returns the array with the manifests' base URLs as fully-qualified, and the
     *      other with manifests' base URLs as relative to the page root.
     */
    generateCumulativeManifest(debugManifests) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._options) {
                this._options.logVerbose('No cumulative manifest options specified. Skipping cumulative manifest generation.');
                return;
            }
            const referencedProjectManifests = this.discoverManifests(this._options.rootPath, ForceSearch.shallow);
            const baseUrl = this._options.baseUrl || 'https://localhost:4321'; // Default if one isn't already defined
            const manifests = {};
            for (const id in referencedProjectManifests) {
                if (referencedProjectManifests.hasOwnProperty(id)) {
                    manifests[id] = {};
                    for (const version in referencedProjectManifests[id]) {
                        if (referencedProjectManifests[id].hasOwnProperty(version)) {
                            manifests[id][version] = this._getTransformedManifest(referencedProjectManifests[id][version], baseUrl);
                        }
                    }
                }
            }
            for (const manifest of debugManifests) {
                const id = manifest.id;
                if (!manifests[id]) {
                    manifests[id] = {};
                }
                manifests[id][manifest.version] = manifest;
            }
            const manifestsArray = [];
            for (const id in manifests) {
                if (manifests.hasOwnProperty(id) &&
                    (!this._options.ignoreOutputManifestIds || this._options.ignoreOutputManifestIds.indexOf(id) === -1)) {
                    for (const version in manifests[id]) {
                        if (manifests[id].hasOwnProperty(version)) {
                            manifestsArray.push(manifests[id][version]);
                        }
                    }
                }
            }
            // Write the manifests.json file
            node_core_library_1.FileSystem.writeFile(path.resolve(this._options.tempFolderName, `${CUMULATIVE_MANIFEST_FILENAME}.json`), JSON.stringify(manifestsArray), { ensureFolderExists: true });
            // Write the manifests.js file
            const webpackConfig = this.getManifestsFileWebpackConfig(manifestsArray, 'manifests.js');
            try {
                const stats = yield node_core_library_1.LegacyAdapters.convertCallbackToPromise(Webpack, webpackConfig // The typings are wrong here. We should fix this
                );
                if (stats.hasErrors() || stats.hasWarnings()) {
                    const statsJson = stats.toJson();
                    const warnings = statsJson.warnings.join('\n');
                    const errors = statsJson.warnings.join('\n');
                    const exceptionMessageParts = [];
                    if (errors !== '') {
                        exceptionMessageParts.push(`errors: ${errors}`);
                    }
                    if (warnings !== '') {
                        exceptionMessageParts.push(`warnings: ${warnings}`);
                    }
                    throw new Error(exceptionMessageParts.join('\n'));
                }
            }
            catch (error) {
                this._options.logError(`Error generating cumulative manifest: ${error}`);
                throw error;
            }
        });
    }
    get manifestsFilePath() {
        return path.join(__dirname, 'manifestsFile', 'manifestsFile.js');
    }
    getManifestsFileWebpackConfig(manifestsArray, filename) {
        return {
            mode: 'production',
            entry: this.manifestsFilePath,
            output: {
                library: 'debugManifests',
                libraryTarget: 'umd',
                path: path.join(this._options.rootPath, this._options.tempFolderName),
                filename: `${CUMULATIVE_MANIFEST_FILENAME}.js`
            },
            optimization: {
                minimize: false
            },
            resolve: {
                descriptionFiles: []
            },
            plugins: [
                new Webpack.DefinePlugin({
                    MANIFESTS_ARRAY_PROXY: JSON.stringify(manifestsArray, undefined, 2),
                    MANIFESTS_FILE_NAME: JSON.stringify(filename)
                }),
                new set_webpack_public_path_plugin_1.SetPublicPathPlugin({
                    skipDetection: true,
                    scriptName: {
                        name: lodash_1.escapeRegExp(filename),
                        isTokenized: false
                    }
                })
            ],
            performance: {
                hints: false
            }
        };
    }
    reset() {
        this._discoveryCache.clear();
    }
    discoverManifests(packagePath, forceSearchMode, options = {}) {
        const optionsToUse = lodash_1.cloneDeep(options);
        if (!optionsToUse.projectTargetFolder) {
            optionsToUse.projectTargetFolder = this._options.distFolderName || 'dist';
        }
        if (!optionsToUse.manifestFileRegex) {
            optionsToUse.manifestFileRegex = options.manifestFileRegex || /^[^\.\\\/]+\.manifest\.json$/;
        }
        const resolvedPackagePath = node_core_library_1.FileSystem.getRealPath(packagePath);
        if (this._discoveryCache.has(resolvedPackagePath)) {
            return this._discoveryCache.get(resolvedPackagePath);
        }
        const referencedProjectManifests = {};
        const tempPath = path.join(packagePath, this._options.tempFolderName || 'temp');
        const targetFolderPath = path.join(packagePath, optionsToUse.projectTargetFolder);
        const packageJsonPath = path.join(packagePath, 'package.json');
        // We want to make sure if we have multiple files with the same component's manifest, we pick the one that
        //  was generated most recently.
        let fileModifiedTime = 0;
        let linkedProjectManifests = undefined;
        let foundCumulativeManifestsFile = false;
        if (forceSearchMode === ForceSearch.none) {
            try {
                const manifestMapPath = path.join(tempPath, `${CUMULATIVE_MANIFEST_FILENAME}.json`);
                const fileStats = node_core_library_1.FileSystem.getStatistics(manifestMapPath);
                fileModifiedTime = fileStats.mtime.getTime();
                linkedProjectManifests = lodash_1.cloneDeep(node_core_library_1.JsonFile.load(manifestMapPath));
                foundCumulativeManifestsFile = true;
            }
            catch (e) {
                this._options.logVerbose(`Unable to get "manifests.json" file for project in "${packagePath}". We'll ` +
                    'try to get each manifest separately');
            }
        }
        // If we didn't find a manifests.json file, we should look for individual <id>.manifest.json files.
        if (!linkedProjectManifests) {
            linkedProjectManifests = [];
            // Look for files called something like "abc123.manifest.json" without any leading slashes or extra periods
            try {
                for (const targetFilename of node_core_library_1.FileSystem.readFolder(targetFolderPath)) {
                    if (targetFilename.match(optionsToUse.manifestFileRegex)) {
                        try {
                            const targetFilePath = path.join(targetFolderPath, targetFilename);
                            const fileStats = node_core_library_1.FileSystem.getStatistics(targetFilePath);
                            // PBI:417074 validate the manifest schema.
                            const manifestData = lodash_1.cloneDeep(node_core_library_1.JsonFile.load(targetFilePath));
                            linkedProjectManifests.push(manifestData);
                            fileModifiedTime = Math.max(fileModifiedTime, fileStats.mtime.getTime());
                        }
                        catch (e) { /* empty */ }
                    }
                }
            }
            catch (e) {
                /* Error getting manifest file data */
            }
        }
        if (!foundCumulativeManifestsFile && // If we find a cumulative file, we can probably skip a deeper search
            (forceSearchMode === ForceSearch.deep ||
                forceSearchMode === ForceSearch.deepSparseIgnoreFirstProject ||
                linkedProjectManifests.length > 0)) {
            // If this project has manifests, or we're forcing search, let's look in its references in other projects
            const packages = new Map();
            try {
                const packageJson = node_core_library_1.JsonFile.load(path.join(packagePath, 'package.json'));
                const getPackages = (refs, optional) => {
                    if (refs) {
                        for (const packageName in refs) { // tslint:disable-line:forin
                            packages.set(packageName, optional);
                        }
                    }
                };
                getPackages(packageJson.dependencies, false);
                getPackages(packageJson.devDependencies, true);
                getPackages(packageJson.optionalDependencies, true);
            }
            catch (e) { /* empty */ }
            // Search each referenced project for manifests
            for (const [packageName, optional] of packages) {
                let referencedPackagePath;
                try {
                    // First, try to resolve the package. Don't resolve symlinks under the assumption that
                    // the dependency a monorepo-linked project. If it is a project in the same Rush monorepo,
                    // the project will have a complete node_module at the symlink target.
                    referencedPackagePath = Resolve_1.resolvePackage(packageName, packagePath, { doNotResolveSymlinks: true });
                }
                catch (e) {
                    try {
                        // Try again, this time resolving symlinks.
                        referencedPackagePath = Resolve_1.resolvePackage(packageName, packagePath, { doNotResolveSymlinks: false });
                    }
                    catch (f) {
                        /* ignore */
                    }
                }
                if (referencedPackagePath) {
                    const recursiveForceSearchMode = (forceSearchMode === ForceSearch.shallow)
                        ? ForceSearch.none
                        : (forceSearchMode === ForceSearch.deepSparseIgnoreFirstProject
                            ? ForceSearch.deepSparse
                            : forceSearchMode);
                    const manifests = this.discoverManifests(referencedPackagePath, recursiveForceSearchMode, optionsToUse);
                    for (const manifestId in manifests) {
                        if (manifests.hasOwnProperty(manifestId)) {
                            const manifestVersions = manifests[manifestId];
                            if (!referencedProjectManifests[manifestId]) {
                                referencedProjectManifests[manifestId] = {};
                            }
                            for (const manifestVersion in manifestVersions) {
                                if (manifestVersions.hasOwnProperty(manifestVersion)) {
                                    referencedProjectManifests[manifestId][manifestVersion] = manifestVersions[manifestVersion];
                                }
                            }
                        }
                    }
                }
                else if (!optional) {
                    // Only warn if this isn't an optional package
                    this._options.logWarning(`Unable to resolve project "${packageName}". Ensure it has been linked.`);
                }
            }
        }
        // If we found any manifests directly linked to this project, merge them into the manifests discovered in other
        // projects
        if (linkedProjectManifests) {
            let packageName;
            const manifestsToFilter = [];
            // Include the package name if we found a single project manifest in the target folder
            let isSinglePackage = linkedProjectManifests.length === 1;
            if (!isSinglePackage && linkedProjectManifests.length === 2) {
                if (linkedProjectManifests[0].id === linkedProjectManifests[1].rootComponentId ||
                    linkedProjectManifests[1].id === linkedProjectManifests[0].rootComponentId) {
                    // If we have two manifests, determine if one is the assembly of the other
                    isSinglePackage = true;
                    const assemblyId = linkedProjectManifests[1].rootComponentId
                        ? linkedProjectManifests[1].id
                        : linkedProjectManifests[0].id;
                    if (!this._options.explicitInclude || this._options.explicitInclude.indexOf(assemblyId) === -1) {
                        // We want to filter the assemblies manifest because we never want an assembly's ID to be a dependency
                        manifestsToFilter.push(assemblyId);
                    }
                }
            }
            if (isSinglePackage) {
                try {
                    const packageJson = node_core_library_1.JsonFile.load(packageJsonPath);
                    packageName = packageJson.name;
                }
                catch (e) { /* empty */ }
            }
            for (const manifest of linkedProjectManifests) {
                if (manifestsToFilter.indexOf(manifest.id) === -1) {
                    const id = manifest.id;
                    const componentManifest = manifest;
                    const multiversionManifest = manifest;
                    if (componentManifest.version) {
                        // Single-version manifest
                        this._insertManifestIntoMap(referencedProjectManifests, packagePath, packageName, fileModifiedTime, componentManifest);
                    }
                    else if (multiversionManifest.versions) {
                        // Multiversion manifest
                        for (const version in multiversionManifest.versions) {
                            if (multiversionManifest.versions.hasOwnProperty(version)) {
                                this._insertManifestIntoMap(referencedProjectManifests, packagePath, packageName, fileModifiedTime, multiversionManifest.versions[version]);
                            }
                        }
                    }
                    else {
                        throw new Error(`Invalid manifest with id "${id}" in ${packagePath}.`);
                    }
                }
            }
        }
        this._discoveryCache.set(resolvedPackagePath, referencedProjectManifests);
        return referencedProjectManifests;
    }
    _insertManifestIntoMap(referencedProjectManifests, packagePath, packageName, fileModifiedTime, manifest) {
        const id = manifest.id;
        const version = manifest.version;
        if (!referencedProjectManifests[id]) {
            referencedProjectManifests[id] = {};
        }
        const existingReference = referencedProjectManifests[id][version];
        if (!existingReference || existingReference.manifestCreationTime > existingReference.manifestCreationTime) {
            referencedProjectManifests[id][version] = {
                manifestCreationTime: fileModifiedTime,
                id: manifest.id,
                version: version,
                packagePath,
                packageName,
                manifestData: manifest
            };
        }
    }
    _getTransformedManifest(referenceProject, baseUrl) {
        const relativePath = path.relative(this._options.rootPath, referenceProject.packagePath);
        const manifest = referenceProject.manifestData;
        const baseUrls = manifest.loaderConfig.internalModuleBaseUrls || [];
        const url = url_1.joinUrlSegments(baseUrl, encodeURI(relativePath.replace(/\\/g, '/')));
        if (baseUrls.length > 0) {
            const existingUrl = Url.parse(baseUrls[0]);
            // Prepend the absolute path only if the original URL was an absolute URL
            baseUrls[0] = !!existingUrl.protocol ? url_1.joinUrlSegments(url, existingUrl.pathname) : baseUrls[0];
        }
        else {
            baseUrls[0] = url;
        }
        manifest.loaderConfig.internalModuleBaseUrls = baseUrls.map((internalModuleBaseUrl) => {
            const baseUrlObject = Url.parse(internalModuleBaseUrl);
            if (baseUrlObject.pathname) {
                baseUrlObject.pathname = baseUrlObject.pathname.replace(/\/\//g, '/');
            }
            internalModuleBaseUrl = Url.format(baseUrlObject);
            return url_1.ensureTrailingSlash(internalModuleBaseUrl);
        });
        return manifest;
    }
}
exports.default = CumulativeManifestProcessor;
//# sourceMappingURL=index.js.map