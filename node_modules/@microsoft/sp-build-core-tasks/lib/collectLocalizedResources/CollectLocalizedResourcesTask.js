"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs");
const glob = require("glob");
const lodash_1 = require("lodash");
const constants_1 = require("./../constants");
const OdspGulpTask_1 = require("./../OdspGulpTask");
exports.escapedTokenRegExp = new RegExp(lodash_1.escapeRegExp(lodash_1.escapeRegExp(constants_1.default.localeToken)));
exports.escapedTokenGlobalRegExp = new RegExp(lodash_1.escapeRegExp(lodash_1.escapeRegExp(constants_1.default.localeToken)), 'g');
/**
 * Discovers strings based on the pattern described in config.json
 */
class CollectLocalizedResourcesTask extends OdspGulpTask_1.default {
    constructor() {
        super('collectLocalizedResources', {});
    }
    executeTask(gulp, completeCallback) {
        const localizedResources = this.properties.localizedResources || {};
        const localizedResourceKeys = Object.keys(localizedResources);
        this.logVerbose(`${localizedResourceKeys.length} localized resources defined.`);
        this.properties.discoveredLocalizedResources = {};
        const promises = localizedResourceKeys.map((key) => this._collectResourcesForKey(localizedResources[key])
            .then((result) => {
            this.properties.discoveredLocalizedResources[key] = result;
        })
            .catch((error) => {
            throw `Error for resource "${key}": ${error}`;
        }));
        return Promise.all(promises)
            .then(() => completeCallback())
            .catch(completeCallback);
    }
    _collectResourcesForKey(rawPattern) {
        // If the pattern doesn't have a leading slash, include one so the glob pattern resolves to under the root directory
        const rawPatternMatches = rawPattern.match(/(?:^\/+)(.+)/);
        const pattern = rawPatternMatches ? rawPatternMatches[1] : rawPattern;
        if (rawPatternMatches) {
            this.logWarning(`The localized file pattern "${rawPattern}" contains a leading slash. These patterns resolve ` +
                `to paths under the root directory ("${this.buildConfig.rootPath}"), so they are intended to ` +
                'be relative. A leading slash is not recommended and may produce unexpected behavior.');
        }
        return new Promise((resolve, reject) => {
            if (!pattern.match(CollectLocalizedResourcesTask._localeTokenRegExp)) {
                // Singleton locale, no pattern token
                const fullPath = path.join(this.buildConfig.rootPath, pattern);
                fs.stat(fullPath, (error) => {
                    if (error) {
                        // Singleton not found, throw an error
                        reject(`Singleton resource "${rawPattern}" not found.`);
                    }
                    else {
                        // Singleton found, resolve as the default locale
                        resolve({
                            default: fullPath
                        });
                    }
                });
            }
            else {
                const globPattern = pattern.replace(CollectLocalizedResourcesTask._localeTokenRegExp, '*');
                glob(globPattern, { cwd: this.buildConfig.rootPath }, (error, files) => {
                    if (error) {
                        reject(error.message);
                    }
                    else if (!files || files.length === 0) {
                        reject(`No localized files found under the root directory ("${this.buildConfig.rootPath}") matching ` +
                            `pattern "${rawPattern}"`);
                    }
                    else {
                        // This turns a pattern that looks something like this: "asdf\{locale}/{locale}/{locale}.js"
                        //  into a regex that looks something like this: /asdf\/(.+)\/(?:\\1)\/(?:\\1).js/
                        const normalizedPattern = path.posix.resolve('/', pattern).substr(1);
                        const regexPattern = new RegExp(lodash_1.escapeRegExp(normalizedPattern)
                            .replace(exports.escapedTokenRegExp, '(.+)')
                            // this rule actually has a bug, so we'll remove this exception when it gets fixed. VSO#513580
                            // tslint:disable-next-line:no-octal-literal
                            .replace(exports.escapedTokenGlobalRegExp, '(?:\\1)'));
                        const result = {};
                        files.forEach((file) => {
                            const posixFile = file.replace(/\\/g, '/');
                            const match = posixFile.match(regexPattern);
                            if (!match) {
                                this.logWarning(`Unexpected file path: "${file}"`);
                            }
                            else {
                                const locale = match[1];
                                this.logVerbose(`Found file "${file}", identified as locale "${locale}"`);
                                result[locale] = path.join(this.buildConfig.rootPath, file);
                            }
                        });
                        resolve(result);
                    }
                });
            }
        });
    }
}
CollectLocalizedResourcesTask._localeToken = '{locale}';
CollectLocalizedResourcesTask._localeTokenRegExp = new RegExp(CollectLocalizedResourcesTask._localeToken, 'g');
exports.CollectLocalizedResourcesTask = CollectLocalizedResourcesTask;
//# sourceMappingURL=CollectLocalizedResourcesTask.js.map