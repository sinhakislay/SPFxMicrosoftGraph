"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const glob = require("glob");
const path = require("path");
const through2 = require("through2");
const node_core_library_1 = require("@microsoft/node-core-library");
const gulp_core_build_1 = require("@microsoft/gulp-core-build");
const createPackage_1 = require("./packageSolution/createPackage");
const manifestSchemaValidator_1 = require("@microsoft/sp-module-interfaces/lib/manifestSchemaValidator");
class PackageSolutionTask extends gulp_core_build_1.GulpTask {
    constructor() {
        super('package-solution', {
            paths: {
                packageDir: 'sharepoint',
                debugDir: path.join('solution', 'debug'),
                zippedPackage: path.join('solution', 'ClientSolution.sppkg'),
                featureXmlDir: 'feature_xml',
                sharepointAssetDir: 'assets',
                manifestsMatch: '*.json',
                teamsDir: 'teams'
            },
            contentTypes: {
                'xml': 'text/xml',
                'rels': 'application/vnd.openxmlformats-package.relationships+xml',
                'webpart': 'text/xml',
                'htm': 'text/html',
                'html': 'text/html',
                'aspx': 'text/xml',
                'resx': 'text/xml',
                'js': 'application/javascript',
                'json': 'application/json',
                'png': 'image/png',
                'jpg': 'image/jpeg',
                'bmp': 'image/bmp',
                'gif': 'image/gif'
            },
            solution: {
                'name': 'A Sample Solution',
                'id': '00000000-0000-0000-0000-000000000000'
            }
        });
        this._hasPrependedPaths = false;
    }
    loadSchema() {
        return node_core_library_1.JsonFile.load(path.join(__dirname, 'package-solution.schema.json'));
    }
    executeTask(gulp, completeCallback) {
        if (!this.taskConfig.paths.distributionDir) {
            this.taskConfig.paths.distributionDir = this.buildConfig.distFolder;
        }
        // We have a few warnings in this task that should not fail the build, regardless of whether we are in
        // ship mode or not.
        this.buildConfig.shouldWarningsFailBuild = false;
        const defaultCdnPath = '<!-- PATH TO CDN -->';
        if (this.taskConfig.solution.includeClientSideAssets &&
            this.cdnBasePath !== defaultCdnPath) {
            // check the write-manifests task and see if the cdnBasePath has been changed
            this.logWarning(colors.yellow(`The "cdnBasePath" in "config/write-manifests.json" has been changed from its`
                + ` default value ("${defaultCdnPath}") to "${this.cdnBasePath}",`
                + ` however the "includeClientSideAssets" setting`
                + ` in "config/package-solution.json" is "true" and will be ignored.`
                + ` If you meant to deploy your assets in your SPPKG to SharePoint,`
                + ` reset the value of "cdnBasePath" to "${defaultCdnPath}".`));
            this.taskConfig.solution.includeClientSideAssets = false;
        }
        if (this.taskConfig.solution.includeClientSideAssets && !this.buildConfig.production) {
            this.logWarning(colors.yellow(`This is not a production build (--ship or --production),`
                + ` therefore the "includeClientSideAssets" setting will be ignored.`));
            this.taskConfig.solution.includeClientSideAssets = false;
        }
        this._prependBaseToConfigPaths();
        const ignoredAssets = ['**/*.map'];
        const manifestMap = new Map();
        let foundAnyManifests = false;
        return gulp.src(this.taskConfig.paths.manifestsMatch, {
            cwd: this.taskConfig.paths.distributionDir
        })
            .pipe(through2.obj((file, enc, callback) => {
            foundAnyManifests = true;
            const manifest = JSON.parse(file.contents.toString(enc));
            const validationResult = manifestSchemaValidator_1.default.validateManifest(manifest);
            if (!validationResult.result) {
                this.log(`Ignoring manifest due to validation error: (${file.path}) use '--verbose' for more information`);
                this.logVerbose(manifestSchemaValidator_1.default.getFormattedErrorMessage(validationResult.errors));
                callback();
                return;
            }
            this.log(`Found manifest: ${file.path}`);
            ignoredAssets.push(path.relative(this.taskConfig.paths.distributionDir, file.path));
            manifestMap.set(manifest.id, manifest);
            callback();
        }, (callback) => {
            if (!manifestMap.size) {
                if (foundAnyManifests) {
                    callback(new Error(`Some manifests were found in '${this.taskConfig.paths.manifestsMatch}' ` +
                        ', but were not valid. Ensure paths.manifestsMatch is correct'));
                }
                else {
                    callback(new Error(`No manifests were found in '${this.taskConfig.paths.manifestsMatch}'. ` +
                        'Ensure a build has completed successfully and that paths.manifestsMatch is correct'));
                }
            }
            // read in all the assets, if necessary
            if (this.taskConfig.solution.includeClientSideAssets) {
                this.taskConfig.solution.clientSideAssets = glob.sync('**/*.*', {
                    ignore: ignoredAssets,
                    cwd: this.taskConfig.paths.distributionDir
                }).map((filename) => {
                    this.log(colors.cyan(`Found client-side build resource: ${filename}`));
                    return {
                        originalFilename: path.join(this.taskConfig.paths.distributionDir, filename),
                        packageFilename: filename
                    };
                });
            }
            // Always copy everything from the teams folder
            const teamsIcons = glob.sync('**/*.*', {
                ignore: ignoredAssets,
                cwd: this.taskConfig.paths.teamsDir
            }).map((filename) => {
                this.log(colors.cyan(`Found teams icons: ${filename}`));
                return {
                    originalFilename: path.join(this.taskConfig.paths.teamsDir, filename),
                    packageFilename: filename
                };
            });
            if (this.taskConfig.solution.clientSideAssets !== undefined) {
                this.taskConfig.solution.clientSideAssets =
                    this.taskConfig.solution.clientSideAssets.concat(teamsIcons);
            }
            else {
                this.taskConfig.solution.clientSideAssets = teamsIcons;
            }
            createPackage_1.default(this.taskConfig, manifestMap).then(callback, callback);
        }));
    }
    getCleanMatch(buildConfig) {
        this.buildConfig = buildConfig;
        if (!this.taskConfig.paths.distributionDir) {
            this.taskConfig.paths.distributionDir = this.buildConfig.distFolder;
        }
        this._prependBaseToConfigPaths();
        return [
            this.taskConfig.paths.debugDir,
            this.taskConfig.paths.zippedPackage
        ];
    }
    _prependBaseToConfigPaths() {
        if (!this._hasPrependedPaths) {
            this.taskConfig.paths.debugDir =
                path.join(this.taskConfig.paths.packageDir, this.taskConfig.paths.debugDir);
            this.taskConfig.paths.zippedPackage =
                path.join(this.taskConfig.paths.packageDir, this.taskConfig.paths.zippedPackage);
            this.taskConfig.paths.featureXmlDir =
                path.join(this.taskConfig.paths.packageDir, this.taskConfig.paths.featureXmlDir);
            this.taskConfig.paths.sharepointAssetDir =
                path.join(this.taskConfig.paths.packageDir, this.taskConfig.paths.sharepointAssetDir);
            this._hasPrependedPaths = true;
        }
    }
}
exports.PackageSolutionTask = PackageSolutionTask;
//# sourceMappingURL=PackageSolutionTask.js.map