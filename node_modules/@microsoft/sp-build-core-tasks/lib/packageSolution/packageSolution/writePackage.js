"use strict";
/**
 * @file writePackage.ts
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * Writes a package xml object to disk, in both raw and zipped format
 */
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="./node-zip.d.ts" />
/* tslint:disable:no-any */
const path = require("path");
const fsx = require("fs-extra");
const rmdir = require("rimraf");
const JSZip = require("node-zip");
const gulp_core_build_1 = require("@microsoft/gulp-core-build");
const utilities_1 = require("../utilities");
/**
 * Writes the ISolutionXml object containing the solution package xml to the disk using provided config
 */
function writePackage(solution, config) {
    const zip = new JSZip();
    return cleanRawPackageDirectory(config)
        .then(() => Promise.all([
        writeODCFile(solution.manifest, config, zip),
        writeXmlFile(solution.relationships, config, zip),
        writeXmlFile(solution.contentTypesXml, config, zip),
        writeIcon(solution.icon, config, zip)
    ]
        .concat(solution.customFiles.map((customFile) => writeXmlFile(customFile, config, zip)))
        .concat(solution.features.map((feature) => writeFeature(feature, config, zip)))))
        .then(() => {
        return writeFile(config.paths.zippedPackage, zip.generate({ base64: false, compression: 'DEFLATE' }), 'binary');
    });
}
exports.default = writePackage;
/**
 * Ensures that the contents of config.paths.debugDir have been deleted
 */
function cleanRawPackageDirectory(config) {
    return new Promise((complete, reject) => {
        rmdir(config.paths.debugDir, (error) => {
            if (error) {
                reject(error);
                return;
            }
            gulp_core_build_1.log(`Cleaned ${config.paths.debugDir}`);
            complete();
        });
    });
}
exports.cleanRawPackageDirectory = cleanRawPackageDirectory;
function writeFeature(feature, config, zip) {
    return Promise.all([
        writeODCFile(feature, config, zip),
        writeXmlFile(feature.config, config, zip)
    ]
        .concat((feature.clientSideResources || []).map((resource) => writeXmlFile(resource, config, zip)))
        .concat(feature.assets.elementFiles.map((asset) => writeXmlFile(asset, config, zip)))
        .concat(feature.assets.elementManifests.map((asset) => writeXmlFile(asset, config, zip)))
        .concat(feature.assets.upgradeActions.map((asset) => writeXmlFile(asset, config, zip)))
        .concat(feature.components.map((component) => writeXmlFile(component, config, zip))));
}
exports.writeFeature = writeFeature;
/**
 * Write the app icon related files: The icon file itself, and the config.xml
 * If there is no icon it does nothing.
 * If the icon path is invalid, it throws an error.
 */
function writeIcon(icon, config, zip) {
    if (icon) {
        const filepath = path.join(config.paths.packageDir, icon.path);
        if (fsx.statSync(filepath).isFile()) {
            return Promise.all([
                readFile(filepath).then((data) => writeFileToPath(icon.path, data, config, zip)),
                writeXmlFile(icon.config, config, zip),
                writeXmlFile(icon.relationships, config, zip)
            ]);
        }
        else {
            throw new Error(`Icon with path "${icon.path}" was not found.`);
        }
    }
}
exports.writeIcon = writeIcon;
function writeXmlFile(file, config, zip) {
    return writeFileToPath(file.filename, file.contents, config, zip);
}
exports.writeXmlFile = writeXmlFile;
function writeODCFile(file, config, zip) {
    return Promise.all([
        writeFileToPath(file.filename, file.contents, config, zip),
        writeXmlFile(file.relationships, config, zip)
    ]);
}
exports.writeODCFile = writeODCFile;
/**
 * Physically writes a file to disk, and adds to an in-memory zip package
 */
function writeFileToPath(filename, contents, config, zip) {
    const filepath = path.join(config.paths.debugDir, filename);
    return utilities_1.serial([
        () => writeFile(filepath, contents),
        () => addFileToZip(filename, contents, zip)
    ]);
}
/**
 * Returns a promise which ensures a directory on disk exists using mkdirsSync()
 */
function ensureDirectory(filepath) {
    return new Promise((complete, reject) => {
        const directories = filepath.split(path.sep);
        directories.pop();
        const pathToFile = directories.join(path.sep);
        fsx.mkdirs(pathToFile, (err) => {
            if (err) {
                reject(err);
                return;
            }
            complete();
        });
    });
}
/**
 * Wraps fsx.readFile in a promise
 */
function readFile(filename) {
    return new Promise((complete, reject) => {
        fsx.readFile(filename, (error, data) => {
            if (error) {
                reject(error);
                return;
            }
            complete(data);
        });
    });
}
/**
 * Wraps fsx.writeFile in a promise
 */
function writeFile(filename, contents, encoding) {
    return ensureDirectory(filename).then(() => {
        fsx.writeFileSync(filename, contents, { encoding });
        gulp_core_build_1.log(`Created file: ${filename}`);
    });
}
/**
 * Adds a file to a zip package
 */
function addFileToZip(filepath, content, zip) {
    return new Promise((complete, reject) => {
        const directories = filepath.split(path.sep);
        const file = directories.pop();
        for (const dir of directories) {
            zip = zip.folder(dir);
        }
        zip.file(file, content);
        complete();
    });
}
//# sourceMappingURL=writePackage.js.map