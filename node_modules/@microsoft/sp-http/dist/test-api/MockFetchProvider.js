/* tslint:disable:no-any */
var MockedHeader = /** @class */ (function () {
    // In order to enforce that the header is NOT present, specify the
    // value as undefined.
    function MockedHeader(name, value) {
        this.name = name;
        this.value = value;
    }
    return MockedHeader;
}());
export { MockedHeader };
/**
 * A mock implementation of IFetchProvider, that allows a unit test to specify
 * the sequence of expected REST requests, and then validate that they occur in
 * that order.
 */
var MockFetchProvider = /** @class */ (function () {
    function MockFetchProvider(serviceScope) {
        this.mockedRequest = [];
        this.practiceRun = false;
    }
    MockFetchProvider.getNormalizedText = function (text) {
        return text.split('\n')
            .map(function (line) { return line.trim(); })
            .join('\n')
            .trim();
    };
    /**
     * Adds an expected request to the internal queue.  Items will be removed from this
     * queue and validated whenever fetch() is called.
     */
    MockFetchProvider.prototype.expect = function (mockedRequest) {
        this.mockedRequest.push(mockedRequest);
    };
    /**
     * Asserts that the queue is empty, e.g. to ensure that the unit test performed
     * all expected requests.
     */
    MockFetchProvider.prototype.assertQueueEmpty = function () {
        if (this.practiceRun) {
            return;
        }
        if (this.mockedRequest.length !== 0) {
            var next = this.mockedRequest.shift();
            throw new Error("A request was expected but never issued: " + next.expectedUrl);
        }
    };
    /**
     * The IFetchProvider contract that we are mocking.
     */
    MockFetchProvider.prototype.fetch = function (request) {
        var _this = this;
        return request.text().then(function (requestBodyText) {
            var url = request.url || '(undefined url)';
            if (_this.mockedRequest.length === 0) {
                throw new Error("No request expected at this time: " + url.toString());
            }
            var mockedRequest = _this.mockedRequest.shift();
            if (_this.practiceRun) {
                var observeOnlyCounter = ++MockFetchProvider._observeOnlyCounter;
                console.log("MockFetchProvider: REQUEST #" + observeOnlyCounter);
                var headerLines_1 = '';
                request.headers.forEach(function (value, name) {
                    headerLines_1 += "  " + name + ": " + value + "\n";
                });
                console.log([
                    '',
                    "==[REQUEST #" + observeOnlyCounter + "]===========================================",
                    "URL: " + request.url,
                    "HEADERS:",
                    "" + headerLines_1 +
                        "== BODY: ====================================================================",
                    "" + requestBodyText,
                    "=============================================================================",
                    ''
                ].join('\n'));
            }
            else {
                if (url !== mockedRequest.expectedUrl) {
                    throw new Error("Expecting this: " + mockedRequest.expectedUrl + "\r\nBut got this:" + url);
                }
                (mockedRequest.expectedRequestHeaders || []).forEach(function (mockedHeader) {
                    var value = request.headers.get(mockedHeader.name);
                    if (mockedHeader.value !== undefined) {
                        if (!value) {
                            throw new Error("The \"" + mockedHeader.name + "\" header was expected,  but is missing from the response");
                        }
                        if (value !== mockedHeader.value) {
                            throw new Error("The \"" + mockedHeader.name + "\" header had this value:\r\n"
                                + ("\"" + value + "\"\r\nbut this was expected:\r\n\"" + mockedHeader.value + "\""));
                        }
                    }
                    else {
                        if (value) {
                            throw new Error("The \"" + mockedHeader.name + "\" header was NOT expected,"
                                + (" but it appeared in the response with this value:\r\n\"" + value + "\""));
                        }
                    }
                });
                if (mockedRequest.expectedRequestObject) {
                    var expectedBodyText = mockedRequest.expectedRequestObject;
                    if (MockFetchProvider.getNormalizedText(expectedBodyText) !==
                        MockFetchProvider.getNormalizedText(requestBodyText)) {
                        throw new Error("The body text for this request did not match:\n" + url);
                    }
                }
                if (mockedRequest.requestAssertions) {
                    mockedRequest.requestAssertions(request);
                }
            }
            var responseText = (typeof mockedRequest.responseObject === 'string')
                ? mockedRequest.responseObject
                : JSON.stringify(mockedRequest.responseObject);
            // Chrome sets these defaults, but whatwg-polyfill does not
            var responseOptions = mockedRequest.responseOptions
                || { status: 200, statusText: 'OK' };
            var response = new Response(responseText, responseOptions);
            if (mockedRequest.responseHeaders) {
                for (var _i = 0, _a = mockedRequest.responseHeaders; _i < _a.length; _i++) {
                    var responseHeader = _a[_i];
                    response.headers.append(responseHeader.name, responseHeader.value);
                }
            }
            if (mockedRequest.responseContentLengthHeader) {
                response.headers.append('Content-Length', responseText.length.toString());
            }
            return response;
        });
    };
    MockFetchProvider._observeOnlyCounter = 0;
    return MockFetchProvider;
}());
export default MockFetchProvider;
//# sourceMappingURL=MockFetchProvider.js.map