/**
 * Cache Manager for http Requests
 *
 * @internal
 */
var CacheManager = /** @class */ (function () {
    function CacheManager() {
    }
    /**
     * Fetches latest data from server or cache. Updates the cache from server if needed.
     * @param cacheKey - The cache Key
     * @param cacheProvider - The cache Provider
     * @param cacheStrategy - The Cache Strategy
     * @param serverFetch - The server fetch call
     * @param serverFetchArgs - The arguments to be used on the server fetch call
     */
    CacheManager.fetchAndCache = function (cacheKey, /* tslint:disable-line:no-any */ cacheProvider, cacheConfiguration, serverFetch) {
        var cacheStrategy = cacheConfiguration.cacheStrategy, refreshInterval = cacheConfiguration.refreshInterval;
        // 3rd party default behavior - If cacheStrategy is undefined
        if (!cacheStrategy) {
            return cacheProvider.getData(cacheKey, refreshInterval).then(function (data) {
                if (data) {
                    return Promise.resolve(data).catch(function (a) { return a; });
                }
                // Cache Miss, update cache with serverData
                /* tslint:disable:error no-floating-promises */
                return serverFetch().then(function (response) {
                    if (response.clone) {
                        CacheManager._updateCache(cacheKey, cacheProvider, response.clone());
                    }
                    return response;
                });
            });
        }
        // First Party Caching Strategies
        var cachableResponse = CacheManager._applyCacheStrategy(cacheKey, cacheProvider, cacheConfiguration, serverFetch);
        return Promise.resolve(cachableResponse);
    };
    CacheManager._applyCacheStrategy = function (cacheKey, /* tslint:disable-line:no-any */ cacheProvider, cacheConfiguration, serverFetch) {
        var cacheStrategy = cacheConfiguration.cacheStrategy, refreshInterval = cacheConfiguration.refreshInterval;
        var cachableResponse = {
            cachedResponse: undefined,
            serverResponse: undefined
        };
        if (cacheStrategy === 1 /* CacheOnly */ || cacheStrategy === 2 /* CacheAndNetwork */) {
            cachableResponse.cachedResponse = cacheProvider.getData(cacheKey, refreshInterval);
        }
        if (cacheStrategy === 0 /* NetworkOnly */ || cacheStrategy === 2 /* CacheAndNetwork */) {
            cachableResponse.serverResponse = serverFetch().then(function (response) {
                if (response.clone) {
                    CacheManager._updateCache(cacheKey, cacheProvider, response.clone());
                }
                return response;
            });
        }
        return cachableResponse;
    };
    CacheManager._updateCache = function (cacheKey, /* tslint:disable-line:no-any */ cacheProvider, response) {
        // Only update the cache if the server response is valid
        if (response.status >= 200 && response.status < 300) {
            response.json().then(function (freshData) {
                if (freshData) {
                    // Update the cache when there is fresh data available from the server
                    setTimeout(function () { return cacheProvider.setData(cacheKey, freshData); }, 0);
                }
            });
        }
    };
    return CacheManager;
}());
export { CacheManager };
//# sourceMappingURL=CacheManager.js.map