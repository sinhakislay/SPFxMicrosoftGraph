import { Guid, _SPKillSwitch } from '@microsoft/sp-core-library';
import AadConstants from './AadConstants';
import { _QosMonitor } from '@microsoft/sp-diagnostics';
import { AadErrorHandler } from './AadErrorHandler';
/**
 * Class that wraps the ADAL's authentication class
 * @internal
 */
var AdalAuthContext = /** @class */ (function () {
    function AdalAuthContext(authContext, aadUserId) {
        this.clientId = authContext.config.clientId;
        this._aadUserId = aadUserId || '';
        this._patchAdalAuthContext(authContext);
        this._authContext = authContext;
    }
    AdalAuthContext.prototype.getToken = function (resourceEndpoint, useCachedToken) {
        var _this = this;
        var acquireAccessTokenQosMonitor = new _QosMonitor('AdalTokenProvider.GetToken');
        var extraData = {
            CorrelationId: Guid.newGuid().toString(),
            isInternal: this.clientId === AadConstants.PRE_AUTHORIZED_APP_PRINCIPAL_ID
        };
        return this._getAccessToken(resourceEndpoint, useCachedToken, extraData)
            .then(function (token) {
            acquireAccessTokenQosMonitor.writeSuccess(extraData);
            return token;
        })
            .catch(function (e) {
            if (!_SPKillSwitch.isActivated(AdalAuthContext.changePromptingForRedirectionKillSwitchGuid, '11/07/19', 'Use error code property instead of AAD error code for triggering User Interaction')) {
                AadErrorHandler._handleInteractionRequiredFailures(_this._authContext, e.message, resourceEndpoint);
            }
            _this._monitorAndThrowForAccessTokenExpectedFailures(acquireAccessTokenQosMonitor, e, resourceEndpoint, extraData);
            // Expected errors will log and throw an exception from the previous function
            acquireAccessTokenQosMonitor.writeUnexpectedFailure(e.message, e, extraData);
            throw e;
        });
    };
    AdalAuthContext.prototype._getAccessToken = function (resourceEndpoint, useCachedToken, extraData) {
        var cachedAccessToken = this._tryGetCachedAccessToken(resourceEndpoint);
        if (useCachedToken && cachedAccessToken) {
            // No network request was made.
            extraData.CorrelationId = Guid.empty.toString();
            return Promise.resolve(cachedAccessToken);
        }
        else {
            if (!_SPKillSwitch.isActivated(AdalAuthContext.unexpectedErrorsKillSwitchGuid, '10/30/19', 'Fix issue with unexpected errors')) {
                return this._fetchAccessToken(resourceEndpoint, extraData);
            }
            return this._fetchAccessTokenOld(resourceEndpoint, extraData);
        }
    };
    /**
     * Returns an access token if a valid cached token exists
     */
    AdalAuthContext.prototype._tryGetCachedAccessToken = function (resourceEndpoint) {
        var cachedToken;
        try {
            cachedToken = this._authContext.getCachedToken(resourceEndpoint);
            var jwtToken = this._authContext._extractIdToken(cachedToken);
            if (jwtToken.oid !== this._aadUserId || jwtToken.appid !== this.clientId) {
                cachedToken = undefined;
            }
        }
        catch (e) {
            // Empty block
        }
        return cachedToken;
    };
    /**
     * See the following link for details about handling conditional access policies.
     * https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-conditional-access-developer
     */
    AdalAuthContext.prototype._fetchAccessTokenOld = function (resourceEndpoint, extraData) {
        var _this = this;
        var acquireAccessTokenQosMonitor = new _QosMonitor('AdalTokenProvider.AcquireAccessTokenSilent');
        this._authContext.config.correlationId = extraData.CorrelationId;
        var aadError;
        // Attempt to fetch a new access token
        return this._fetchAccessTokenSilent(resourceEndpoint)
            .catch(function (firstError) {
            aadError = firstError;
            _this._monitorAndThrowForAccessTokenExpectedFailures(acquireAccessTokenQosMonitor, firstError, resourceEndpoint, extraData);
        })
            .then(function (token) {
            if (token) {
                return token;
            }
            return _this._fetchAccessTokenSilent(resourceEndpoint);
        })
            .catch(function (secondError) {
            if (aadError) {
                throw aadError;
            }
            aadError = secondError;
            _this._monitorAndThrowForAccessTokenExpectedFailures(acquireAccessTokenQosMonitor, secondError, resourceEndpoint, extraData);
        })
            .then(function (token) {
            // If we don't have a token at this point, then we tried twice with unexpected failures
            if (!token) {
                if (!aadError) {
                    aadError = new Error('Neither a token or error was received');
                }
                if (aadError.message.indexOf('Token renewal operation failed due to timeout') > -1) {
                    aadError.message = aadError.message + ' AADCorrelationId: ' + extraData.CorrelationId;
                }
                acquireAccessTokenQosMonitor.writeUnexpectedFailure(aadError.message, aadError, extraData);
                throw aadError;
            }
            acquireAccessTokenQosMonitor.writeSuccess(extraData);
            return token;
        });
    };
    AdalAuthContext.prototype._fetchAccessToken = function (resourceEndpoint, extraData) {
        var _this = this;
        var acquireAccessTokenQosMonitor = new _QosMonitor('AdalTokenProvider.AcquireAccessTokenSilent');
        this._authContext.config.correlationId = extraData.CorrelationId;
        var expectedError;
        // Attempt to fetch a new access token
        return this._fetchAccessTokenSilent(resourceEndpoint)
            .catch(function (firstError) {
            try {
                _this._monitorAndThrowForAccessTokenExpectedFailures(acquireAccessTokenQosMonitor, firstError, resourceEndpoint, extraData);
            }
            catch (error) {
                expectedError = error;
                throw error;
            }
        })
            .then(function (token) { return token || _this._fetchAccessTokenSilent(resourceEndpoint); })
            .catch(function (secondError) {
            // Avoid processing an expected error on the first request
            if (expectedError) {
                throw expectedError;
            }
            _this._monitorAndThrowForAccessTokenExpectedFailures(acquireAccessTokenQosMonitor, secondError, resourceEndpoint, extraData);
            if (secondError.message === 'Token renewal operation failed due to timeout') {
                secondError.message = secondError.message + ' AADCorrelationId: ' + extraData.CorrelationId;
            }
            acquireAccessTokenQosMonitor.writeUnexpectedFailure(secondError, secondError, extraData);
            throw secondError;
        })
            .then(function (token) {
            acquireAccessTokenQosMonitor.writeSuccess(extraData);
            return token;
        });
    };
    /**
     * Throws an exception if an expected error has occurred. List of expected errors are listed in AadConstants.ts
     */
    AdalAuthContext.prototype._monitorAndThrowForAccessTokenExpectedFailures = function (acquireAccessTokenQosMonitor, aadError, resourceEndpoint, correlationObject) {
        if (_SPKillSwitch.isActivated(AdalAuthContext.changePromptingForRedirectionKillSwitchGuid, '11/07/19', 'Use error code property instead of AAD error code for triggering User Interaction')) {
            if (AadErrorHandler._doesAadErrorCodeExist(aadError.message, AadConstants.RESOLVABLE_AAD_ERROR_CODES)) {
                AadErrorHandler._handleInteractionRequiredFailuresOld(this._authContext, aadError.message, resourceEndpoint);
                acquireAccessTokenQosMonitor.writeExpectedFailure(aadError.message, aadError, correlationObject);
                throw aadError;
            }
            else if (AadErrorHandler._doesAadErrorCodeExist(aadError.message, AadConstants.UNRESOLVABLE_AAD_ERROR_CODES)) {
                acquireAccessTokenQosMonitor.writeExpectedFailure(aadError.message, aadError, correlationObject);
                throw aadError;
            }
        }
        else {
            if (AadErrorHandler._doesAadErrorCodeExist(aadError.message, AadConstants.EXPECTED_AAD_ERRORS)) {
                acquireAccessTokenQosMonitor.writeExpectedFailure(aadError.message, aadError, correlationObject);
                throw aadError;
            }
        }
    };
    /**
     * Wraps the ADAL.js callback code with a promise.
     */
    AdalAuthContext.prototype._fetchAccessTokenSilent = function (resourceEndpoint) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._authContext.acquireToken(resourceEndpoint, function (errorDescription, token, errorType) {
                if (!token) {
                    reject(new Error('Error - Type : ' + errorType + ' - Description : ' + errorDescription));
                }
                else {
                    resolve(token);
                }
            });
        });
    };
    /**
     * Patching ADAL context to address design issues.
     */
    AdalAuthContext.prototype._patchAdalAuthContext = function (authContext) {
        var _this = this;
        // AuthContext object has a weird mechanism that forces the object to be a singleton
        // We're fixing this so that we can have multiple authContext objects
        Object.getPrototypeOf(authContext)._singletonInstance = undefined;
        // Patching ADAL's iframe to include sandbox mode
        authContext._addAdalFrame = function (iframeId) {
            return _this._addAdalFrame(authContext, iframeId);
        };
        // Patching ADAL's iframe rendering logic to avoid setTimeout.
        authContext._loadFrame = function (urlNavigate, frameName) {
            return _this._loadFrame(authContext, urlNavigate, frameName);
        };
        // Patching ADAL's to avoid fetching id token before access token
        authContext._user = {};
        // This is required for the MFA scenario. SPFxSingleSignOn.aspx reads this value redirects to the original page.
        authContext._saveItem(authContext.CONSTANTS.STORAGE.LOGIN_REQUEST, window.location.href);
    };
    /**
     * Adds the hidden iframe for silent token renewal. This code is a security fix to ADAL.js's iframe
     * rendering code. IE11 doesn't support dynamically setting attributes on an iFrame element, so
     * we must patch the original implementation. Original code is in ADAL.js addAdalFrame.
     * https://github.com/AzureAD/azure-activedirectory-library-for-js/ for source code
     */
    AdalAuthContext.prototype._addAdalFrame = function (authContext, iframeId) {
        if (typeof iframeId === 'undefined') {
            return;
        }
        authContext.info('Add adal frame to document:' + iframeId);
        var adalFrame = document.getElementById(iframeId);
        var sandboxAttributes = 'allow-same-origin allow-scripts allow-forms allow-pointer-lock';
        if (!adalFrame) {
            if (document.createElement && document.documentElement &&
                /* tslint:disable:next-line no-any */
                (window.opera || window.navigator.userAgent.indexOf('MSIE 5.0') === -1)) {
                var ifr = document.createElement('iframe');
                ifr.setAttribute('id', iframeId);
                ifr.setAttribute('aria-hidden', 'true');
                ifr.setAttribute('sandbox', sandboxAttributes);
                ifr.style.visibility = 'hidden';
                ifr.style.position = 'absolute';
                ifr.style.width = ifr.style.height = ifr.style.border = '0';
                adalFrame = document.getElementsByTagName('body')[0].appendChild(ifr);
            }
            else if (document.body && document.body.insertAdjacentHTML) {
                document.body.insertAdjacentHTML('beforeEnd', '<iframe sandbox="' + sandboxAttributes + '" name="' +
                    iframeId + '" id="' + iframeId + '" style="display:none"></iframe>');
            }
            if (window.frames && window.frames[iframeId]) {
                adalFrame = window.frames[iframeId];
            }
        }
        return adalFrame;
    };
    /**
     * Opens a hidden iframe for silent token renewal. The original code performed this action in a really weird
     * and inefficent way, so we're fixing it.
     * Original code is in ADAL.js loadFrame.
     * https://github.com/AzureAD/azure-activedirectory-library-for-js/ for source code
     */
    AdalAuthContext.prototype._loadFrame = function (authContext, urlNavigate, frameName) {
        authContext.info('LoadFrame: ' + frameName);
        var frameHandle = authContext._addAdalFrame(frameName);
        frameHandle.src = urlNavigate;
    };
    AdalAuthContext.changePromptingForRedirectionKillSwitchGuid = Guid.parse('e9f10f8d-7bbd-4077-b992-a372f43466d7');
    AdalAuthContext.unexpectedErrorsKillSwitchGuid = Guid.parse('b862cbc3-9d33-4953-9225-758348e534bc');
    return AdalAuthContext;
}());
export default AdalAuthContext;
//# sourceMappingURL=AdalAuthContext.js.map