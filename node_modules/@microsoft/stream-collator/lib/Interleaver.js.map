{"version":3,"file":"Interleaver.js","sourceRoot":"","sources":["../src/Interleaver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as colors from 'colors';\r\nimport * as os from 'os';\r\n\r\n/**\r\n * An writable interface for managing output of simultaneous processes.\r\n *\r\n * @public\r\n */\r\nexport interface ITaskWriter {\r\n  write(data: string): void;      // Writes a string to the buffer\r\n  writeLine(data: string): void;  // Writes a string with a newline character at the end\r\n  writeError(data: string): void; // Writes an error to the stderr stream\r\n  getStdOutput(): string;         // Returns standard output buffer as a string\r\n  getStdError(): string;          // Returns standard error buffer as a string\r\n  close(): void;                  // Closes the stream and marks the simultaneous process as completed\r\n}\r\n\r\nenum TaskWriterState {\r\n  Open = 1,\r\n  ClosedUnwritten = 2,\r\n  Written = 3\r\n}\r\n\r\ninterface ITaskWriterInfo {\r\n  state: TaskWriterState;\r\n  quietMode: boolean;\r\n  stdout: string[];\r\n  stderr: string[];\r\n}\r\n\r\nenum ITaskOutputStream {\r\n  stdout = 1,\r\n  stderr = 2\r\n}\r\n\r\n/**\r\n * A static class which manages the output of multiple threads.\r\n *\r\n * @public\r\n */\r\nexport class Interleaver {\r\n  private static _tasks: Map<string, ITaskWriterInfo> = new Map<string, ITaskWriterInfo>();\r\n  private static _activeTask: string = undefined;\r\n  private static _stdout: { write: (text: string) => void } = process.stdout;\r\n\r\n  /**\r\n   * Resets the default output stream\r\n   */\r\n  public static setStdOut(stdout: { write: (text: string) => void }): void {\r\n    this._stdout = stdout;\r\n  }\r\n\r\n  /**\r\n   * Registers a task into the list of active buffers and returns a ITaskWriter for the\r\n   * calling process to use to manage output.\r\n   */\r\n  public static registerTask(taskName: string, quietMode: boolean = false): ITaskWriter {\r\n    if (this._tasks.has(taskName)) {\r\n      throw new Error('A task with that name has already been registered');\r\n    }\r\n\r\n    this._tasks.set(taskName, {\r\n      quietMode: quietMode,\r\n      state: TaskWriterState.Open,\r\n      stderr: [],\r\n      stdout: []\r\n    });\r\n\r\n    if (this._activeTask === undefined) {\r\n      this._activeTask = taskName;\r\n    }\r\n\r\n    return {\r\n      close: (): void => this._completeTask(taskName),\r\n      getStdError: (): string => this._getTaskOutput(taskName, ITaskOutputStream.stderr),\r\n      getStdOutput: (): string => this._getTaskOutput(taskName),\r\n      write: (data: string): void => this._writeTaskOutput(taskName, data),\r\n      writeError: (data: string): void => this._writeTaskOutput(taskName, data, ITaskOutputStream.stderr),\r\n      writeLine: (data: string): void => this._writeTaskOutput(taskName, data + os.EOL)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Removes information about all running tasks\r\n   */\r\n  public static reset(): void {\r\n    this._activeTask = undefined;\r\n    this._tasks = new Map<string, ITaskWriterInfo>();\r\n  }\r\n\r\n  /**\r\n   * Adds the text to the task's buffer, and writes it to the console if it is the active task\r\n   */\r\n  private static _writeTaskOutput(taskName: string, data: string,\r\n    stream: ITaskOutputStream = ITaskOutputStream.stdout): void {\r\n\r\n    const taskInfo: ITaskWriterInfo = this._tasks.get(taskName);\r\n    if (!taskInfo || taskInfo.state !== TaskWriterState.Open) {\r\n      throw new Error('The task is not registered or has been completed and written.');\r\n    }\r\n    const outputBuffer: string[] = (stream === ITaskOutputStream.stderr ? taskInfo.stderr : taskInfo.stdout);\r\n\r\n    if (!this._activeTask) {\r\n      this._activeTask = taskName;\r\n      this._writeTask(taskName, taskInfo);\r\n      taskInfo.state = TaskWriterState.Open;\r\n    }\r\n\r\n    outputBuffer.push(data);\r\n    if (this._activeTask === taskName) {\r\n      if (stream === ITaskOutputStream.stdout && !taskInfo.quietMode) {\r\n        this._stdout.write(data);\r\n      } else if (stream === ITaskOutputStream.stderr) {\r\n        this._stdout.write(data);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the current value of the task's buffer\r\n   */\r\n  private static _getTaskOutput(taskName: string, stream: ITaskOutputStream = ITaskOutputStream.stdout): string {\r\n    const taskInfo: ITaskWriterInfo = this._tasks.get(taskName);\r\n    return (stream === ITaskOutputStream.stdout ? taskInfo.stdout : taskInfo.stderr).join('');\r\n  }\r\n\r\n  /**\r\n   * Marks a task as completed. There are 3 cases:\r\n   *  - If the task was the active task, also write out all completed, unwritten tasks\r\n   *  - If there is no active task, write the output to the screen\r\n   *  - If there is an active task, mark the task as completed and wait for active task to complete\r\n   */\r\n  private static _completeTask(taskName: string): void {\r\n    const taskInfo: ITaskWriterInfo = this._tasks.get(taskName);\r\n    if (!taskInfo || taskInfo.state !== TaskWriterState.Open) {\r\n      throw new Error('The task is not registered or has been completed and written.');\r\n    }\r\n\r\n    if (this._activeTask === undefined) {\r\n      this._writeTask(taskName, taskInfo);\r\n    } else if (taskName === this._activeTask) {\r\n      this._activeTask = undefined;\r\n      taskInfo.state = TaskWriterState.Written;\r\n      this._writeAllCompletedTasks();\r\n    } else {\r\n      taskInfo.state = TaskWriterState.ClosedUnwritten;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper function which writes all completed tasks\r\n   */\r\n  private static _writeAllCompletedTasks(): void {\r\n    this._tasks.forEach((task: ITaskWriterInfo, taskName: string) => {\r\n      if (task && task.state === TaskWriterState.ClosedUnwritten) {\r\n        this._writeTask(taskName, task);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Write and delete task\r\n   */\r\n  private static _writeTask(taskName: string, taskInfo: ITaskWriterInfo): void {\r\n    taskInfo.state = TaskWriterState.Written;\r\n    if (!taskInfo.quietMode) {\r\n      this._stdout.write(taskInfo.stdout.join(''));\r\n    }\r\n    this._stdout.write(colors.red(taskInfo.stderr.join('')));\r\n  }\r\n\r\n  private constructor() { }\r\n}\r\n"]}