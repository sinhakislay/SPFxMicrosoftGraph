"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const os = require("os");
var TaskWriterState;
(function (TaskWriterState) {
    TaskWriterState[TaskWriterState["Open"] = 1] = "Open";
    TaskWriterState[TaskWriterState["ClosedUnwritten"] = 2] = "ClosedUnwritten";
    TaskWriterState[TaskWriterState["Written"] = 3] = "Written";
})(TaskWriterState || (TaskWriterState = {}));
var ITaskOutputStream;
(function (ITaskOutputStream) {
    ITaskOutputStream[ITaskOutputStream["stdout"] = 1] = "stdout";
    ITaskOutputStream[ITaskOutputStream["stderr"] = 2] = "stderr";
})(ITaskOutputStream || (ITaskOutputStream = {}));
/**
 * A static class which manages the output of multiple threads.
 *
 * @public
 */
class Interleaver {
    constructor() { }
    /**
     * Resets the default output stream
     */
    static setStdOut(stdout) {
        this._stdout = stdout;
    }
    /**
     * Registers a task into the list of active buffers and returns a ITaskWriter for the
     * calling process to use to manage output.
     */
    static registerTask(taskName, quietMode = false) {
        if (this._tasks.has(taskName)) {
            throw new Error('A task with that name has already been registered');
        }
        this._tasks.set(taskName, {
            quietMode: quietMode,
            state: TaskWriterState.Open,
            stderr: [],
            stdout: []
        });
        if (this._activeTask === undefined) {
            this._activeTask = taskName;
        }
        return {
            close: () => this._completeTask(taskName),
            getStdError: () => this._getTaskOutput(taskName, ITaskOutputStream.stderr),
            getStdOutput: () => this._getTaskOutput(taskName),
            write: (data) => this._writeTaskOutput(taskName, data),
            writeError: (data) => this._writeTaskOutput(taskName, data, ITaskOutputStream.stderr),
            writeLine: (data) => this._writeTaskOutput(taskName, data + os.EOL)
        };
    }
    /**
     * Removes information about all running tasks
     */
    static reset() {
        this._activeTask = undefined;
        this._tasks = new Map();
    }
    /**
     * Adds the text to the task's buffer, and writes it to the console if it is the active task
     */
    static _writeTaskOutput(taskName, data, stream = ITaskOutputStream.stdout) {
        const taskInfo = this._tasks.get(taskName);
        if (!taskInfo || taskInfo.state !== TaskWriterState.Open) {
            throw new Error('The task is not registered or has been completed and written.');
        }
        const outputBuffer = (stream === ITaskOutputStream.stderr ? taskInfo.stderr : taskInfo.stdout);
        if (!this._activeTask) {
            this._activeTask = taskName;
            this._writeTask(taskName, taskInfo);
            taskInfo.state = TaskWriterState.Open;
        }
        outputBuffer.push(data);
        if (this._activeTask === taskName) {
            if (stream === ITaskOutputStream.stdout && !taskInfo.quietMode) {
                this._stdout.write(data);
            }
            else if (stream === ITaskOutputStream.stderr) {
                this._stdout.write(data);
            }
        }
    }
    /**
     * Returns the current value of the task's buffer
     */
    static _getTaskOutput(taskName, stream = ITaskOutputStream.stdout) {
        const taskInfo = this._tasks.get(taskName);
        return (stream === ITaskOutputStream.stdout ? taskInfo.stdout : taskInfo.stderr).join('');
    }
    /**
     * Marks a task as completed. There are 3 cases:
     *  - If the task was the active task, also write out all completed, unwritten tasks
     *  - If there is no active task, write the output to the screen
     *  - If there is an active task, mark the task as completed and wait for active task to complete
     */
    static _completeTask(taskName) {
        const taskInfo = this._tasks.get(taskName);
        if (!taskInfo || taskInfo.state !== TaskWriterState.Open) {
            throw new Error('The task is not registered or has been completed and written.');
        }
        if (this._activeTask === undefined) {
            this._writeTask(taskName, taskInfo);
        }
        else if (taskName === this._activeTask) {
            this._activeTask = undefined;
            taskInfo.state = TaskWriterState.Written;
            this._writeAllCompletedTasks();
        }
        else {
            taskInfo.state = TaskWriterState.ClosedUnwritten;
        }
    }
    /**
     * Helper function which writes all completed tasks
     */
    static _writeAllCompletedTasks() {
        this._tasks.forEach((task, taskName) => {
            if (task && task.state === TaskWriterState.ClosedUnwritten) {
                this._writeTask(taskName, task);
            }
        });
    }
    /**
     * Write and delete task
     */
    static _writeTask(taskName, taskInfo) {
        taskInfo.state = TaskWriterState.Written;
        if (!taskInfo.quietMode) {
            this._stdout.write(taskInfo.stdout.join(''));
        }
        this._stdout.write(colors.red(taskInfo.stderr.join('')));
    }
}
Interleaver._tasks = new Map();
Interleaver._activeTask = undefined;
Interleaver._stdout = process.stdout;
exports.Interleaver = Interleaver;
//# sourceMappingURL=Interleaver.js.map