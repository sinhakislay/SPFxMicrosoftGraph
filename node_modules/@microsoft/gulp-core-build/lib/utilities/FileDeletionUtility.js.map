{"version":3,"file":"FileDeletionUtility.js","sourceRoot":"","sources":["../../src/utilities/FileDeletionUtility.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;AAE3D,6BAA6B;AAC7B,0CAA2C;AAC3C,iCAAkC;AAElC,4BAA4B;AAC5B,MAAM,GAAG,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC;AAC3B,4BAA4B;AAE5B,MAAa,mBAAmB;IACvB,MAAM,CAAC,cAAc,CAAC,QAAkB;QAC7C,MAAM,KAAK,GAAa,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC9C,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;IAC1B,CAAC;IAEM,MAAM,CAAC,WAAW,CAAC,KAAe;QACvC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC7D,CAAC;IAEM,MAAM,CAAC,eAAe,CAAC,KAAe;QAC3C,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC,IAAY,EAAE,EAAE;YAChC,OAAO,UAAU,CAAC,IAAI,CAAC,CAAC;QAC1B,CAAC,CAAC,CAAC;IACL,CAAC;IAEM,MAAM,CAAC,cAAc,CAAC,SAAmB;QAC9C,iDAAiD;QACjD,mEAAmE;QACnE,iEAAiE;QACjE,iEAAiE;QACjE,iEAAiE;QACjE,2BAA2B;QAE3B,wEAAwE;QACxE,kEAAkE;QAClE,SAAS,CAAC,IAAI,EAAE,CAAC;QAEjB,qFAAqF;QACrF,0BAA0B;QAC1B,MAAM,aAAa,GAAa,EAAE,CAAC;QAEnC,4BAA4B;QAC5B,IAAI,aAAa,GAAuB,SAAS,CAAC;QAElD,KAAK,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACjD,MAAM,OAAO,GAAW,SAAS,CAAC,CAAC,CAAC,CAAC;YACrC,IAAI,IAAI,CAAC,iBAAiB,CAAC,aAAa,EAAE,OAAO,CAAC,EAAE;gBAClD,SAAS;aACV;iBAAM;gBACL,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAC5B,aAAa,GAAG,OAAO,CAAC;aACzB;SACF;QACD,OAAO,aAAa,CAAC;IACvB,CAAC;IAEM,MAAM,CAAC,iBAAiB,CAAC,SAA6B,EAAE,QAA4B;QACzF,IAAI,CAAC,SAAS,IAAI,CAAC,QAAQ,EAAE;YAC3B,OAAO,KAAK,CAAC;SACd;QAED,MAAM,cAAc,GAAa,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACzE,MAAM,SAAS,GAAa,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAEnE,IAAI,cAAc,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;YACpD,6CAA6C;YAC7C,cAAc,CAAC,GAAG,EAAE,CAAC;SACtB;QAED,IAAI,cAAc,CAAC,MAAM,IAAI,SAAS,CAAC,MAAM,EAAE;YAC7C,OAAO,KAAK,CAAC;SACd;QAED,KAAK,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACtD,IAAI,cAAc,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC,EAAE;gBACtC,OAAO,KAAK,CAAC;aACd;SACF;QACD,OAAO,IAAI,CAAC;IACd,CAAC;CACF;AAvED,kDAuEC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport globEscape = require('glob-escape');\r\nimport globby = require('globby');\r\n\r\n/* tslint:disable:typedef */\r\nconst del = require('del');\r\n/* tslint:disable:typedef */\r\n\r\nexport class FileDeletionUtility {\r\n  public static deletePatterns(patterns: string[]) {\r\n    const files: string[] = globby.sync(patterns);\r\n    this.deleteFiles(files);\r\n  }\r\n\r\n  public static deleteFiles(files: string[]) {\r\n    del.sync(this.escapeFilePaths(this.removeChildren(files)));\r\n  }\r\n\r\n  public static escapeFilePaths(files: string[]): string[] {\r\n    return files.map((file: string) => {\r\n      return globEscape(file);\r\n    });\r\n  }\r\n\r\n  public static removeChildren(filenames: string[]): string[] {\r\n    // Appears to be a known issue with `del` whereby\r\n    // if you ask to delete both a folder, and something in the folder,\r\n    // it randomly chooses which one to delete first, which can cause\r\n    // the function to fail sporadically. The fix for this is simple:\r\n    // we need to remove any cleanPaths which exist under a folder we\r\n    // are attempting to delete\r\n\r\n    // First we sort the list of files. We know that if something is a file,\r\n    // if matched, the parent folder should appear earlier in the list\r\n    filenames.sort();\r\n\r\n    // We need to determine which paths exist under other paths, and remove them from the\r\n    // list of files to delete\r\n    const filesToDelete: string[] = [];\r\n\r\n    // current working directory\r\n    let currentParent: string | undefined = undefined;\r\n\r\n    for (let i: number = 0; i < filenames.length; i++) {\r\n      const curFile: string = filenames[i];\r\n      if (this.isParentDirectory(currentParent, curFile)) {\r\n        continue;\r\n      } else {\r\n        filesToDelete.push(curFile);\r\n        currentParent = curFile;\r\n      }\r\n    }\r\n    return filesToDelete;\r\n  }\r\n\r\n  public static isParentDirectory(directory: string | undefined, filePath: string | undefined): boolean {\r\n    if (!directory || !filePath) {\r\n      return false;\r\n    }\r\n\r\n    const directoryParts: string[] = path.resolve(directory).split(path.sep);\r\n    const fileParts: string[] = path.resolve(filePath).split(path.sep);\r\n\r\n    if (directoryParts[directoryParts.length - 1] === '') {\r\n      // this is to fix an issue with windows roots\r\n      directoryParts.pop();\r\n    }\r\n\r\n    if (directoryParts.length >= fileParts.length) {\r\n      return false;\r\n    }\r\n\r\n    for (let i: number = 0; i < directoryParts.length; i++) {\r\n      if (directoryParts[i] !== fileParts[i]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}"]}