"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tsutils_1 = require("tsutils");
const ts = require("typescript");
const Lint = require("tslint");
/**
 * Matches parts of the webpack import(...) meta-comment that look like these examples:
 *  - propertyName:'value'
 *  - propertyName: 'value'
 *  - propertyName:"value"
 *  - propertyName: "value"
 *  - propertyName :'value'
 *  - propertyName : 'value'
 *  - propertyName :"value"
 *  - propertyName : "value"
 */
const COMMENT_PART_REGEX = /^([A-Za-z]+)\s*:\s*('[^']+'|"[^"]+")$/;
/**
 * This rule requires that import(...) statements include a /* webpackChunkName: '...' *\/ comment.
 *
 * See documentation here: https://webpack.js.org/api/module-methods/#import-
 */
class Rule extends Lint.Rules.AbstractRule {
    apply(sourceFile) {
        return this.applyWithFunction(sourceFile, (ctx) => {
            const childCallback = (node) => {
                if (tsutils_1.isCallExpression(node) &&
                    node.expression.kind === ts.SyntaxKind.ImportKeyword &&
                    node.getChildCount() >= 4 // 4+ children: keyword, openParen, args..., closeParen
                ) {
                    // In an import(...) expression
                    const comments = [];
                    tsutils_1.forEachComment(node, (text, comment) => {
                        comments.push(text.substring(comment.pos, comment.end));
                    });
                    let webpackChunkNameTokensFound = 0;
                    for (const rawComment of comments) {
                        let comment = rawComment.trim();
                        if (comment.indexOf('//') === 0) {
                            comment = comment.substr(2);
                        }
                        else if (comment.indexOf('/*') === 0 && comment.indexOf('*/') === comment.length - 2) {
                            comment = comment.substring(2, comment.length - 2);
                        }
                        const commentParts = comment.split(',');
                        for (let commentPart of commentParts) {
                            commentPart = commentPart.trim();
                            const commentRegexResult = commentPart.match(COMMENT_PART_REGEX);
                            if (commentRegexResult && commentRegexResult[1] === 'webpackChunkName') {
                                webpackChunkNameTokensFound++;
                            }
                        }
                    }
                    if (webpackChunkNameTokensFound === 0) {
                        ctx.addFailureAtNode(node.expression, 'Calls to "import" must include a /* webpackChunkName: \'name\' */ comment');
                    }
                    else if (webpackChunkNameTokensFound !== 1) {
                        ctx.addFailureAtNode(node.expression, 'Calls to "import" must include only one /* webpackChunkName: \'name\' */ comment');
                    }
                }
                return ts.forEachChild(node, childCallback);
            };
            return ts.forEachChild(ctx.sourceFile, childCallback);
        });
    }
}
Rule.metadata = {
    ruleName: 'import-requires-chunk-name',
    description: 'Requires that calls to import(...) for code splitting include a webpack chunk name',
    rationale: 'Unnamed chunks are difficult to manage.',
    optionsDescription: 'No options available.',
    options: {},
    type: 'functionality',
    typescriptOnly: false
};
exports.Rule = Rule;
//# sourceMappingURL=importRequiresChunkNameRule.js.map