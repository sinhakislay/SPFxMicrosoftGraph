"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tsUtils = require("tsutils");
const ts = require("typescript");
const Lint = require("tslint");
class Rule extends Lint.Rules.AbstractRule {
    apply(sourceFile) {
        return this.applyWithFunction(sourceFile, this.walk.bind(this));
    }
    walk(ctx) {
        const renderCalls = [];
        const unmountCalls = [];
        // Do not convert `callback` to a function. It references `this` keyword inside it.
        const callback = (node) => {
            const reactDOMImportNamespaceName = this.getReactDOMImportNamespaceName(node);
            if (reactDOMImportNamespaceName) {
                this.reactDOMImportNamespaceName = reactDOMImportNamespaceName;
                return;
            }
            const isRenderCallExpression = this.isReactDOMCallExpression(node, 'render');
            if (isRenderCallExpression) {
                renderCalls.push(node);
                return;
            }
            const isUnmountCallExpression = this.isReactDOMCallExpression(node, 'unmountComponentAtNode');
            if (isUnmountCallExpression) {
                unmountCalls.push(node);
                return;
            }
            ts.forEachChild(node, callback);
        };
        ts.forEachChild(ctx.sourceFile, callback);
        // Verify the count of render calls and unmount calls are the same in the file.
        if (renderCalls.length !== unmountCalls.length) {
            renderCalls.concat(unmountCalls).forEach(renderCallExpression => {
                ctx.addFailureAtNode(renderCallExpression, 'Unmatched calls between `ReactDOM.render` and `ReactDOM.unmountComponentAtNode`.');
            });
        }
    }
    getReactDOMImportNamespaceName(node) {
        if (
        // import * as ReactDOM from 'react-dom'
        tsUtils.isImportDeclaration(node) &&
            // * as ReactDOM
            node.importClause && tsUtils.isImportClause(node.importClause) &&
            // ReactDOM
            node.importClause.namedBindings && tsUtils.isNamespaceImport(node.importClause.namedBindings) &&
            // 'react-dom'
            tsUtils.isStringLiteral(node.moduleSpecifier) && node.moduleSpecifier.text === 'react-dom') {
            return node.importClause.namedBindings.name.text;
        }
        else {
            return undefined;
        }
    }
    isReactDOMCallExpression(node, methodName) {
        return (
        // ReactDOM.method(param1, param2)
        tsUtils.isCallExpression(node) &&
            // ReactDOM.method
            tsUtils.isPropertyAccessExpression(node.expression) &&
            // ReactDOM
            tsUtils.isIdentifier(node.expression.expression) && node.expression.expression.text === this.reactDOMImportNamespaceName && // tslint:disable-line:max-line-length
            // method
            tsUtils.isIdentifier(node.expression.name) && node.expression.name.text === methodName);
    }
}
Rule.metadata = {
    ruleName: 'pair-react-dom-render-unmount',
    description: 'Pair ReactDOM render and unmount calls in one file.'
        + ' If a ReactDOM render tree is not unmounted when disposed, it will cause a memory leak.',
    rationale: 'Pair the render and unmount calls to avoid memory leak.',
    optionsDescription: 'No options available.',
    options: {},
    type: 'maintainability',
    typescriptOnly: false
};
exports.Rule = Rule;
//# sourceMappingURL=pairReactDomRenderUnmountRule.js.map