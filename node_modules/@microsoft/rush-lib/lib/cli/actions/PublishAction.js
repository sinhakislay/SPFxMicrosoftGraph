"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const os_1 = require("os");
const path = require("path");
const node_core_library_1 = require("@microsoft/node-core-library");
const ChangeManagement_1 = require("../../api/ChangeManagement");
const Npm_1 = require("../../utilities/Npm");
const PublishUtilities_1 = require("../../logic/PublishUtilities");
const ChangelogGenerator_1 = require("../../logic/ChangelogGenerator");
const PrereleaseToken_1 = require("../../logic/PrereleaseToken");
const ChangeManager_1 = require("../../logic/ChangeManager");
const BaseRushAction_1 = require("./BaseRushAction");
const PublishGit_1 = require("../../logic/PublishGit");
const VersionControl_1 = require("../../utilities/VersionControl");
const PolicyValidator_1 = require("../../logic/policy/PolicyValidator");
const VersionAction_1 = require("./VersionAction");
class PublishAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'publish',
            summary: 'Reads and processes package publishing change requests generated by "rush change".',
            documentation: 'Reads and processes package publishing change requests generated by "rush change". This will perform a ' +
                'read-only operation by default, printing operations executed to the console. To commit ' +
                'changes and publish packages, you must use the --commit flag and/or the --publish flag.',
            parser
        });
    }
    onDefineParameters() {
        this._apply = this.defineFlagParameter({
            parameterLongName: '--apply',
            parameterShortName: '-a',
            description: 'If this flag is specified, the change requests will be applied to package.json files.'
        });
        this._targetBranch = this.defineStringParameter({
            parameterLongName: '--target-branch',
            parameterShortName: '-b',
            argumentName: 'BRANCH',
            description: 'If this flag is specified, applied changes and deleted change requests will be' +
                'committed and merged into the target branch.'
        });
        this._publish = this.defineFlagParameter({
            parameterLongName: '--publish',
            parameterShortName: '-p',
            description: 'If this flag is specified, applied changes will be published to npm.'
        });
        this._addCommitDetails = this.defineFlagParameter({
            parameterLongName: '--add-commit-details',
            parameterShortName: undefined,
            description: 'Adds commit author and hash to the changelog.json files for each change.'
        });
        this._regenerateChangelogs = this.defineFlagParameter({
            parameterLongName: '--regenerate-changelogs',
            parameterShortName: undefined,
            description: 'Regenerates all changelog files based on the current JSON content.'
        });
        // NPM registry related parameters
        this._registryUrl = this.defineStringParameter({
            parameterLongName: '--registry',
            parameterShortName: '-r',
            argumentName: 'REGISTRY',
            description: `Publishes to a specified NPM registry. If this is specified, it will prevent the current commit will not be ` +
                'tagged.'
        });
        this._npmAuthToken = this.defineStringParameter({
            parameterLongName: '--npm-auth-token',
            parameterShortName: '-n',
            argumentName: 'TOKEN',
            description: 'Provide the default scope NPM auth token to be passed into npm publish for global package publishing.'
        });
        this._npmTag = this.defineStringParameter({
            parameterLongName: '--tag',
            parameterShortName: '-t',
            argumentName: 'TAG',
            description: `The tag option to pass to npm publish. By default NPM will publish using the 'latest' tag, even if ` +
                `the package is older than the current latest, so in publishing workflows for older releases, providing ` +
                `a tag is important. When hotfix changes are made, this parameter defaults to 'hotfix'.`
        });
        this._npmAccessLevel = this.defineChoiceParameter({
            alternatives: ['public', 'restricted'],
            parameterLongName: '--set-access-level',
            parameterShortName: undefined,
            description: `By default, when Rush invokes "npm publish" it will publish scoped packages with an access level ` +
                `of "restricted". Scoped packages can be published with an access level of "public" by specifying ` +
                `that value for this flag with the initial publication. NPM always publishes unscoped packages with ` +
                `an access level of "public". For more information, see the NPM documentation for the "--access" ` +
                `option of "npm publish".`
        });
        // NPM pack tarball related parameters
        this._pack = this.defineFlagParameter({
            parameterLongName: '--pack',
            description: `Packs projects into tarballs instead of publishing to npm repository. It can only be used when ` +
                `--include-all is specified. If this flag is specified, NPM registry related parameters will be ignored.`
        });
        this._releaseFolder = this.defineStringParameter({
            parameterLongName: '--release-folder',
            argumentName: 'FOLDER',
            description: `This parameter is used with --pack parameter to provide customized location for the tarballs instead of ` +
                `the default value. `
        });
        // End of NPM pack tarball related parameters
        this._includeAll = this.defineFlagParameter({
            parameterLongName: '--include-all',
            parameterShortName: undefined,
            description: 'If this flag is specified, all packages with shouldPublish=true in rush.json ' +
                'or with a specified version policy ' +
                'will be published if their version is newer than published version.'
        });
        this._versionPolicy = this.defineStringParameter({
            parameterLongName: '--version-policy',
            argumentName: 'POLICY',
            description: 'Version policy name. Only projects with this version policy will be published if used ' +
                'with --include-all.'
        });
        this._prereleaseName = this.defineStringParameter({
            parameterLongName: '--prerelease-name',
            argumentName: 'NAME',
            description: 'Bump up to a prerelease version with the provided prerelease name. Cannot be used with --suffix'
        });
        this._partialPrerelease = this.defineFlagParameter({
            parameterLongName: '--partial-prerelease',
            parameterShortName: undefined,
            description: 'Used with --prerelease-name. Only bump packages to a prerelease version if they have changes.'
        });
        this._suffix = this.defineStringParameter({
            parameterLongName: '--suffix',
            argumentName: 'SUFFIX',
            description: 'Append a suffix to all changed versions. Cannot be used with --prerelease-name.'
        });
        this._force = this.defineFlagParameter({
            parameterLongName: '--force',
            parameterShortName: undefined,
            description: 'If this flag is specified with --publish, packages will be published with --force on npm'
        });
        this._applyGitTagsOnPack = this.defineFlagParameter({
            parameterLongName: '--apply-git-tags-on-pack',
            description: `If specified with --publish and --pack, git tags will be applied for packages` +
                ` as if a publish was being run without --pack.`
        });
    }
    /**
     * Executes the publish action, which will read change request files, apply changes to package.jsons,
     */
    run() {
        return Promise.resolve().then(() => {
            PolicyValidator_1.PolicyValidator.validatePolicy(this.rushConfiguration, false);
            const allPackages = this.rushConfiguration.projectsByName;
            if (this._regenerateChangelogs.value) {
                console.log('Regenerating changelogs');
                ChangelogGenerator_1.ChangelogGenerator.regenerateChangelogs(allPackages, this.rushConfiguration);
                return Promise.resolve();
            }
            this._validate();
            if (this._includeAll.value) {
                this._publishAll(allPackages);
            }
            else {
                this._prereleaseToken = new PrereleaseToken_1.PrereleaseToken(this._prereleaseName.value, this._suffix.value, this._partialPrerelease.value);
                this._publishChanges(allPackages);
            }
            console.log(os_1.EOL + colors.green('Rush publish finished successfully.'));
        });
    }
    /**
     * Validate some input parameters
     */
    _validate() {
        if (this._pack.value && !this._includeAll.value) {
            throw new Error('--pack can only be used with --include-all');
        }
        if (this._releaseFolder.value && !this._pack.value) {
            throw new Error(`--release-folder can only be used with --pack`);
        }
        if (this._registryUrl.value && this._pack.value) {
            throw new Error(`--registry cannot be used with --pack`);
        }
        if (this._applyGitTagsOnPack.value && !this._pack.value) {
            throw new Error(`${this._applyGitTagsOnPack.longName} must be used `
                + `with ${this._pack.longName}`);
        }
    }
    _publishChanges(allPackages) {
        const changeManager = new ChangeManager_1.ChangeManager(this.rushConfiguration);
        changeManager.load(this.rushConfiguration.changesFolder, this._prereleaseToken, this._addCommitDetails.value);
        if (changeManager.hasChanges()) {
            const orderedChanges = changeManager.changes;
            const git = new PublishGit_1.PublishGit(this._targetBranch.value);
            const tempBranch = 'publish-' + new Date().getTime();
            // Make changes in temp branch.
            git.checkout(tempBranch, true);
            this._setDependenciesBeforePublish();
            // Make changes to package.json and change logs.
            changeManager.apply(this._apply.value);
            changeManager.updateChangelog(this._apply.value);
            this._setDependenciesBeforeCommit();
            if (VersionControl_1.VersionControl.hasUncommittedChanges()) {
                // Stage, commit, and push the changes to remote temp branch.
                git.addChanges(':/*');
                git.commit(this.rushConfiguration.gitVersionBumpCommitMessage || VersionAction_1.DEFAULT_PACKAGE_UPDATE_MESSAGE);
                git.push(tempBranch);
                this._setDependenciesBeforePublish();
                // Override tag parameter if there is a hotfix change.
                for (const change of orderedChanges) {
                    if (change.changeType === ChangeManagement_1.ChangeType.hotfix) {
                        this._hotfixTagOverride = 'hotfix';
                        break;
                    }
                }
                // npm publish the things that need publishing.
                for (const change of orderedChanges) {
                    if (change.changeType && change.changeType > ChangeManagement_1.ChangeType.dependency) {
                        const project = allPackages.get(change.packageName);
                        if (project) {
                            if (!this._packageExists(project)) {
                                this._npmPublish(change.packageName, project.projectFolder);
                            }
                            else {
                                console.log(`Skip ${change.packageName}. Package exists.`);
                            }
                        }
                        else {
                            console.log(`Skip ${change.packageName}. Failed to find its project.`);
                        }
                    }
                }
                this._setDependenciesBeforeCommit();
                // Create and push appropriate Git tags.
                this._gitAddTags(git, orderedChanges);
                git.push(tempBranch);
                // Now merge to target branch.
                git.checkout(this._targetBranch.value);
                git.pull();
                git.merge(tempBranch);
                git.push(this._targetBranch.value);
                git.deleteBranch(tempBranch);
            }
            else {
                git.checkout(this._targetBranch.value);
                git.deleteBranch(tempBranch, false);
            }
        }
    }
    _publishAll(allPackages) {
        console.log(`Rush publish starts with includeAll and version policy ${this._versionPolicy.value}`);
        let updated = false;
        const git = new PublishGit_1.PublishGit(this._targetBranch.value);
        allPackages.forEach((packageConfig, packageName) => {
            if (packageConfig.shouldPublish &&
                (!this._versionPolicy.value || this._versionPolicy.value === packageConfig.versionPolicyName)) {
                const applyTag = (apply) => {
                    if (!apply) {
                        return;
                    }
                    // Do not tag packages that already exist. This will fail with a fatal error.
                    if (this._packageExists(packageConfig)) {
                        return;
                    }
                    git.addTag(!!this._publish.value && !this._registryUrl.value, packageName, packageConfig.packageJson.version);
                    updated = true;
                };
                if (this._pack.value) {
                    // packs to tarball instead of publishing to NPM repository
                    this._npmPack(packageName, packageConfig);
                    applyTag(this._applyGitTagsOnPack.value);
                }
                else if (this._force.value || !this._packageExists(packageConfig)) {
                    // Publish to npm repository
                    this._npmPublish(packageName, packageConfig.projectFolder);
                    applyTag(true);
                }
                else {
                    console.log(`Skip ${packageName}. Not updated.`);
                }
            }
        });
        if (updated) {
            git.push(this._targetBranch.value);
        }
    }
    _gitAddTags(git, orderedChanges) {
        for (const change of orderedChanges) {
            if (change.changeType &&
                change.changeType > ChangeManagement_1.ChangeType.dependency &&
                this.rushConfiguration.projectsByName.get(change.packageName).shouldPublish) {
                git.addTag(!!this._publish.value && !this._registryUrl.value, change.packageName, change.newVersion);
            }
        }
    }
    _npmPublish(packageName, packagePath) {
        const env = PublishUtilities_1.PublishUtilities.getEnvArgs();
        const args = ['publish'];
        if (this.rushConfiguration.projectsByName.get(packageName).shouldPublish) {
            this._addSharedNpmConfig(env, args);
            if (this._npmTag.value) {
                args.push(`--tag`, this._npmTag.value);
            }
            else if (this._hotfixTagOverride) {
                args.push(`--tag`, this._hotfixTagOverride);
            }
            if (this._force.value) {
                args.push(`--force`);
            }
            if (this._npmAccessLevel.value) {
                args.push(`--access`, this._npmAccessLevel.value);
            }
            // TODO: Yarn's "publish" command line is fairly different from NPM and PNPM.  The right thing to do here
            // would be to remap our options to the Yarn equivalents.  But until we get around to that, we'll simply invoke
            // whatever NPM binary happens to be installed in the global path.
            const packageManagerToolFilename = this.rushConfiguration.packageManager === 'yarn'
                ? 'npm' : this.rushConfiguration.packageManagerToolFilename;
            PublishUtilities_1.PublishUtilities.execCommand(!!this._publish.value, packageManagerToolFilename, args, packagePath, env);
        }
    }
    _packageExists(packageConfig) {
        const env = PublishUtilities_1.PublishUtilities.getEnvArgs();
        const args = [];
        this._addSharedNpmConfig(env, args);
        const publishedVersions = Npm_1.Npm.publishedVersions(packageConfig.packageName, packageConfig.projectFolder, env, args);
        return publishedVersions.indexOf(packageConfig.packageJson.version) >= 0;
    }
    _npmPack(packageName, project) {
        const args = ['pack'];
        const env = PublishUtilities_1.PublishUtilities.getEnvArgs();
        PublishUtilities_1.PublishUtilities.execCommand(!!this._publish.value, this.rushConfiguration.packageManagerToolFilename, args, project.projectFolder, env);
        if (!!this._publish.value) {
            // Copy the tarball the release folder
            const tarballName = this._calculateTarballName(project);
            const tarballPath = path.join(project.projectFolder, tarballName);
            const destFolder = this._releaseFolder.value ?
                this._releaseFolder.value : path.join(this.rushConfiguration.commonTempFolder, 'artifacts', 'packages');
            node_core_library_1.FileSystem.move({
                sourcePath: tarballPath,
                destinationPath: path.join(destFolder, tarballName),
                overwrite: true
            });
        }
    }
    _calculateTarballName(project) {
        // Same logic as how npm forms the tarball name
        const packageName = project.packageName;
        const name = packageName[0] === '@' ? packageName.substr(1).replace(/\//g, '-') : packageName;
        if (this.rushConfiguration.packageManager === 'yarn') {
            // yarn tarballs have a "v" before the version number
            return `${name}-v${project.packageJson.version}.tgz`;
        }
        else {
            return `${name}-${project.packageJson.version}.tgz`;
        }
    }
    _setDependenciesBeforePublish() {
        for (const project of this.rushConfiguration.projects) {
            if (!this._versionPolicy.value || this._versionPolicy.value === project.versionPolicyName) {
                const versionPolicy = project.versionPolicy;
                if (versionPolicy) {
                    versionPolicy.setDependenciesBeforePublish(project.packageName, this.rushConfiguration);
                }
            }
        }
    }
    _setDependenciesBeforeCommit() {
        for (const project of this.rushConfiguration.projects) {
            if (!this._versionPolicy.value || this._versionPolicy.value === project.versionPolicyName) {
                const versionPolicy = project.versionPolicy;
                if (versionPolicy) {
                    versionPolicy.setDependenciesBeforePublish(project.packageName, this.rushConfiguration);
                }
            }
        }
    }
    _addSharedNpmConfig(env, args) {
        let registry = '//registry.npmjs.org/';
        if (this._registryUrl.value) {
            const registryUrl = this._registryUrl.value;
            env['npm_config_registry'] = registryUrl; // tslint:disable-line:no-string-literal
            registry = registryUrl.substring(registryUrl.indexOf('//'));
        }
        if (this._npmAuthToken.value) {
            args.push(`--${registry}:_authToken=${this._npmAuthToken.value}`);
        }
    }
}
exports.PublishAction = PublishAction;
//# sourceMappingURL=PublishAction.js.map