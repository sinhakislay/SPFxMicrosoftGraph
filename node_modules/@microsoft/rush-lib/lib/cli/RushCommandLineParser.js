"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const os = require("os");
const path = require("path");
const ts_command_line_1 = require("@microsoft/ts-command-line");
const node_core_library_1 = require("@microsoft/node-core-library");
const RushConfiguration_1 = require("../api/RushConfiguration");
const RushConstants_1 = require("../logic/RushConstants");
const CommandLineConfiguration_1 = require("../api/CommandLineConfiguration");
const Utilities_1 = require("../utilities/Utilities");
const BaseScriptAction_1 = require("../cli/scriptActions/BaseScriptAction");
const AddAction_1 = require("./actions/AddAction");
const ChangeAction_1 = require("./actions/ChangeAction");
const CheckAction_1 = require("./actions/CheckAction");
const UpdateAction_1 = require("./actions/UpdateAction");
const InstallAction_1 = require("./actions/InstallAction");
const InitAction_1 = require("./actions/InitAction");
const LinkAction_1 = require("./actions/LinkAction");
const ListAction_1 = require("./actions/ListAction");
const PublishAction_1 = require("./actions/PublishAction");
const PurgeAction_1 = require("./actions/PurgeAction");
const UnlinkAction_1 = require("./actions/UnlinkAction");
const ScanAction_1 = require("./actions/ScanAction");
const VersionAction_1 = require("./actions/VersionAction");
const BulkScriptAction_1 = require("./scriptActions/BulkScriptAction");
const GlobalScriptAction_1 = require("./scriptActions/GlobalScriptAction");
const Telemetry_1 = require("../logic/Telemetry");
const AlreadyReportedError_1 = require("../utilities/AlreadyReportedError");
const RushGlobalFolder_1 = require("../api/RushGlobalFolder");
const NodeJsCompatibility_1 = require("../logic/NodeJsCompatibility");
class RushCommandLineParser extends ts_command_line_1.CommandLineParser {
    constructor(options) {
        super({
            toolFilename: 'rush',
            toolDescription: 'Rush makes life easier for JavaScript developers who develop, build, and publish'
                + ' many packages from a central Git repo.  It is designed to handle very large repositories'
                + ' supporting many projects and people.  Rush provides policies, protections, and customizations'
                + ' that help coordinate teams and safely onboard new contributors.  Rush also generates change logs'
                + ' and automates package publishing.  It can manage decoupled subsets of projects with different'
                + ' release and versioning strategies.  A full API is included to facilitate integration with other'
                + ' automation tools.  If you are looking for a proven turnkey solution for monorepo management,'
                + ' Rush is for you.'
        });
        this._rushOptions = this._normalizeOptions(options || {});
        try {
            const rushJsonFilename = RushConfiguration_1.RushConfiguration.tryFindRushJsonLocation({
                startingFolder: this._rushOptions.cwd,
                showVerbose: true
            });
            if (rushJsonFilename) {
                this.rushConfiguration = RushConfiguration_1.RushConfiguration.loadFromConfigurationFile(rushJsonFilename);
            }
        }
        catch (error) {
            this._reportErrorAndSetExitCode(error);
        }
        NodeJsCompatibility_1.NodeJsCompatibility.warnAboutCompatibilityIssues({
            isRushLib: true,
            alreadyReportedNodeTooNewError: this._rushOptions.alreadyReportedNodeTooNewError,
            rushConfiguration: this.rushConfiguration
        });
        this._populateActions();
    }
    get isDebug() {
        return this._debugParameter.value;
    }
    flushTelemetry() {
        if (this.telemetry) {
            this.telemetry.flush();
        }
    }
    onDefineParameters() {
        this._debugParameter = this.defineFlagParameter({
            parameterLongName: '--debug',
            parameterShortName: '-d',
            description: 'Show the full call stack if an error occurs while executing the tool'
        });
    }
    onExecute() {
        // Defensively set the exit code to 1 so if Rush crashes for whatever reason, we'll have a nonzero exit code.
        // For example, Node.js currently has the inexcusable design of terminating with zero exit code when
        // there is an uncaught promise exception.  This will supposedly be fixed in Node.js 9.
        // Ideally we should do this for all the Rush actions, but "rush build" is the most critical one
        // -- if it falsely appears to succeed, we could merge bad PRs, publish empty packages, etc.
        process.exitCode = 1;
        if (this._debugParameter.value) {
            node_core_library_1.InternalError.breakInDebugger = true;
        }
        return this._wrapOnExecute().catch((error) => {
            this._reportErrorAndSetExitCode(error);
        }).then(() => {
            // If we make it here, everything went fine, so reset the exit code back to 0
            process.exitCode = 0;
        });
    }
    _normalizeOptions(options) {
        return {
            cwd: options.cwd || process.cwd(),
            alreadyReportedNodeTooNewError: options.alreadyReportedNodeTooNewError || false
        };
    }
    _wrapOnExecute() {
        try {
            if (this.rushConfiguration) {
                this.telemetry = new Telemetry_1.Telemetry(this.rushConfiguration);
            }
            return super.onExecute().then(() => {
                if (this.telemetry) {
                    this.flushTelemetry();
                }
            });
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    _populateActions() {
        try {
            this.rushGlobalFolder = new RushGlobalFolder_1.RushGlobalFolder();
            this.addAction(new AddAction_1.AddAction(this));
            this.addAction(new ChangeAction_1.ChangeAction(this));
            this.addAction(new CheckAction_1.CheckAction(this));
            this.addAction(new InstallAction_1.InstallAction(this));
            this.addAction(new InitAction_1.InitAction(this));
            this.addAction(new LinkAction_1.LinkAction(this));
            this.addAction(new ListAction_1.ListAction(this));
            this.addAction(new PublishAction_1.PublishAction(this));
            this.addAction(new PurgeAction_1.PurgeAction(this));
            this.addAction(new ScanAction_1.ScanAction(this));
            this.addAction(new UpdateAction_1.UpdateAction(this));
            this.addAction(new UnlinkAction_1.UnlinkAction(this));
            this.addAction(new VersionAction_1.VersionAction(this));
            this._populateScriptActions();
        }
        catch (error) {
            this._reportErrorAndSetExitCode(error);
        }
    }
    _populateScriptActions() {
        let commandLineConfiguration = undefined;
        // If there is not a rush.json file, we still want "build" and "rebuild" to appear in the
        // command-line help
        if (this.rushConfiguration) {
            const commandLineConfigFile = path.join(this.rushConfiguration.commonRushConfigFolder, RushConstants_1.RushConstants.commandLineFilename);
            commandLineConfiguration = CommandLineConfiguration_1.CommandLineConfiguration.loadFromFileOrDefault(commandLineConfigFile);
        }
        // Build actions from the command line configuration supercede default build actions.
        this._addCommandLineConfigActions(commandLineConfiguration);
        this._addDefaultBuildActions(commandLineConfiguration);
        this._validateCommandLineConfigParameterAssociations(commandLineConfiguration);
    }
    _addDefaultBuildActions(commandLineConfiguration) {
        if (!this.tryGetAction('build')) {
            // always create a build and a rebuild command
            this.addAction(new BulkScriptAction_1.BulkScriptAction({
                actionName: 'build',
                summary: '(EXPERIMENTAL) Build all projects that haven\'t been built, or have changed since they were last '
                    + 'built.',
                documentation: 'This command is similar to "rush rebuild", except that "rush build" performs'
                    + ' an incremental build. In other words, it only builds projects whose source files have changed'
                    + ' since the last successful build. The analysis requires a Git working tree, and only considers'
                    + ' source files that are tracked by Git and whose path is under the project folder. (For more details'
                    + ' about this algorithm, see the documentation for the "package-deps-hash" NPM package.) The incremental'
                    + ' build state is tracked in a per-project folder called ".rush/temp" which should NOT be added to Git. The'
                    + ' build command is tracked by the "arguments" field in the "package-deps_build.json" file contained'
                    + ' therein; a full rebuild is forced whenever the command has changed (e.g. "--production" or not).',
                parser: this,
                commandLineConfiguration: commandLineConfiguration,
                enableParallelism: true,
                ignoreMissingScript: false,
                ignoreDependencyOrder: false,
                incremental: true,
                allowWarningsInSuccessfulBuild: false
            }));
        }
        if (!this.tryGetAction('rebuild')) {
            this.addAction(new BulkScriptAction_1.BulkScriptAction({
                actionName: 'rebuild',
                // To remain compatible with existing repos, `rebuild` defaults to calling the `build` command in each repo.
                commandToRun: 'build',
                summary: 'Clean and rebuild the entire set of projects',
                documentation: 'This command assumes that the package.json file for each project contains'
                    + ' a "scripts" entry for "npm run build" that performs a full clean build.'
                    + ' Rush invokes this script to build each project that is registered in rush.json.'
                    + ' Projects are built in parallel where possible, but always respecting the dependency'
                    + ' graph for locally linked projects.  The number of simultaneous processes will be'
                    + ' based on the number of machine cores unless overridden by the --parallelism flag.'
                    + ' (For an incremental build, see "rush build" instead of "rush rebuild".)',
                parser: this,
                commandLineConfiguration: commandLineConfiguration,
                enableParallelism: true,
                ignoreMissingScript: false,
                ignoreDependencyOrder: false,
                incremental: false,
                allowWarningsInSuccessfulBuild: false
            }));
        }
    }
    _addCommandLineConfigActions(commandLineConfiguration) {
        if (!commandLineConfiguration) {
            return;
        }
        // Register each custom command
        for (const command of commandLineConfiguration.commands) {
            if (this.tryGetAction(command.name)) {
                throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a command "${command.name}"`
                    + ` using a name that already exists`);
            }
            this._validateCommandLineConfigCommand(command);
            switch (command.commandKind) {
                case 'bulk':
                    this.addAction(new BulkScriptAction_1.BulkScriptAction({
                        actionName: command.name,
                        summary: command.summary,
                        documentation: command.description || command.summary,
                        safeForSimultaneousRushProcesses: command.safeForSimultaneousRushProcesses,
                        parser: this,
                        commandLineConfiguration: commandLineConfiguration,
                        enableParallelism: command.enableParallelism,
                        ignoreMissingScript: command.ignoreMissingScript || false,
                        ignoreDependencyOrder: command.ignoreDependencyOrder || false,
                        incremental: command.incremental || false,
                        allowWarningsInSuccessfulBuild: !!command.allowWarningsInSuccessfulBuild
                    }));
                    break;
                case 'global':
                    this.addAction(new GlobalScriptAction_1.GlobalScriptAction({
                        actionName: command.name,
                        summary: command.summary,
                        documentation: command.description || command.summary,
                        safeForSimultaneousRushProcesses: command.safeForSimultaneousRushProcesses,
                        parser: this,
                        commandLineConfiguration: commandLineConfiguration,
                        shellCommand: command.shellCommand
                    }));
                    break;
                default:
                    throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a command "${command.name}"`
                        + ` using an unsupported command kind "${command.commandKind}"`);
            }
        }
    }
    _validateCommandLineConfigParameterAssociations(commandLineConfiguration) {
        if (!commandLineConfiguration) {
            return;
        }
        // Check for any invalid associations
        for (const parameter of commandLineConfiguration.parameters) {
            for (const associatedCommand of parameter.associatedCommands) {
                const action = this.tryGetAction(associatedCommand);
                if (!action) {
                    throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${parameter.longName}"`
                        + ` that is associated with a nonexistent command "${associatedCommand}"`);
                }
                if (!(action instanceof BaseScriptAction_1.BaseScriptAction)) {
                    throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${parameter.longName}"`
                        + ` that is associated with a command "${associatedCommand}", but that command does not`
                        + ` support custom parameters`);
                }
            }
        }
    }
    _validateCommandLineConfigCommand(command) {
        // There are some restrictions on the 'build' and 'rebuild' commands.
        if (command.name !== 'build' && command.name !== 'rebuild') {
            return;
        }
        if (command.commandKind === 'global') {
            throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a command "${command.name}" using ` +
                `the command kind "global". This command can only be designated as a command kind "bulk".`);
        }
        if (command.safeForSimultaneousRushProcesses) {
            throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a command "${command.name}" using ` +
                `"safeForSimultaneousRushProcesses=true". This configuration is not supported for "${command.name}".`);
        }
    }
    _reportErrorAndSetExitCode(error) {
        if (!(error instanceof AlreadyReportedError_1.AlreadyReportedError)) {
            const prefix = 'ERROR: ';
            console.error(os.EOL + colors.red(Utilities_1.Utilities.wrapWords(prefix + error.message)));
        }
        if (this._debugParameter.value) {
            // If catchSyncErrors() called this, then show a call stack similar to what Node.js
            // would show for an uncaught error
            console.error(os.EOL + error.stack);
        }
        this.flushTelemetry();
        // Ideally we want to eliminate all calls to process.exit() from our code, and replace them
        // with normal control flow that properly cleans up its data structures.
        // For this particular call, we have a problem that the RushCommandLineParser constructor
        // performs nontrivial work that can throw an exception.  Either the Rush class would need
        // to handle reporting for those exceptions, or else _populateActions() should be moved
        // to a RushCommandLineParser lifecycle stage that can handle it.
        if (process.exitCode > 0) {
            process.exit(process.exitCode);
        }
        else {
            process.exit(1);
        }
    }
}
exports.RushCommandLineParser = RushCommandLineParser;
//# sourceMappingURL=RushCommandLineParser.js.map