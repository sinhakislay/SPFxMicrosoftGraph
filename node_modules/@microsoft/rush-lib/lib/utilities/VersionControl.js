"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const child_process = require("child_process");
const colors = require("colors");
const node_core_library_1 = require("@microsoft/node-core-library");
const DEFAULT_BRANCH = 'master';
const DEFAULT_REMOTE = 'origin';
const DEFAULT_FULLY_QUALIFIED_BRANCH = `${DEFAULT_REMOTE}/${DEFAULT_BRANCH}`;
class VersionControl {
    static getRepositoryRootPath() {
        const output = node_core_library_1.Executable.spawnSync('git', ['rev-parse', '--show-toplevel']);
        if (output.status !== 0) {
            return undefined;
        }
        else {
            return output.stdout.trim();
        }
    }
    static getChangedFolders(targetBranch, skipFetch = false) {
        if (!skipFetch) {
            VersionControl._fetchRemoteBranch(targetBranch);
        }
        const output = child_process.execSync(`git diff ${targetBranch}... --dirstat=files,0`).toString();
        return output.split('\n').map((line) => {
            if (line) {
                const delimiterIndex = line.indexOf('%');
                if (delimiterIndex > 0 && delimiterIndex + 1 < line.length) {
                    return line.substring(delimiterIndex + 1).trim();
                }
            }
            return undefined;
        });
    }
    /**
     * @param pathPrefix - An optional path prefix "git diff"s should be filtered by.
     * @returns
     * An array of paths of repo-root-relative paths of files that are different from
     * those in the provided {@param targetBranch}. If a {@param pathPrefix} is provided,
     * this function only returns results under the that path.
     */
    static getChangedFiles(targetBranch, skipFetch = false, pathPrefix) {
        if (!skipFetch) {
            VersionControl._fetchRemoteBranch(targetBranch);
        }
        const output = child_process.execSync(`git diff ${targetBranch}... --name-only --no-renames --diff-filter=A`).toString();
        return output.split('\n').map((line) => {
            if (line) {
                const trimmedLine = line.trim();
                if (!pathPrefix || node_core_library_1.Path.isUnderOrEqual(trimmedLine, pathPrefix)) {
                    return trimmedLine;
                }
            }
            else {
                return undefined;
            }
        }).filter((line) => {
            return line && line.length > 0;
        });
    }
    /**
     * Gets the remote master branch that maps to the provided repository url.
     * This method is used by 'Rush change' to find the default remote branch to compare against.
     * If repository url is not provided or if there is no match, returns the default remote
     * master branch 'origin/master'.
     * If there are more than one matches, returns the first remote's master branch.
     *
     * @param repositoryUrl - repository url
     */
    static getRemoteMasterBranch(repositoryUrl) {
        if (repositoryUrl) {
            const output = child_process
                .execSync(`git remote`)
                .toString();
            const normalizedRepositoryUrl = repositoryUrl.toUpperCase();
            const matchingRemotes = output.split('\n').filter((remoteName) => {
                if (remoteName) {
                    const remoteUrl = child_process.execSync(`git remote get-url ${remoteName}`)
                        .toString()
                        .trim();
                    if (!remoteUrl) {
                        return false;
                    }
                    const normalizedRemoteUrl = remoteUrl.toUpperCase();
                    if (normalizedRemoteUrl.toUpperCase() === normalizedRepositoryUrl) {
                        return true;
                    }
                    // When you copy a URL from the GitHub web site, they append the ".git" file extension to the URL.
                    // We allow that to be specified in rush.json, even though the file extension gets dropped
                    // by "git clone".
                    if (`${normalizedRemoteUrl}.GIT` === normalizedRepositoryUrl) {
                        return true;
                    }
                }
                return false;
            });
            if (matchingRemotes.length > 0) {
                if (matchingRemotes.length > 1) {
                    console.log(`More than one git remote matches the repository URL. Using the first remote (${matchingRemotes[0]}).`);
                }
                return `${matchingRemotes[0]}/${DEFAULT_BRANCH}`;
            }
            else {
                console.log(colors.yellow(`Unable to find a git remote matching the repository URL (${repositoryUrl}). ` +
                    'Detected changes are likely to be incorrect.'));
                return DEFAULT_FULLY_QUALIFIED_BRANCH;
            }
        }
        else {
            console.log(colors.yellow('A git remote URL has not been specified in rush.json. Setting the baseline remote URL is recommended.'));
            return DEFAULT_FULLY_QUALIFIED_BRANCH;
        }
    }
    static hasUncommittedChanges() {
        return VersionControl.getUncommittedChanges().length > 0;
    }
    /**
     * The list of files changed but not committed
     */
    static getUncommittedChanges() {
        const changes = [];
        changes.push(...VersionControl._getUntrackedChanges());
        changes.push(...VersionControl._getDiffOnHEAD());
        return changes.filter(change => {
            return change.trim().length > 0;
        });
    }
    static _getUntrackedChanges() {
        const output = child_process
            .execSync(`git ls-files --exclude-standard --others`)
            .toString();
        return output.trim().split('\n');
    }
    static _getDiffOnHEAD() {
        const output = child_process
            .execSync(`git diff HEAD --name-only`)
            .toString();
        return output.trim().split('\n');
    }
    static _tryFetchRemoteBranch(remoteBranchName) {
        const firstSlashIndex = remoteBranchName.indexOf('/');
        if (firstSlashIndex === -1) {
            throw new Error(`Unexpected git remote branch format: ${remoteBranchName}. ` +
                'Expected branch to be in the <remote>/<branch name> format.');
        }
        const remoteName = remoteBranchName.substr(0, firstSlashIndex);
        const branchName = remoteBranchName.substr(firstSlashIndex + 1);
        const spawnResult = node_core_library_1.Executable.spawnSync('git', ['fetch', remoteName, branchName], {
            stdio: 'ignore'
        });
        return spawnResult.status === 0;
    }
    static _fetchRemoteBranch(remoteBranchName) {
        console.log(`Checking for updates to ${remoteBranchName}...`);
        const fetchResult = VersionControl._tryFetchRemoteBranch(remoteBranchName);
        if (!fetchResult) {
            console.log(colors.yellow(`Error fetching git remote branch ${remoteBranchName}. Detected changed files may be incorrect.`));
        }
    }
}
exports.VersionControl = VersionControl;
//# sourceMappingURL=VersionControl.js.map