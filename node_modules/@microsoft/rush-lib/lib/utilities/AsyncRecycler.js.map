{"version":3,"file":"AsyncRecycler.js","sourceRoot":"","sources":["../../src/utilities/AsyncRecycler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as child_process from 'child_process';\r\nimport * as fs from 'fs';\r\nimport * as os from 'os';\r\nimport * as path from 'path';\r\n\r\nimport {\r\n  Text,\r\n  Path,\r\n  FileSystem\r\n} from '@microsoft/node-core-library';\r\n\r\nimport { Utilities } from './Utilities';\r\n\r\n/**\r\n * For deleting large folders, AsyncRecycler is significantly faster than Utilities.dangerouslyDeletePath().\r\n * It works by moving one or more folders into a temporary \"recycler\" folder, and then launches a separate\r\n * background process to recursively delete that folder.\r\n */\r\nexport class AsyncRecycler {\r\n  private _recyclerFolder: string;\r\n  private _movedFolderCount: number;\r\n  private _deleting: boolean;\r\n\r\n  constructor(recyclerFolder: string) {\r\n    this._recyclerFolder = path.resolve(recyclerFolder);\r\n    this._movedFolderCount = 0;\r\n    this._deleting = false;\r\n  }\r\n\r\n  /**\r\n   * The full path of the recycler folder.\r\n   * Example: `C:\\MyRepo\\common\\rush-recycler`\r\n   */\r\n  public get recyclerFolder(): string {\r\n    return this._recyclerFolder;\r\n  }\r\n\r\n  /**\r\n   * Synchronously moves the specified folder into the recycler folder.  If the specified folder\r\n   * does not exist, then no operation is performed.  After calling this function one or more times,\r\n   * deleteAll() must be called to actually delete the contents of the recycler folder.\r\n   */\r\n  public moveFolder(folderPath: string): void {\r\n    if (this._deleting) {\r\n      throw new Error('AsyncRecycler.moveFolder() must not be called after deleteAll() has started');\r\n    }\r\n\r\n    if (Path.isUnder(this.recyclerFolder, folderPath)) {\r\n      throw new Error('AsyncRecycler.moveFolder() cannot be called on a parent of the recycler folder');\r\n    }\r\n\r\n    if (!FileSystem.exists(folderPath)) {\r\n      return;\r\n    }\r\n\r\n    ++this._movedFolderCount;\r\n\r\n    // We need to do a simple \"FileSystem.move\" here, however if the folder we're trying to rename\r\n    // has a lock, or if its destination container doesn't exist yet,\r\n    // then there seems to be some OS process (virus scanner?) that holds\r\n    // a lock on the folder for a split second, which causes renameSync to\r\n    // fail. To workaround that, retry for up to 7 seconds before giving up.\r\n    const maxWaitTimeMs: number = 7 * 1000;\r\n\r\n    const oldFolderName: string = path.basename(folderPath);\r\n    const newFolderPath: string = path.join(this.recyclerFolder, `${oldFolderName}_${new Date().getTime()}`);\r\n\r\n    if (!FileSystem.exists(this.recyclerFolder)) {\r\n      Utilities.createFolderWithRetry(this.recyclerFolder);\r\n    }\r\n\r\n    Utilities.retryUntilTimeout(\r\n      () => FileSystem.move({ sourcePath: folderPath, destinationPath: newFolderPath }),\r\n      maxWaitTimeMs,\r\n      (e) => new Error(`Error: ${e}${os.EOL}Often this is caused by a file lock ` +\r\n                      'from a process like the virus scanner.'),\r\n      'recycleFolder'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * This deletes all items under the specified folder, except for the items in the membersToExclude.\r\n   * To be conservative, a case-insensitive comparison is used for membersToExclude.\r\n   * The membersToExclude must be file/folder names that would match readdir() results.\r\n   */\r\n  public moveAllItemsInFolder(folderPath: string, membersToExclude?: ReadonlyArray<string>): void {\r\n    const resolvedFolderPath: string = path.resolve(folderPath);\r\n\r\n    const excludeSet: Set<string> = new Set<string>(\r\n      (membersToExclude || []).map(x => x.toUpperCase())\r\n    );\r\n\r\n    for (const memberPath of FileSystem.readFolder(resolvedFolderPath, { absolutePaths: true })) {\r\n      const normalizedMemberName: string = path.basename(memberPath).toUpperCase();\r\n      if (!excludeSet.has(normalizedMemberName)) {\r\n        let shouldMove: boolean = false;\r\n        try {\r\n          const stats: fs.Stats = FileSystem.getLinkStatistics(memberPath);\r\n          shouldMove = stats.isDirectory();\r\n        } catch (error) {\r\n          // If we fail to access the item, assume it's not a folder\r\n        }\r\n        if (shouldMove) {\r\n          this.moveFolder(memberPath);\r\n        } else {\r\n          FileSystem.deleteFolder(memberPath);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Starts an asynchronous process to delete the recycler folder.  Deleting will continue\r\n   * even if the current Node.js process is killed.\r\n   *\r\n   * NOTE: To avoid spawning multiple instances of the same command, moveFolder()\r\n   * MUST NOT be called again after deleteAll() has started.\r\n   */\r\n  public deleteAll(): void {\r\n    if (this._deleting) {\r\n      throw new Error('AsyncRecycler.deleteAll() must not be called more than once');\r\n    }\r\n\r\n    this._deleting = true;\r\n\r\n    if (this._movedFolderCount === 0) {\r\n      // Nothing to do\r\n      return;\r\n    }\r\n\r\n    // Asynchronously delete the folder contents.\r\n    let command: string;\r\n    let args: string[];\r\n\r\n    const options: child_process.SpawnOptions = {\r\n      detached: true,\r\n      // The child won't stay alive unless we detach its stdio\r\n      stdio: 'ignore'\r\n    };\r\n\r\n    if (os.platform() === 'win32') {\r\n      // PowerShell.exe doesn't work with a detached console, so we need cmd.exe to create\r\n      // the new console for us.\r\n      command = 'cmd.exe';\r\n\r\n      // In PowerShell single-quote literals, single quotes are escaped by doubling them\r\n      const escapedRecyclerFolder: string = Text.replaceAll(this.recyclerFolder, '\\'', '\\'\\'');\r\n\r\n      // As of PowerShell 3.0, the \"\\\\?\" prefix can be used for paths that exceed MAX_PATH.\r\n      // (This prefix does not seem to work for cmd.exe's \"rd\" command.)\r\n      args = [\r\n        '/c',\r\n        '\"' +\r\n        'PowerShell.exe -Version 3.0 -NoLogo -NonInteractive -WindowStyle Hidden -Command'\r\n          + ` Get-ChildItem -Force '${escapedRecyclerFolder}'`\r\n          // The \"^|\" here prevents cmd.exe from interpreting the \"|\" symbol\r\n          + ` ^| ForEach ($_) { Remove-Item -ErrorAction Ignore -Force -Recurse \"\\\\\\\\?\\\\$($_.FullName)\" }`\r\n          + '\"'\r\n      ];\r\n\r\n      options.windowsVerbatimArguments = true;\r\n    } else {\r\n      command = 'rm';\r\n      args = [ '-rf' ];\r\n\r\n      let pathCount: number = 0;\r\n\r\n      // child_process.spawn() doesn't expand wildcards.  To be safe, we will do it manually\r\n      // rather than rely on an unknown shell.\r\n      for (const filename of FileSystem.readFolder(this.recyclerFolder)) {\r\n        // The \".\" and \"..\" are supposed to be excluded, but let's be safe\r\n        if (filename !== '.' && filename !== '..') {\r\n          args.push(path.join(this.recyclerFolder, filename));\r\n          ++pathCount;\r\n        }\r\n      }\r\n\r\n      if (pathCount === 0) {\r\n        // Nothing to do\r\n        return;\r\n      }\r\n    }\r\n\r\n    const process: child_process.ChildProcess = child_process.spawn(command, args, options);\r\n\r\n    // The child won't stay alive unless we unlink it from the parent process\r\n    process.unref();\r\n  }\r\n\r\n}\r\n"]}