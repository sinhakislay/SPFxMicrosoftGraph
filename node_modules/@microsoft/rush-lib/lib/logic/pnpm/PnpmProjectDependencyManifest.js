"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const semver = require("semver");
const node_core_library_1 = require("@microsoft/node-core-library");
const PnpmShrinkwrapFile_1 = require("./PnpmShrinkwrapFile");
const RushConstants_1 = require("../RushConstants");
/**
 * This class handles creating the project/.rush/temp/shrinkwrap-deps.json file
 * which tracks the direct and indirect dependencies that a project consumes. This is used
 * to better determine which projects should be rebuilt when dependencies are updated.
 */
class PnpmProjectDependencyManifest {
    /**
     * Get the fully-qualified path to the project/.rush/temp/shrinkwrap-deps.json
     * for the specified project.
     */
    static getFilePathForProject(project) {
        return path.join(project.projectRushTempFolder, RushConstants_1.RushConstants.projectDependencyManifestFilename);
    }
    constructor(options) {
        this._pnpmShrinkwrapFile = options.pnpmShrinkwrapFile;
        this._project = options.project;
        this._projectDependencyManifestFilename = PnpmProjectDependencyManifest.getFilePathForProject(this._project);
        this._projectDependencyManifestFile = new Map();
    }
    addDependency(pkg, parentShrinkwrapEntry) {
        if (!pkg.version) {
            throw new node_core_library_1.InternalError(`Version missing from dependency ${pkg.name}`);
        }
        this._addDependencyInternal(pkg.name, pkg.version, parentShrinkwrapEntry);
    }
    /**
     * Save the current state of the object to project/.rush/temp/shrinkwrap-deps.json
     */
    save() {
        const file = {};
        const keys = Array.from(this._projectDependencyManifestFile.keys()).sort();
        for (const key of keys) {
            file[key] = this._projectDependencyManifestFile.get(key);
        }
        node_core_library_1.JsonFile.save(file, this._projectDependencyManifestFilename, { ensureFolderExists: true });
    }
    /**
     * If the project/.rush/temp/shrinkwrap-deps.json file exists, delete it. Otherwise, do nothing.
     */
    deleteIfExists() {
        node_core_library_1.FileSystem.deleteFile(this._projectDependencyManifestFilename, { throwIfNotExists: false });
    }
    _addDependencyInternal(name, version, parentShrinkwrapEntry, throwIfShrinkwrapEntryMissing = true) {
        const shrinkwrapEntry = this._pnpmShrinkwrapFile.getShrinkwrapEntry(name, version);
        if (!shrinkwrapEntry) {
            if (throwIfShrinkwrapEntryMissing) {
                throw new node_core_library_1.InternalError(`Unable to find dependency ${name} with version ${version} in shrinkwrap.`);
            }
            return;
        }
        const specifier = `${name}@${version}`;
        const integrity = shrinkwrapEntry.resolution.integrity;
        if (this._projectDependencyManifestFile.has(specifier)) {
            if (this._projectDependencyManifestFile.get(specifier) !== integrity) {
                throw new Error(`Collision: ${specifier} already exists in with a different integrity`);
            }
            return;
        }
        // Add the current dependency
        this._projectDependencyManifestFile.set(specifier, integrity);
        // Add the dependencies of the dependency
        for (const dependencyName in shrinkwrapEntry.dependencies) {
            if (shrinkwrapEntry.dependencies.hasOwnProperty(dependencyName)) {
                const dependencyVersion = shrinkwrapEntry.dependencies[dependencyName];
                this._addDependencyInternal(dependencyName, dependencyVersion, shrinkwrapEntry);
            }
        }
        // Add the optional dependencies of the dependency
        for (const optionalDependencyName in shrinkwrapEntry.optionalDependencies) {
            if (shrinkwrapEntry.optionalDependencies.hasOwnProperty(optionalDependencyName)) {
                // Optional dependencies may not exist. Don't blow up if it can't be found
                const dependencyVersion = shrinkwrapEntry.optionalDependencies[optionalDependencyName];
                this._addDependencyInternal(optionalDependencyName, dependencyVersion, shrinkwrapEntry, throwIfShrinkwrapEntryMissing = false);
            }
        }
        for (const peerDependencyName in shrinkwrapEntry.peerDependencies) {
            if (shrinkwrapEntry.peerDependencies.hasOwnProperty(peerDependencyName)) {
                // Peer dependencies come in the form of a semantic version range
                const dependencySemVer = shrinkwrapEntry.peerDependencies[peerDependencyName];
                // Check the current package to see if the dependency is already satisfied
                if (shrinkwrapEntry.dependencies &&
                    shrinkwrapEntry.dependencies.hasOwnProperty(peerDependencyName)) {
                    const dependencySpecifier = PnpmShrinkwrapFile_1.parsePnpmDependencyKey(peerDependencyName, shrinkwrapEntry.dependencies[peerDependencyName]);
                    if (dependencySpecifier) {
                        if (!semver.valid(dependencySpecifier.versionSpecifier)) {
                            throw new node_core_library_1.InternalError(`The version '${dependencySemVer}' of peer dependency '${peerDependencyName}' is invalid`);
                        }
                        continue;
                    }
                }
                // If not, check the parent.
                if (parentShrinkwrapEntry.dependencies &&
                    parentShrinkwrapEntry.dependencies.hasOwnProperty(peerDependencyName)) {
                    const dependencySpecifier = PnpmShrinkwrapFile_1.parsePnpmDependencyKey(peerDependencyName, parentShrinkwrapEntry.dependencies[peerDependencyName]);
                    if (dependencySpecifier) {
                        if (!semver.valid(dependencySpecifier.versionSpecifier)) {
                            throw new node_core_library_1.InternalError(`The version '${dependencySemVer}' of peer dependency '${peerDependencyName}' is invalid`);
                        }
                        continue;
                    }
                }
                // The parent doesn't have a version that satisfies the range. As a last attempt, check
                // if it's been hoisted up as a top-level dependency
                const topLevelDependencySpecifier = this._pnpmShrinkwrapFile.getTopLevelDependencyVersion(peerDependencyName);
                if (!topLevelDependencySpecifier || !semver.valid(topLevelDependencySpecifier.versionSpecifier)) {
                    throw new node_core_library_1.InternalError(`Could not find peer dependency '${peerDependencyName}' that satisfies version '${dependencySemVer}'`);
                }
                this._addDependencyInternal(peerDependencyName, this._pnpmShrinkwrapFile.getTopLevelDependencyKey(peerDependencyName), shrinkwrapEntry);
            }
        }
    }
}
exports.PnpmProjectDependencyManifest = PnpmProjectDependencyManifest;
//# sourceMappingURL=PnpmProjectDependencyManifest.js.map