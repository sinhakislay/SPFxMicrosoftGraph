{"version":3,"file":"PnpmProjectDependencyManifest.js","sourceRoot":"","sources":["../../../src/logic/pnpm/PnpmProjectDependencyManifest.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport * as semver from 'semver';\r\nimport {\r\n  JsonFile,\r\n  InternalError,\r\n  FileSystem\r\n} from '@microsoft/node-core-library';\r\n\r\nimport {\r\n  PnpmShrinkwrapFile,\r\n  IPnpmShrinkwrapDependencyYaml,\r\n  parsePnpmDependencyKey\r\n} from './PnpmShrinkwrapFile';\r\nimport { RushConfigurationProject } from '../../api/RushConfigurationProject';\r\nimport { RushConstants } from '../RushConstants';\r\nimport { BasePackage } from '../base/BasePackage';\r\nimport { DependencySpecifier } from '../DependencySpecifier';\r\n\r\nexport interface IPnpmProjectDependencyManifestOptions {\r\n  pnpmShrinkwrapFile: PnpmShrinkwrapFile;\r\n  project: RushConfigurationProject;\r\n}\r\n\r\n/**\r\n * This class handles creating the project/.rush/temp/shrinkwrap-deps.json file\r\n * which tracks the direct and indirect dependencies that a project consumes. This is used\r\n * to better determine which projects should be rebuilt when dependencies are updated.\r\n */\r\nexport class PnpmProjectDependencyManifest {\r\n  /**\r\n   * This mapping is used to map all project dependencies and all their dependencies\r\n   * to their respective dependency integrity hash. For example, if the project contains\r\n   * a dependency A which itself has a dependency on B, the mapping would look like:\r\n   * 'A@1.2.3': '{Integrity of A}',\r\n   * 'B@4.5.6': '{Integrity of B}',\r\n   * ...\r\n   */\r\n  private _projectDependencyManifestFile: Map<string, string>;\r\n\r\n  private readonly _projectDependencyManifestFilename: string;\r\n  private readonly _pnpmShrinkwrapFile: PnpmShrinkwrapFile;\r\n  private readonly _project: RushConfigurationProject;\r\n\r\n  /**\r\n   * Get the fully-qualified path to the project/.rush/temp/shrinkwrap-deps.json\r\n   * for the specified project.\r\n   */\r\n  public static getFilePathForProject(project: RushConfigurationProject): string {\r\n    return path.join(\r\n      project.projectRushTempFolder,\r\n      RushConstants.projectDependencyManifestFilename\r\n    );\r\n  }\r\n\r\n  public constructor(options: IPnpmProjectDependencyManifestOptions) {\r\n    this._pnpmShrinkwrapFile = options.pnpmShrinkwrapFile;\r\n    this._project = options.project;\r\n    this._projectDependencyManifestFilename = PnpmProjectDependencyManifest.getFilePathForProject(this._project);\r\n\r\n    this._projectDependencyManifestFile = new Map<string, string>();\r\n  }\r\n\r\n  public addDependency(pkg: BasePackage, parentShrinkwrapEntry: IPnpmShrinkwrapDependencyYaml): void {\r\n    if (!pkg.version) {\r\n      throw new InternalError(`Version missing from dependency ${pkg.name}`);\r\n    }\r\n\r\n    this._addDependencyInternal(pkg.name, pkg.version, parentShrinkwrapEntry);\r\n  }\r\n\r\n  /**\r\n   * Save the current state of the object to project/.rush/temp/shrinkwrap-deps.json\r\n   */\r\n  public save(): void {\r\n    const file: { [specifier: string]: string } = {};\r\n    const keys: string[] = Array.from(this._projectDependencyManifestFile.keys()).sort();\r\n    for (const key of keys) {\r\n      file[key] = this._projectDependencyManifestFile.get(key)!;\r\n    }\r\n\r\n    JsonFile.save(\r\n      file,\r\n      this._projectDependencyManifestFilename,\r\n      { ensureFolderExists: true }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * If the project/.rush/temp/shrinkwrap-deps.json file exists, delete it. Otherwise, do nothing.\r\n   */\r\n  public deleteIfExists(): void {\r\n    FileSystem.deleteFile(this._projectDependencyManifestFilename, { throwIfNotExists: false });\r\n  }\r\n\r\n  private _addDependencyInternal(\r\n    name: string,\r\n    version: string,\r\n    parentShrinkwrapEntry: IPnpmShrinkwrapDependencyYaml,\r\n    throwIfShrinkwrapEntryMissing: boolean = true\r\n  ): void {\r\n    const shrinkwrapEntry: IPnpmShrinkwrapDependencyYaml | undefined = this._pnpmShrinkwrapFile.getShrinkwrapEntry(\r\n      name,\r\n      version\r\n    );\r\n\r\n    if (!shrinkwrapEntry) {\r\n      if (throwIfShrinkwrapEntryMissing) {\r\n        throw new InternalError(`Unable to find dependency ${name} with version ${version} in shrinkwrap.`);\r\n      }\r\n      return;\r\n    }\r\n\r\n    const specifier: string = `${name}@${version}`;\r\n    const integrity: string = shrinkwrapEntry.resolution.integrity;\r\n    if (this._projectDependencyManifestFile.has(specifier)) {\r\n      if (this._projectDependencyManifestFile.get(specifier) !== integrity) {\r\n        throw new Error(`Collision: ${specifier} already exists in with a different integrity`);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Add the current dependency\r\n    this._projectDependencyManifestFile.set(specifier, integrity);\r\n\r\n    // Add the dependencies of the dependency\r\n    for (const dependencyName in shrinkwrapEntry.dependencies) {\r\n      if (shrinkwrapEntry.dependencies.hasOwnProperty(dependencyName)) {\r\n        const dependencyVersion: string = shrinkwrapEntry.dependencies[dependencyName];\r\n        this._addDependencyInternal(dependencyName, dependencyVersion, shrinkwrapEntry);\r\n      }\r\n    }\r\n\r\n    // Add the optional dependencies of the dependency\r\n    for (const optionalDependencyName in shrinkwrapEntry.optionalDependencies) {\r\n      if (shrinkwrapEntry.optionalDependencies.hasOwnProperty(optionalDependencyName)) {\r\n        // Optional dependencies may not exist. Don't blow up if it can't be found\r\n        const dependencyVersion: string = shrinkwrapEntry.optionalDependencies[optionalDependencyName];\r\n        this._addDependencyInternal(\r\n          optionalDependencyName,\r\n          dependencyVersion,\r\n          shrinkwrapEntry,\r\n          throwIfShrinkwrapEntryMissing = false);\r\n      }\r\n    }\r\n\r\n    for (const peerDependencyName in shrinkwrapEntry.peerDependencies) {\r\n      if (shrinkwrapEntry.peerDependencies.hasOwnProperty(peerDependencyName)) {\r\n        // Peer dependencies come in the form of a semantic version range\r\n        const dependencySemVer: string = shrinkwrapEntry.peerDependencies[peerDependencyName];\r\n\r\n        // Check the current package to see if the dependency is already satisfied\r\n        if (\r\n          shrinkwrapEntry.dependencies &&\r\n          shrinkwrapEntry.dependencies.hasOwnProperty(peerDependencyName)\r\n        ) {\r\n          const dependencySpecifier: DependencySpecifier | undefined = parsePnpmDependencyKey(\r\n            peerDependencyName,\r\n            shrinkwrapEntry.dependencies[peerDependencyName]\r\n          );\r\n          if (dependencySpecifier) {\r\n            if (!semver.valid(dependencySpecifier.versionSpecifier)) {\r\n              throw new InternalError(\r\n                `The version '${dependencySemVer}' of peer dependency '${peerDependencyName}' is invalid`\r\n              );\r\n            }\r\n            continue;\r\n          }\r\n        }\r\n\r\n        // If not, check the parent.\r\n        if (\r\n          parentShrinkwrapEntry.dependencies &&\r\n          parentShrinkwrapEntry.dependencies.hasOwnProperty(peerDependencyName)\r\n        ) {\r\n          const dependencySpecifier: DependencySpecifier | undefined = parsePnpmDependencyKey(\r\n            peerDependencyName,\r\n            parentShrinkwrapEntry.dependencies[peerDependencyName]\r\n          );\r\n          if (dependencySpecifier) {\r\n            if (!semver.valid(dependencySpecifier.versionSpecifier)) {\r\n              throw new InternalError(\r\n                `The version '${dependencySemVer}' of peer dependency '${peerDependencyName}' is invalid`\r\n              );\r\n            }\r\n            continue;\r\n          }\r\n        }\r\n\r\n        // The parent doesn't have a version that satisfies the range. As a last attempt, check\r\n        // if it's been hoisted up as a top-level dependency\r\n        const topLevelDependencySpecifier: DependencySpecifier | undefined =\r\n          this._pnpmShrinkwrapFile.getTopLevelDependencyVersion(peerDependencyName);\r\n        if (!topLevelDependencySpecifier || !semver.valid(topLevelDependencySpecifier.versionSpecifier)) {\r\n          throw new InternalError(\r\n            `Could not find peer dependency '${peerDependencyName}' that satisfies version '${dependencySemVer}'`\r\n          );\r\n        }\r\n\r\n        this._addDependencyInternal(\r\n          peerDependencyName,\r\n          this._pnpmShrinkwrapFile.getTopLevelDependencyKey(peerDependencyName)!,\r\n          shrinkwrapEntry\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}