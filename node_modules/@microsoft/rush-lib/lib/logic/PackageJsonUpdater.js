"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const semver = require("semver");
const InstallManager_1 = require("./InstallManager");
const VersionMismatchFinder_1 = require("./versionMismatch/VersionMismatchFinder");
const PurgeManager_1 = require("./PurgeManager");
const Utilities_1 = require("../utilities/Utilities");
const VersionMismatchFinderProject_1 = require("./versionMismatch/VersionMismatchFinderProject");
/**
 * A helper class for managing the dependencies of various package.json files.
 * @internal
 */
class PackageJsonUpdater {
    constructor(rushConfiguration, rushGlobalFolder) {
        this._rushConfiguration = rushConfiguration;
        this._rushGlobalFolder = rushGlobalFolder;
    }
    /**
     * Adds a dependency to a particular project. The core business logic for "rush add".
     */
    doRushAdd(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { projects, packageName, initialVersion, devDependency, updateOtherPackages, skipUpdate, debugInstall, rangeStyle, variant } = options;
            const implicitlyPinned = InstallManager_1.InstallManager.collectImplicitlyPreferredVersions(this._rushConfiguration, {
                variant
            });
            const purgeManager = new PurgeManager_1.PurgeManager(this._rushConfiguration, this._rushGlobalFolder);
            const installManagerOptions = {
                debug: debugInstall,
                allowShrinkwrapUpdates: true,
                bypassPolicy: false,
                noLink: false,
                fullUpgrade: false,
                recheckShrinkwrap: false,
                networkConcurrency: undefined,
                collectLogFile: false,
                variant: variant
            };
            const installManager = new InstallManager_1.InstallManager(this._rushConfiguration, this._rushGlobalFolder, purgeManager, installManagerOptions);
            const version = yield this._getNormalizedVersionSpec(installManager, packageName, initialVersion, implicitlyPinned.get(packageName), rangeStyle);
            console.log();
            console.log(colors.green(`Updating projects to use `) + packageName + '@' + colors.cyan(version));
            console.log();
            const allPackageUpdates = [];
            for (const project of projects) {
                const currentProjectUpdate = {
                    project: new VersionMismatchFinderProject_1.VersionMismatchFinderProject(project),
                    packageName,
                    newVersion: version,
                    dependencyType: devDependency ? "devDependencies" /* Dev */ : undefined
                };
                this.updateProject(currentProjectUpdate);
                const otherPackageUpdates = [];
                if (this._rushConfiguration.ensureConsistentVersions || updateOtherPackages) {
                    // we need to do a mismatch check
                    const mismatchFinder = VersionMismatchFinder_1.VersionMismatchFinder.getMismatches(this._rushConfiguration, {
                        variant: variant
                    });
                    const mismatches = mismatchFinder.getMismatches().filter((mismatch) => {
                        return !projects.find((proj) => proj.packageName === mismatch);
                    });
                    if (mismatches.length) {
                        if (!updateOtherPackages) {
                            throw new Error(`Adding '${packageName}@${version}' to ${project.packageName}`
                                + ` causes mismatched dependencies. Use the "--make-consistent" flag to update other packages to use`
                                + ` this version, or do not specify a SemVer range.`);
                        }
                        // otherwise we need to go update a bunch of other projects
                        const mismatchedVersions = mismatchFinder.getVersionsOfMismatch(packageName);
                        if (mismatchedVersions) {
                            for (const mismatchedVersion of mismatchedVersions) {
                                for (const consumer of mismatchFinder.getConsumersOfMismatch(packageName, mismatchedVersion)) {
                                    if (consumer instanceof VersionMismatchFinderProject_1.VersionMismatchFinderProject) {
                                        otherPackageUpdates.push({
                                            project: consumer,
                                            packageName: packageName,
                                            newVersion: version
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
                this.updateProjects(otherPackageUpdates);
                allPackageUpdates.push(currentProjectUpdate, ...otherPackageUpdates);
            }
            for (const { project } of allPackageUpdates) {
                if (project.saveIfModified()) {
                    console.log(colors.green('Wrote ') + project.filePath);
                }
            }
            if (!skipUpdate) {
                console.log();
                console.log(colors.green('Running "rush update"'));
                console.log();
                try {
                    yield installManager.doInstall();
                }
                finally {
                    purgeManager.deleteAll();
                }
            }
        });
    }
    /**
     * Updates several projects' package.json files
     */
    updateProjects(projectUpdates) {
        for (const update of projectUpdates) {
            this.updateProject(update);
        }
    }
    /**
     * Updates a single project's package.json file
     */
    updateProject(options) {
        let { dependencyType } = options;
        const { project, packageName, newVersion } = options;
        const oldDependency = project.tryGetDependency(packageName);
        const oldDevDependency = project.tryGetDevDependency(packageName);
        const oldDependencyType = oldDevDependency
            ? oldDevDependency.dependencyType
            : (oldDependency ? oldDependency.dependencyType : undefined);
        dependencyType = dependencyType || oldDependencyType || "dependencies" /* Regular */;
        project.addOrUpdateDependency(packageName, newVersion, dependencyType);
    }
    /**
     * Selects an appropriate version number for a particular package, given an optional initial SemVer spec.
     * If ensureConsistentVersions, tries to pick a version that will be consistent.
     * Otherwise, will choose the latest semver matching the initialSpec and append the proper range style.
     * @param packageName - the name of the package to be used
     * @param initialSpec - a semver pattern that should be used to find the latest version matching the spec
     * @param implicitlyPinnedVersion - the implicitly preferred (aka common/primary) version of the package in use
     * @param rangeStyle - if this version is selected by querying registry, then this range specifier is prepended to
     *   the selected version.
     */
    _getNormalizedVersionSpec(installManager, packageName, initialSpec, implicitlyPinnedVersion, rangeStyle) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(colors.gray(`Determining new version for dependency: ${packageName}`));
            if (initialSpec) {
                console.log(`Specified version selector: ${colors.cyan(initialSpec)}`);
            }
            else {
                console.log(`No version selector was specified, so the version will be determined automatically.`);
            }
            console.log();
            // if ensureConsistentVersions => reuse the pinned version
            // else, query the registry and use the latest that satisfies semver spec
            if (initialSpec && implicitlyPinnedVersion && initialSpec === implicitlyPinnedVersion) {
                console.log(colors.green('Assigning "')
                    + colors.cyan(initialSpec)
                    + colors.green(`" for "${packageName}" because it matches what other projects are using in this repo.`));
                return initialSpec;
            }
            if (this._rushConfiguration.ensureConsistentVersions && !initialSpec && implicitlyPinnedVersion) {
                console.log(`Assigning the version range "${colors.cyan(implicitlyPinnedVersion)}" for "${packageName}" because`
                    + ` it is already used by other projects in this repo.`);
                return implicitlyPinnedVersion;
            }
            if (this._rushConfiguration.packageManager === 'yarn') {
                throw new Error('The Yarn package manager is not currently supported by the "rush add" command.');
            }
            yield installManager.ensureLocalPackageManager();
            let selectedVersion;
            if (initialSpec && initialSpec !== 'latest') {
                console.log(colors.gray('Finding versions that satisfy the selector: ') + initialSpec);
                console.log();
                console.log(`Querying registry for all versions of "${packageName}"...`);
                const allVersions = Utilities_1.Utilities.executeCommandAndCaptureOutput(this._rushConfiguration.packageManagerToolFilename, ['view', packageName, 'versions', '--json'], this._rushConfiguration.commonTempFolder);
                const versionList = JSON.parse(allVersions);
                console.log(colors.gray(`Found ${versionList.length} available versions.`));
                for (const version of versionList) {
                    if (semver.satisfies(version, initialSpec)) {
                        selectedVersion = initialSpec;
                        console.log(`Found a version that satisfies ${initialSpec}: ${colors.cyan(version)}`);
                        break;
                    }
                }
                if (!selectedVersion) {
                    throw new Error(`Unable to find a version of "${packageName}" that satisfies`
                        + ` the version specifier "${initialSpec}"`);
                }
            }
            else {
                if (!this._rushConfiguration.ensureConsistentVersions) {
                    console.log(colors.gray(`The "ensureConsistentVersions" policy is NOT active,`
                        + ` so we will assign the latest version.`));
                    console.log();
                }
                console.log(`Querying NPM registry for latest version of "${packageName}"...`);
                selectedVersion = Utilities_1.Utilities.executeCommandAndCaptureOutput(this._rushConfiguration.packageManagerToolFilename, ['view', `${packageName}@latest`, 'version'], this._rushConfiguration.commonTempFolder).trim();
                console.log();
                console.log(`Found latest version: ${colors.cyan(selectedVersion)}`);
            }
            console.log();
            switch (rangeStyle) {
                case "caret" /* Caret */: {
                    console.log(colors.grey(`Assigning version "^${selectedVersion}" for "${packageName}" because the "--caret"`
                        + ` flag was specified.`));
                    return `^${selectedVersion}`;
                }
                case "exact" /* Exact */: {
                    console.log(colors.grey(`Assigning version "${selectedVersion}" for "${packageName}" because the "--exact"`
                        + ` flag was specified.`));
                    return selectedVersion;
                }
                case "tilde" /* Tilde */: {
                    console.log(colors.gray(`Assigning version "~${selectedVersion}" for "${packageName}".`));
                    return `~${selectedVersion}`;
                }
                case "passthrough" /* Passthrough */: {
                    console.log(colors.gray(`Assigning version "${selectedVersion}" for "${packageName}".`));
                    return selectedVersion;
                }
                default: {
                    throw new Error(`Unexpected SemVerStyle ${rangeStyle}.`);
                }
            }
        });
    }
}
exports.PackageJsonUpdater = PackageJsonUpdater;
//# sourceMappingURL=PackageJsonUpdater.js.map