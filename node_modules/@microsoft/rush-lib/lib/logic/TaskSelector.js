"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_core_library_1 = require("@microsoft/node-core-library");
const ProjectTask_1 = require("../logic/taskRunner/ProjectTask");
const PackageChangeAnalyzer_1 = require("./PackageChangeAnalyzer");
const TaskCollection_1 = require("./taskRunner/TaskCollection");
/**
 * This class is responsible for:
 *  - based on to/from flags, solving the dependency graph and figuring out which projects need to be run
 *  - creating a ProjectTask for each project that needs to be built
 *  - registering the necessary ProjectTasks with the TaskRunner, which actually orchestrates execution
 */
class TaskSelector {
    constructor(options) {
        this._options = options;
        this._packageChangeAnalyzer = new PackageChangeAnalyzer_1.PackageChangeAnalyzer(options.rushConfiguration);
        this._taskCollection = new TaskCollection_1.TaskCollection({
            quietMode: options.isQuietMode
        });
        try {
            this._rushLinkJson = node_core_library_1.JsonFile.load(this._options.rushConfiguration.rushLinkJsonFilename);
        }
        catch (error) {
            throw new Error(`Could not read "${this._options.rushConfiguration.rushLinkJsonFilename}".`
                + ` Did you run "rush install" or "rush update"?`);
        }
    }
    registerTasks() {
        if (this._options.toFlags.length > 0) {
            this._registerToFlags(this._options.toFlags);
        }
        if (this._options.fromFlags.length > 0) {
            this._registerFromFlags(this._options.fromFlags);
        }
        if (this._options.toFlags.length === 0 && this._options.fromFlags.length === 0) {
            this._registerAll();
        }
        return this._taskCollection;
    }
    _registerToFlags(toFlags) {
        const dependencies = new Set();
        for (const toFlag of toFlags) {
            const toProject = this._options.rushConfiguration.findProjectByShorthandName(toFlag);
            if (!toProject) {
                throw new Error(`The project '${toFlag}' does not exist in rush.json`);
            }
            this._collectAllDependencies(toProject.packageName, dependencies);
        }
        // Register any dependencies it may have
        for (const dependency of dependencies) {
            this._registerTask(this._options.rushConfiguration.getProjectByName(dependency));
        }
        if (!this._options.ignoreDependencyOrder) {
            // Add ordering relationships for each dependency
            for (const dependency of dependencies) {
                this._taskCollection.addDependencies(dependency, this._rushLinkJson.localLinks[dependency] || []);
            }
        }
    }
    _registerFromFlags(fromFlags) {
        this._buildDependentGraph();
        const dependents = new Set();
        for (const fromFlag of fromFlags) {
            const fromProject = this._options.rushConfiguration.findProjectByShorthandName(fromFlag);
            if (!fromProject) {
                throw new Error(`The project '${fromFlag}' does not exist in rush.json`);
            }
            this._collectAllDependents(fromProject.packageName, dependents);
        }
        // Register all downstream dependents
        for (const dependent of dependents) {
            this._registerTask(this._options.rushConfiguration.getProjectByName(dependent));
        }
        if (!this._options.ignoreDependencyOrder) {
            // Only add ordering relationships for projects which have been registered
            // e.g. package C may depend on A & B, but if we are only building A's downstream, we will ignore B
            for (const dependent of dependents) {
                this._taskCollection.addDependencies(dependent, (this._rushLinkJson.localLinks[dependent] || []).filter(dep => dependents.has(dep)));
            }
        }
    }
    _registerAll() {
        // Register all tasks
        for (const rushProject of this._options.rushConfiguration.projects) {
            this._registerTask(rushProject);
        }
        if (!this._options.ignoreDependencyOrder) {
            // Add ordering relationships for each dependency
            for (const projectName of Object.keys(this._rushLinkJson.localLinks)) {
                this._taskCollection.addDependencies(projectName, this._rushLinkJson.localLinks[projectName]);
            }
        }
    }
    /**
     * Collects all upstream dependencies for a certain project
     */
    _collectAllDependencies(project, result) {
        if (!result.has(project)) {
            result.add(project);
            for (const dependency of this._rushLinkJson.localLinks[project] || []) {
                this._collectAllDependencies(dependency, result);
            }
        }
    }
    /**
     * Collects all downstream dependents of a certain project
     */
    _collectAllDependents(project, result) {
        if (!result.has(project)) {
            result.add(project);
            for (const dependent of (this._dependentList.get(project) || new Set())) {
                this._collectAllDependents(dependent, result);
            }
        }
    }
    /**
     * Inverts the localLinks to arrive at the dependent graph. This helps when using the --from flag
     */
    _buildDependentGraph() {
        this._dependentList = new Map();
        for (const project of Object.keys(this._rushLinkJson.localLinks)) {
            for (const dep of this._rushLinkJson.localLinks[project]) {
                if (!this._dependentList.has(dep)) {
                    this._dependentList.set(dep, new Set());
                }
                this._dependentList.get(dep).add(project);
            }
        }
    }
    _registerTask(project) {
        if (project) {
            const projectTask = new ProjectTask_1.ProjectTask({
                rushProject: project,
                rushConfiguration: this._options.rushConfiguration,
                commandToRun: this._getScriptToRun(project),
                isIncrementalBuildAllowed: this._options.isIncrementalBuildAllowed,
                packageChangeAnalyzer: this._packageChangeAnalyzer,
                packageDepsFilename: this._options.packageDepsFilename
            });
            if (!this._taskCollection.hasTask(projectTask.name)) {
                this._taskCollection.addTask(projectTask);
            }
        }
    }
    _getScriptToRun(rushProject) {
        const script = this._getScriptCommand(rushProject, this._options.commandToRun);
        if (script === undefined && !this._options.ignoreMissingScript) {
            // tslint:disable-next-line:max-line-length
            throw new Error(`The project [${rushProject.packageName}] does not define a '${this._options.commandToRun}' command in the 'scripts' section of its package.json`);
        }
        if (!script) {
            return '';
        }
        const taskCommand = `${script} ${this._options.customParameterValues.join(' ')}`;
        return process.platform === 'win32'
            ? ProjectTask_1.convertSlashesForWindows(taskCommand)
            : taskCommand;
    }
    _getScriptCommand(rushProject, script) {
        // tslint:disable-next-line:no-string-literal
        if (!rushProject.packageJson.scripts) {
            return undefined;
        }
        const rawCommand = rushProject.packageJson.scripts[script];
        // tslint:disable-next-line:no-null-keyword
        if (rawCommand === undefined || rawCommand === null) {
            return undefined;
        }
        return rawCommand;
    }
}
exports.TaskSelector = TaskSelector;
//# sourceMappingURL=TaskSelector.js.map