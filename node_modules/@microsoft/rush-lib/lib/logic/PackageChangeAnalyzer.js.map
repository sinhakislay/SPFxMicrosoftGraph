{"version":3,"file":"PackageChangeAnalyzer.js","sourceRoot":"","sources":["../../src/logic/PackageChangeAnalyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport * as colors from 'colors';\r\n\r\nimport {\r\n  getPackageDeps,\r\n  getGitHashForFiles,\r\n  IPackageDeps\r\n} from '@microsoft/package-deps-hash';\r\nimport {\r\n  Path,\r\n  InternalError,\r\n  FileSystem\r\n} from '@microsoft/node-core-library';\r\n\r\nimport { RushConfiguration } from '../api/RushConfiguration';\r\nimport { Git } from './Git';\r\nimport { PnpmProjectDependencyManifest } from './pnpm/PnpmProjectDependencyManifest';\r\nimport { RushConfigurationProject } from '../api/RushConfigurationProject';\r\n\r\nexport class PackageChangeAnalyzer {\r\n  // Allow this function to be overwritten during unit tests\r\n  public static getPackageDeps: (path: string, ignoredFiles: string[]) => IPackageDeps;\r\n\r\n  private _data: Map<string, IPackageDeps>;\r\n  private _rushConfiguration: RushConfiguration;\r\n  private _isGitSupported: boolean;\r\n\r\n  public constructor(rushConfiguration: RushConfiguration) {\r\n    this._rushConfiguration = rushConfiguration;\r\n    this._isGitSupported = Git.isPathUnderGitWorkingTree();\r\n    this._data = this._getData();\r\n  }\r\n\r\n  public getPackageDepsHash(projectName: string): IPackageDeps | undefined {\r\n    if (!this._data) {\r\n      this._data = this._getData();\r\n    }\r\n\r\n    return this._data.get(projectName);\r\n  }\r\n\r\n  private _getData(): Map<string, IPackageDeps> {\r\n    // If we are not in a unit test, use the correct resources\r\n    if (!PackageChangeAnalyzer.getPackageDeps) {\r\n      PackageChangeAnalyzer.getPackageDeps = getPackageDeps;\r\n    }\r\n\r\n    const projectHashDeps: Map<string, IPackageDeps> = new Map<string, IPackageDeps>();\r\n\r\n    // pre-populate the map with the projects from the config\r\n    for (const project of this._rushConfiguration.projects) {\r\n      projectHashDeps.set(project.packageName, {\r\n        files: {}\r\n      });\r\n    }\r\n\r\n    const noProjectHashes: { [key: string]: string } = {};\r\n\r\n    let repoDeps: IPackageDeps;\r\n    try {\r\n      if (this._isGitSupported) {\r\n        // Load the package deps hash for the whole repository\r\n        repoDeps = PackageChangeAnalyzer.getPackageDeps(this._rushConfiguration.rushJsonFolder, []);\r\n      } else {\r\n        return projectHashDeps;\r\n      }\r\n    } catch (e) {\r\n      // If getPackageDeps fails, don't fail the whole build. Treat this case as if we don't know anything about\r\n      // the state of the files in the repo. This can happen if the environment doesn't have Git.\r\n      console.log(colors.yellow(\r\n        `Error calculating the state of the repo. (inner error: ${e}). Continuing without diffing files.`\r\n      ));\r\n\r\n      return projectHashDeps;\r\n    }\r\n\r\n    // Sort each project folder into its own package deps hash\r\n    Object.keys(repoDeps.files).forEach((filePath: string) => {\r\n      const fileHash: string = repoDeps.files[filePath];\r\n\r\n      const projectName: string | undefined = this._getProjectForFile(filePath);\r\n\r\n      // If we found a project for the file, go ahead and store this file's hash\r\n      if (projectName) {\r\n        projectHashDeps.get(projectName)!.files[filePath] = fileHash;\r\n      } else {\r\n        noProjectHashes[filePath] = fileHash;\r\n      }\r\n    });\r\n\r\n    /* Incremental Build notes:\r\n     *\r\n     * Temporarily revert below code in favor of replacing this solution with something more\r\n     * flexible. Idea is essentially that we should have gulp-core-build (or other build tool)\r\n     * create the package-deps_<command>.json. The build tool would default to using the 'simple'\r\n     * algorithm (e.g. only files that are in a project folder are associated with the project), however it would\r\n     * also provide a hook which would allow certain tasks to modify the package-deps-hash before being written.\r\n     * At the end of the build, a we would create a package-deps_<command>.json file like so:\r\n     *\r\n     *  {\r\n     *    commandLine: [\"--production\"],\r\n     *    files: {\r\n     *      \"src/index.ts\": \"478789a7fs8a78989afd8\",\r\n     *      \"src/fileOne.ts\": \"a8sfa8979871fdjiojlk\",\r\n     *      \"common/api/review\": \"324598afasfdsd\",                      // this entry was added by the API Extractor\r\n     *                                                                  //  task (for example)\r\n     *      \".rush/temp/shrinkwrap-deps.json\": \"3428789dsafdsfaf\"       // this is a file which will be created by rush\r\n     *                                                                  //  link describing the state of the\r\n     *                                                                  //  node_modules folder\r\n     *    }\r\n     *  }\r\n     *\r\n     * Verifying this file should be fairly straightforward, we would simply need to check if:\r\n     *   A) no files were added or deleted from the current folder\r\n     *   B) all file hashes match\r\n     *   C) the node_modules hash/contents match\r\n     *   D) the command line parameters match or are compatible\r\n     *\r\n     *   Notes:\r\n     *   * We need to store the command line arguments, which is currently done by rush instead of GCB\r\n     *   * We need to store the hash/text of the a file which describes the state of the node_modules folder\r\n     *   * The package-deps_<command>.json should be a complete list of dependencies, and it should be extremely cheap\r\n     *       to validate/check the file (even if creating it is more computationally costly).\r\n     */\r\n\r\n    // Add the \"NO_PROJECT\" files to every project's dependencies\r\n    // for (const project of PackageChangeAnalyzer.rushConfig.projects) {\r\n    //  Object.keys(noProjectHashes).forEach((filePath: string) => {\r\n    //    const fileHash: string = noProjectHashes[filePath];\r\n    //    projectHashDeps.get(project.packageName).files[filePath] = fileHash;\r\n    //  });\r\n    // }\r\n\r\n    if (\r\n      this._rushConfiguration.packageManager === 'pnpm' &&\r\n      !this._rushConfiguration.experimentsConfiguration.configuration.legacyIncrementalBuildDependencyDetection\r\n    ) {\r\n      const projects: RushConfigurationProject[] = [];\r\n      const projectDependencyManifestPaths: string[] = [];\r\n\r\n      for (const project of this._rushConfiguration.projects) {\r\n        const dependencyManifestFilePath: string = PnpmProjectDependencyManifest.getFilePathForProject(project);\r\n        const relativeDependencyManifestFilePath: string = path.relative(\r\n          this._rushConfiguration.rushJsonFolder,\r\n          dependencyManifestFilePath\r\n        ).replace(/\\\\/g, '/');\r\n\r\n        if (!FileSystem.exists(dependencyManifestFilePath)) {\r\n          throw new Error(\r\n            `A project dependency file (${relativeDependencyManifestFilePath}) is missing. You may need to run ` +\r\n            '\"rush unlink\" and \"rush link\".'\r\n          );\r\n        }\r\n\r\n        projects.push(project);\r\n        projectDependencyManifestPaths.push(relativeDependencyManifestFilePath);\r\n      }\r\n\r\n      const hashes: Map<string, string> = getGitHashForFiles(\r\n        projectDependencyManifestPaths,\r\n        this._rushConfiguration.rushJsonFolder\r\n      );\r\n      for (let i: number = 0; i < projects.length; i++) {\r\n        const project: RushConfigurationProject = projects[i];\r\n        const projectDependencyManifestPath: string = projectDependencyManifestPaths[i];\r\n        if (!hashes.has(projectDependencyManifestPath)) {\r\n          throw new InternalError(`Expected to get a hash for ${projectDependencyManifestPath}`);\r\n        }\r\n        const hash: string = hashes.get(projectDependencyManifestPath)!;\r\n        projectHashDeps.get(project.packageName)!.files[projectDependencyManifestPath] = hash;\r\n      }\r\n    } else {\r\n      // Determine the current variant from the link JSON.\r\n      const variant: string | undefined = this._rushConfiguration.currentInstalledVariant;\r\n\r\n      // Add the shrinkwrap file to every project's dependencies\r\n      const shrinkwrapFile: string = path.relative(\r\n        this._rushConfiguration.rushJsonFolder,\r\n        this._rushConfiguration.getCommittedShrinkwrapFilename(variant)\r\n      ).replace(/\\\\/g, '/');\r\n\r\n      for (const project of this._rushConfiguration.projects) {\r\n        const shrinkwrapHash: string | undefined = noProjectHashes[shrinkwrapFile];\r\n        if (shrinkwrapHash) {\r\n          projectHashDeps.get(project.packageName)!.files[shrinkwrapFile] = shrinkwrapHash;\r\n        }\r\n      }\r\n    }\r\n\r\n    return projectHashDeps;\r\n  }\r\n\r\n  private _getProjectForFile(filePath: string): string | undefined {\r\n    for (const project of this._rushConfiguration.projects) {\r\n      if (this._fileExistsInFolder(filePath, project.projectRelativeFolder)) {\r\n        return project.packageName;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  private _fileExistsInFolder(filePath: string, folderPath: string): boolean {\r\n    return Path.isUnder(filePath, folderPath);\r\n  }\r\n}\r\n"]}