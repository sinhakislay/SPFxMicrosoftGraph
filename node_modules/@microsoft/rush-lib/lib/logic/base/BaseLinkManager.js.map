{"version":3,"file":"BaseLinkManager.js","sourceRoot":"","sources":["../../../src/logic/base/BaseLinkManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as colors from 'colors';\r\nimport * as fs from 'fs';\r\nimport * as os from 'os';\r\nimport * as path from 'path';\r\n\r\nimport { FileSystem, IFileSystemCreateLinkOptions, InternalError } from '@microsoft/node-core-library';\r\n\r\nimport { RushConfiguration } from '../../api/RushConfiguration';\r\nimport { Utilities } from '../../utilities/Utilities';\r\nimport { Stopwatch } from '../../utilities/Stopwatch';\r\nimport { BasePackage } from './BasePackage';\r\nimport { EnvironmentConfiguration } from '../../api/EnvironmentConfiguration';\r\n\r\nexport enum SymlinkKind {\r\n  File,\r\n  Directory\r\n}\r\n\r\nexport interface IBaseLinkManagerCreateSymlinkOptions extends IFileSystemCreateLinkOptions {\r\n  symlinkKind: SymlinkKind;\r\n}\r\n\r\nexport abstract class BaseLinkManager {\r\n  protected _rushConfiguration: RushConfiguration;\r\n\r\n  protected static _createSymlink(options: IBaseLinkManagerCreateSymlinkOptions): void {\r\n    const newLinkFolder: string = path.dirname(options.newLinkPath);\r\n    FileSystem.ensureFolder(newLinkFolder);\r\n\r\n    let targetPath: string;\r\n    if (EnvironmentConfiguration.absoluteSymlinks) {\r\n        targetPath = options.linkTargetPath;\r\n    } else {\r\n      // Link to the relative path, to avoid going outside containers such as a Docker image\r\n      targetPath = path.relative(\r\n        fs.realpathSync(newLinkFolder),\r\n        options.linkTargetPath\r\n      );\r\n    }\r\n\r\n    if (process.platform === 'win32') {\r\n      if (options.symlinkKind === SymlinkKind.Directory) {\r\n        // For directories, we use a Windows \"junction\".  On Unix, this produces a regular symlink.\r\n        FileSystem.createSymbolicLinkJunction({\r\n          linkTargetPath: targetPath,\r\n          newLinkPath: options.newLinkPath\r\n        });\r\n      } else {\r\n        // For files, we use a Windows \"hard link\", because creating a symbolic link requires\r\n        // administrator permission.\r\n\r\n        // NOTE: We cannot use the relative path for hard links\r\n        FileSystem.createHardLink({\r\n          linkTargetPath: options.linkTargetPath,\r\n          newLinkPath: options.newLinkPath\r\n        });\r\n      }\r\n    } else {\r\n      // However hard links seem to cause build failures on Mac, so for all other operating systems\r\n      // we use symbolic links for this case.\r\n      if (options.symlinkKind === SymlinkKind.Directory) {\r\n        FileSystem.createSymbolicLinkFolder({\r\n          linkTargetPath: targetPath,\r\n          newLinkPath: options.newLinkPath\r\n        });\r\n      } else {\r\n        FileSystem.createSymbolicLinkFile({\r\n          linkTargetPath: targetPath,\r\n          newLinkPath: options.newLinkPath\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For a Package object that represents a top-level Rush project folder\r\n   * (i.e. with source code that we will be building), this clears out its\r\n   * node_modules folder and then recursively creates all the symlinked folders.\r\n   */\r\n  protected static _createSymlinksForTopLevelProject(localPackage: BasePackage): void {\r\n    const localModuleFolder: string = path.join(localPackage.folderPath, 'node_modules');\r\n\r\n    // Sanity check\r\n    if (localPackage.parent) {\r\n      throw new Error('The provided package is not a top-level project');\r\n    }\r\n\r\n    // The root-level folder is the project itself, so we simply delete its node_modules\r\n    // to start clean\r\n    console.log('Purging ' + localModuleFolder);\r\n    Utilities.dangerouslyDeletePath(localModuleFolder);\r\n\r\n    if (localPackage.children.length > 0) {\r\n      Utilities.createFolderWithRetry(localModuleFolder);\r\n\r\n      for (const child of localPackage.children) {\r\n        BaseLinkManager._createSymlinksForDependencies(child);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This is a helper function used by createSymlinksForTopLevelProject().\r\n   * It will recursively creates symlinked folders corresponding to each of the\r\n   * Package objects in the provided tree.\r\n   */\r\n  private static _createSymlinksForDependencies(localPackage: BasePackage): void {\r\n    const localModuleFolder: string = path.join(localPackage.folderPath, 'node_modules');\r\n\r\n    if (!localPackage.symlinkTargetFolderPath) {\r\n      throw new InternalError('localPackage.symlinkTargetFolderPath was not assigned');\r\n    }\r\n\r\n    // This is special case for when localPackage.name has the form '@scope/name',\r\n    // in which case we need to create the '@scope' folder first.\r\n    const parentFolderPath: string = path.dirname(localPackage.folderPath);\r\n    if (parentFolderPath && parentFolderPath !== localPackage.folderPath) {\r\n      if (!FileSystem.exists(parentFolderPath)) {\r\n        Utilities.createFolderWithRetry(parentFolderPath);\r\n      }\r\n    }\r\n\r\n    if (localPackage.children.length === 0) {\r\n      // If there are no children, then we can symlink the entire folder\r\n      BaseLinkManager._createSymlink({\r\n        linkTargetPath: localPackage.symlinkTargetFolderPath,\r\n        newLinkPath: localPackage.folderPath,\r\n        symlinkKind: SymlinkKind.Directory\r\n      });\r\n    } else {\r\n      // If there are children, then we need to symlink each item in the folder individually\r\n      Utilities.createFolderWithRetry(localPackage.folderPath);\r\n\r\n      for (const filename of FileSystem.readFolder(localPackage.symlinkTargetFolderPath)) {\r\n        if (filename.toLowerCase() !== 'node_modules') {\r\n          // Create the symlink\r\n          let symlinkKind: SymlinkKind = SymlinkKind.File;\r\n\r\n          const linkSource: string = path.join(localPackage.folderPath, filename);\r\n          let linkTarget: string = path.join(localPackage.symlinkTargetFolderPath, filename);\r\n\r\n          const linkStats: fs.Stats = FileSystem.getLinkStatistics(linkTarget);\r\n\r\n          if (linkStats.isSymbolicLink()) {\r\n\r\n            const targetStats: fs.Stats = FileSystem.getStatistics(FileSystem.getRealPath(linkTarget));\r\n            if (targetStats.isDirectory()) {\r\n              // Neither a junction nor a directory-symlink can have a directory-symlink\r\n              // as its target; instead, we must obtain the real physical path.\r\n              // A junction can link to another junction.  Unfortunately, the node 'fs' API\r\n              // lacks the ability to distinguish between a junction and a directory-symlink\r\n              // (even though it has the ability to create them both), so the safest policy\r\n              // is to always make a junction and always to the real physical path.\r\n              linkTarget = FileSystem.getRealPath(linkTarget);\r\n              symlinkKind = SymlinkKind.Directory;\r\n            }\r\n          } else if (linkStats.isDirectory()) {\r\n            symlinkKind = SymlinkKind.Directory;\r\n          }\r\n\r\n          BaseLinkManager._createSymlink({\r\n            linkTargetPath: linkTarget,\r\n            newLinkPath: linkSource,\r\n            symlinkKind\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    if (localPackage.children.length > 0) {\r\n      Utilities.createFolderWithRetry(localModuleFolder);\r\n\r\n      for (const child of localPackage.children) {\r\n        BaseLinkManager._createSymlinksForDependencies(child);\r\n      }\r\n    }\r\n  }\r\n\r\n  constructor(rushConfiguration: RushConfiguration) {\r\n    this._rushConfiguration = rushConfiguration;\r\n  }\r\n\r\n  /**\r\n   * Creates node_modules symlinks for all Rush projects defined in the RushConfiguration.\r\n   * @param force - Normally the operation will be skipped if the links are already up to date;\r\n   *   if true, this option forces the links to be recreated.\r\n   */\r\n  public createSymlinksForProjects(force: boolean): Promise<void> {\r\n    if (!force) {\r\n      if (FileSystem.exists(this._rushConfiguration.rushLinkJsonFilename)) {\r\n        console.log(colors.green(`Skipping linking -- everything is already up to date.`));\r\n        return Promise.resolve();\r\n      }\r\n    }\r\n\r\n    console.log('Linking projects together...');\r\n    const stopwatch: Stopwatch = Stopwatch.start();\r\n\r\n    // Delete the flag file if it exists; if we get interrupted, this will ensure that\r\n    // a full \"rush link\" is required next time\r\n    Utilities.deleteFile(this._rushConfiguration.rushLinkJsonFilename);\r\n\r\n    return this._linkProjects()\r\n      .then(() => {\r\n        stopwatch.stop();\r\n        console.log(os.EOL + colors.green(`Linking finished successfully. (${stopwatch.toString()})`));\r\n        console.log(os.EOL + 'Next you should probably run \"rush build\" or \"rush rebuild\"');\r\n      });\r\n  }\r\n\r\n  protected abstract _linkProjects(): Promise<void>;\r\n}\r\n"]}