{"version":3,"file":"NpmPackage.js","sourceRoot":"","sources":["../../../src/logic/npm/NpmPackage.ts"],"names":[],"mappings":"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","sourcesContent":["import * as path from 'path';\r\nimport readPackageTree = require('read-package-tree');\r\nimport {\r\n  JsonFile,\r\n  IPackageJson\r\n} from '@microsoft/node-core-library';\r\n\r\nimport {\r\n  BasePackage,\r\n  IRushTempPackageJson\r\n} from '../base/BasePackage';\r\n\r\n/**\r\n * Used by the \"rush link\" algorithm when doing NPM package resolution.\r\n */\r\nexport interface IResolveOrCreateResult {\r\n  found: BasePackage | undefined;\r\n  parentForCreate: BasePackage | undefined;\r\n}\r\n\r\n/**\r\n * The type of dependency; used by IPackageDependency.\r\n */\r\nexport enum PackageDependencyKind {\r\n  Normal,\r\n  /**\r\n   * The dependency was listed in the optionalDependencies section of package.json.\r\n   */\r\n  Optional,\r\n\r\n  /**\r\n   * The dependency should be a symlink to a project that is locally built by Rush..\r\n   */\r\n  LocalLink\r\n}\r\n\r\nexport interface IPackageDependency {\r\n  /**\r\n   * The name of the dependency\r\n   */\r\n  name: string;\r\n  /**\r\n   * The requested version, which may be a pattern such as \"^1.2.3\"\r\n   */\r\n  versionRange: string;\r\n\r\n  /**\r\n   * The kind of dependency\r\n   */\r\n  kind: PackageDependencyKind;\r\n}\r\n\r\nexport class NpmPackage extends BasePackage {\r\n  /**\r\n   * Names of packages that we explicitly depend on.  The actual dependency\r\n   * package may be found in this.children, or possibly in this.children of\r\n   * one of the parents.\r\n   * If a dependency is listed in the \"optionalDependencies\" section of package.json\r\n   * then its name here will be prepended with a \"?\" character, which means that Rush\r\n   * will not report an error if the module cannot be found in the Common folder.\r\n   */\r\n  public dependencies: IPackageDependency[];\r\n\r\n  /**\r\n   * Used by \"npm link\" when creating a Package object that represents symbolic links to be created.\r\n   */\r\n  public static createLinkedNpmPackage(name: string, version: string | undefined, dependencies: IPackageDependency[],\r\n    folderPath: string): NpmPackage {\r\n    return new NpmPackage(name, version, dependencies, folderPath);\r\n  }\r\n\r\n  /**\r\n   * Used by \"npm link\" to simulate a temp project that is missing from the common/node_modules\r\n   * folder (e.g. because it was added after the shrinkwrap file was regenerated).\r\n   * @param packageJsonFilename - Filename of the source package.json\r\n   *        Example: `C:\\MyRepo\\common\\temp\\projects\\project1\\package.json`\r\n   * @param targetFolderName - Filename where it should have been installed\r\n   *        Example: `C:\\MyRepo\\common\\temp\\node_modules\\@rush-temp\\project1`\r\n   */\r\n  public static createVirtualTempPackage(packageJsonFilename: string, installFolderName: string): NpmPackage {\r\n    const packageJson: IPackageJson = JsonFile.load(packageJsonFilename);\r\n    const npmPackage: readPackageTree.PackageNode = {\r\n      children: [],\r\n      error: undefined,\r\n      id: 0,\r\n      isLink: false,\r\n      package: packageJson,\r\n      parent: undefined,\r\n      path: installFolderName,\r\n      realpath: installFolderName\r\n    };\r\n    return NpmPackage.createFromNpm(npmPackage);\r\n  }\r\n\r\n  /**\r\n   * Recursive constructs a tree of NpmPackage objects using information returned\r\n   * by the \"read-package-tree\" library.\r\n   */\r\n  public static createFromNpm(npmPackage: readPackageTree.PackageNode): NpmPackage {\r\n    if (npmPackage.error) {\r\n      throw new Error(`Failed to parse package.json for ${path.basename(npmPackage.path)}:`\r\n        + ` ${npmPackage.error.message}`);\r\n    }\r\n\r\n    let dependencies: IPackageDependency[] = [];\r\n    const dependencyNames: Set<string> = new Set<string>();\r\n    const packageJson: IRushTempPackageJson = npmPackage.package;\r\n\r\n    if (packageJson.optionalDependencies) {\r\n      for (const dependencyName of Object.keys(packageJson.optionalDependencies)) {\r\n        if (!dependencyNames.has(dependencyName)) {\r\n          dependencyNames.add(dependencyName);\r\n          dependencies.push({\r\n            name: dependencyName,\r\n            versionRange: packageJson.optionalDependencies[dependencyName],\r\n            kind: PackageDependencyKind.Optional\r\n          });\r\n        }\r\n      }\r\n    }\r\n    if (packageJson.dependencies) {\r\n      for (const dependencyName of Object.keys(packageJson.dependencies)) {\r\n        if (!dependencyNames.has(dependencyName)) {\r\n          dependencyNames.add(dependencyName);\r\n          dependencies.push({\r\n            name: dependencyName,\r\n            versionRange: packageJson.dependencies[dependencyName],\r\n            kind: PackageDependencyKind.Normal\r\n          });\r\n        }\r\n      }\r\n    }\r\n    if (packageJson.rushDependencies) {\r\n      for (const dependencyName of Object.keys(packageJson.rushDependencies)) {\r\n        if (!dependencyNames.has(dependencyName)) {\r\n          dependencyNames.add(dependencyName);\r\n          dependencies.push({\r\n            name: dependencyName,\r\n            versionRange: packageJson.dependencies![dependencyName],\r\n            kind: PackageDependencyKind.LocalLink\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    dependencies = dependencies.sort((a, b) => a.name.localeCompare(b.name));\r\n\r\n    const newPackage: NpmPackage = new NpmPackage(\r\n      npmPackage.package.name,\r\n      npmPackage.package.version,\r\n      dependencies,\r\n      // NOTE: We don't use packageNode.realpath here, because if \"npm unlink\" was\r\n      // performed without redoing \"rush link\", then a broken symlink is better than\r\n      // a symlink to the wrong thing.\r\n      npmPackage.path\r\n    );\r\n\r\n    for (const child of npmPackage.children) {\r\n      newPackage.addChild(NpmPackage.createFromNpm(child));\r\n    }\r\n\r\n    return newPackage;\r\n  }\r\n\r\n  /**\r\n   * Searches the node_modules hierarchy for the nearest matching package with the\r\n   * given name.  Note that the nearest match may have an incompatible version.\r\n   * If a match is found, then the \"found\" result will not be undefined.\r\n   * In either case, the parentForCreate result indicates where the missing\r\n   * dependency can be added, i.e. if the requested dependency was not found\r\n   * or was found with an incompatible version.\r\n   *\r\n   * \"cyclicSubtreeRoot\" is a special optional parameter that specifies a different\r\n   * root for the tree; the cyclicDependencyProjects feature uses this to isolate\r\n   * certain devDependencies in their own subtree.\r\n   */\r\n  public resolveOrCreate(dependencyName: string, cyclicSubtreeRoot?: NpmPackage): IResolveOrCreateResult {\r\n    let currentParent: NpmPackage = this;\r\n    let parentForCreate: NpmPackage | undefined = undefined;\r\n\r\n    // tslint:disable-next-line:no-constant-condition\r\n    while (true) {\r\n      // Does any child match?\r\n      for (const child of currentParent.children) {\r\n        // The package.json name can differ from the installation folder name, in the case of an NPM package alias\r\n        // such as this:\r\n        //\r\n        // \"dependencies\": {\r\n        //   \"@alias-scope/alias-name\": \"npm:target-name@^1.2.3\"\r\n        // }\r\n        //\r\n        // Thus we need to compare child.installedName instead of child.name:\r\n        if (child.installedName === dependencyName) {\r\n          // One of the children matched.  Note that parentForCreate may be\r\n          // undefined, e.g. if an immediate child is found but has the wrong version,\r\n          // then we have no place in the tree to create another version.\r\n          return { found: child, parentForCreate };\r\n        }\r\n      }\r\n\r\n      // If no child matched, then make this node the \"parentForCreate\" where we\r\n      // could add a missing dependency.\r\n      parentForCreate = currentParent;\r\n\r\n      if (!currentParent.parent\r\n        || (cyclicSubtreeRoot && currentParent === cyclicSubtreeRoot)) {\r\n        // We reached the root without finding a match\r\n        // parentForCreate will be the root.\r\n        return { found: undefined, parentForCreate };\r\n      }\r\n\r\n      // Continue walking upwards.\r\n      currentParent = currentParent.parent as NpmPackage;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Searches the node_modules hierarchy for the nearest matching package with the\r\n   * given name.  If no match is found, then undefined is returned.\r\n   */\r\n  public resolve(dependencyName: string): NpmPackage | undefined {\r\n    return this.resolveOrCreate(dependencyName).found as NpmPackage;\r\n  }\r\n\r\n  private constructor(name: string,\r\n    version: string | undefined,\r\n    dependencies: IPackageDependency[],\r\n    folderPath: string) {\r\n\r\n    super(name, version, folderPath, undefined);\r\n    this.dependencies = dependencies.slice(0); // clone the array\r\n    this.parent = undefined;\r\n  }\r\n}"]}