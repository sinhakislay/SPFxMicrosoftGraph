"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const glob = require("glob");
const colors = require("colors");
const fetch = require("node-fetch");
const HttpsProxyAgent = require("https-proxy-agent");
const os = require("os");
const path = require("path");
const semver = require("semver");
const tar = require("tar");
const globEscape = require("glob-escape");
const node_core_library_1 = require("@microsoft/node-core-library");
const ApprovedPackagesChecker_1 = require("../logic/ApprovedPackagesChecker");
const PolicyValidator_1 = require("../logic/policy/PolicyValidator");
const Git_1 = require("../logic/Git");
const LastInstallFlag_1 = require("../api/LastInstallFlag");
const LinkManagerFactory_1 = require("../logic/LinkManagerFactory");
const RushConstants_1 = require("../logic/RushConstants");
const ShrinkwrapFileFactory_1 = require("../logic/ShrinkwrapFileFactory");
const Stopwatch_1 = require("../utilities/Stopwatch");
const Utilities_1 = require("../utilities/Utilities");
const Rush_1 = require("../api/Rush");
const AlreadyReportedError_1 = require("../utilities/AlreadyReportedError");
// The PosixModeBits are intended to be used with bitwise operations.
// tslint:disable:no-bitwise
const MAX_INSTALL_ATTEMPTS = 2;
const DependencySpecifier_1 = require("./DependencySpecifier");
/**
 * This class implements common logic between "rush install" and "rush update".
 */
class InstallManager {
    /**
     * Returns a map of all direct dependencies that only have a single semantic version specifier.
     * Returns a map: dependency name --> version specifier
     */
    static collectImplicitlyPreferredVersions(rushConfiguration, options = {}) {
        // First, collect all the direct dependencies of all local projects, and their versions:
        // direct dependency name --> set of version specifiers
        const versionsForDependencies = new Map();
        rushConfiguration.projects.forEach((project) => {
            InstallManager._collectVersionsForDependencies(rushConfiguration, {
                versionsForDependencies,
                dependencies: project.packageJsonEditor.dependencyList,
                cyclicDependencies: project.cyclicDependencyProjects,
                variant: options.variant
            });
            InstallManager._collectVersionsForDependencies(rushConfiguration, {
                versionsForDependencies,
                dependencies: project.packageJsonEditor.devDependencyList,
                cyclicDependencies: project.cyclicDependencyProjects,
                variant: options.variant
            });
        });
        // If any dependency has more than one version, then filter it out (since we don't know which version
        // should be preferred).  What remains will be the list of preferred dependencies.
        // dependency --> version specifier
        const implicitlyPreferred = new Map();
        versionsForDependencies.forEach((versions, dep) => {
            if (versions.size === 1) {
                const version = versions.values().next().value;
                implicitlyPreferred.set(dep, version);
            }
        });
        return implicitlyPreferred;
    }
    // Helper for collectImplicitlyPreferredVersions()
    static _updateVersionsForDependencies(versionsForDependencies, dependency, version) {
        if (!versionsForDependencies.has(dependency)) {
            versionsForDependencies.set(dependency, new Set());
        }
        versionsForDependencies.get(dependency).add(version);
    }
    // Helper for collectImplicitlyPreferredVersions()
    static _collectVersionsForDependencies(rushConfiguration, options) {
        const { variant, dependencies, versionsForDependencies, cyclicDependencies } = options;
        const commonVersions = rushConfiguration.getCommonVersions(variant);
        const allowedAlternativeVersions = commonVersions.allowedAlternativeVersions;
        for (const dependency of dependencies) {
            const alternativesForThisDependency = allowedAlternativeVersions.get(dependency.name) || [];
            // For each dependency, collectImplicitlyPreferredVersions() is collecting the set of all version specifiers
            // that appear across the repo.  If there is only one version specifier, then that's the "preferred" one.
            // However, there are a few cases where additional version specifiers can be safely ignored.
            let ignoreVersion = false;
            // 1. If the version specifier was listed in "allowedAlternativeVersions", then it's never a candidate.
            //    (Even if it's the only version specifier anywhere in the repo, we still ignore it, because
            //    otherwise the rule would be difficult to explain.)
            if (alternativesForThisDependency.indexOf(dependency.version) > 0) {
                ignoreVersion = true;
            }
            else {
                // Is it a local project?
                const localProject = rushConfiguration.getProjectByName(dependency.name);
                if (localProject) {
                    // 2. If it's a symlinked local project, then it's not a candidate, because the package manager will
                    //    never even see it.
                    // However there are two ways that a local project can NOT be symlinked:
                    // - if the local project doesn't satisfy the referenced semver specifier; OR
                    // - if the local project was specified in "cyclicDependencyProjects" in rush.json
                    if (semver.satisfies(localProject.packageJsonEditor.version, dependency.version)
                        && !cyclicDependencies.has(dependency.name)) {
                        ignoreVersion = true;
                    }
                }
                if (!ignoreVersion) {
                    InstallManager._updateVersionsForDependencies(versionsForDependencies, dependency.name, dependency.version);
                }
            }
        }
    }
    get commonNodeModulesMarker() {
        return this._commonNodeModulesMarker;
    }
    constructor(rushConfiguration, rushGlobalFolder, purgeManager, options) {
        this._rushConfiguration = rushConfiguration;
        this._rushGlobalFolder = rushGlobalFolder;
        this._commonTempFolderRecycler = purgeManager.commonTempFolderRecycler;
        this._options = options;
        this._commonNodeModulesMarker = new LastInstallFlag_1.LastInstallFlag(this._rushConfiguration.commonTempFolder, {
            node: process.versions.node,
            packageManager: rushConfiguration.packageManager,
            packageManagerVersion: rushConfiguration.packageManagerToolVersion
        });
    }
    doInstall() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this._options;
            // Check the policies
            PolicyValidator_1.PolicyValidator.validatePolicy(this._rushConfiguration, options.bypassPolicy);
            // Git hooks are only installed if the repo opts in by including files in /common/git-hooks
            const hookSource = path.join(this._rushConfiguration.commonFolder, 'git-hooks');
            const hookDestination = Git_1.Git.getHooksFolder();
            if (node_core_library_1.FileSystem.exists(hookSource) && hookDestination) {
                const hookFilenames = node_core_library_1.FileSystem.readFolder(hookSource);
                if (hookFilenames.length > 0) {
                    console.log(os.EOL + colors.bold('Found files in the "common/git-hooks" folder.'));
                    // Clear the currently installed git hooks and install fresh copies
                    node_core_library_1.FileSystem.ensureEmptyFolder(hookDestination);
                    // Only copy files that look like Git hook names
                    const filteredHookFilenames = hookFilenames.filter(x => /^[a-z\-]+/.test(x));
                    for (const filename of filteredHookFilenames) {
                        node_core_library_1.FileSystem.copyFile({
                            sourcePath: path.join(hookSource, filename),
                            destinationPath: path.join(hookDestination, filename)
                        });
                        node_core_library_1.FileSystem.changePosixModeBits(path.join(hookDestination, filename), 256 /* UserRead */ | 64 /* UserExecute */);
                    }
                    console.log('Successfully installed these Git hook scripts: ' + filteredHookFilenames.join(', ') + os.EOL);
                }
            }
            const approvedPackagesChecker = new ApprovedPackagesChecker_1.ApprovedPackagesChecker(this._rushConfiguration);
            if (approvedPackagesChecker.approvedPackagesFilesAreOutOfDate) {
                if (this._options.allowShrinkwrapUpdates) {
                    approvedPackagesChecker.rewriteConfigFiles();
                    console.log(colors.yellow('Approved package files have been updated. These updates should be committed to source control'));
                }
                else {
                    throw new Error(`Approved packages files are out-of date. Run "rush update" to update them.`);
                }
            }
            // Ensure that the package manager is installed
            yield this.ensureLocalPackageManager();
            let shrinkwrapFile = undefined;
            // (If it's a full update, then we ignore the shrinkwrap from Git since it will be overwritten)
            if (!options.fullUpgrade) {
                try {
                    shrinkwrapFile = ShrinkwrapFileFactory_1.ShrinkwrapFileFactory.getShrinkwrapFile(this._rushConfiguration.packageManager, this._rushConfiguration.getCommittedShrinkwrapFilename(options.variant));
                }
                catch (ex) {
                    console.log();
                    console.log(`Unable to load the ${this._shrinkwrapFilePhrase}: ${ex.message}`);
                    if (!options.allowShrinkwrapUpdates) {
                        console.log();
                        console.log(colors.red('You need to run "rush update" to fix this problem'));
                        throw new AlreadyReportedError_1.AlreadyReportedError();
                    }
                    shrinkwrapFile = undefined;
                }
            }
            // Write a file indicating which variant is being installed.
            // This will be used by bulk scripts to determine the correct Shrinkwrap file to track.
            const currentVariantJsonFilename = this._rushConfiguration.currentVariantJsonFilename;
            const currentVariantJson = {
                variant: options.variant || null // tslint:disable-line:no-null-keyword
            };
            // Determine if the variant is already current by updating current-variant.json.
            // If nothing is written, the variant has not changed.
            const variantIsUpToDate = !node_core_library_1.JsonFile.save(currentVariantJson, currentVariantJsonFilename, {
                onlyIfChanged: true
            });
            if (options.variant) {
                console.log();
                console.log(colors.bold(`Using variant '${options.variant}' for installation.`));
            }
            else if (!variantIsUpToDate && !options.variant) {
                console.log();
                console.log(colors.bold('Using the default variant for installation.'));
            }
            const shrinkwrapIsUpToDate = this._createTempModulesAndCheckShrinkwrap({
                shrinkwrapFile,
                variant: options.variant
            }) && !options.recheckShrinkwrap;
            if (!shrinkwrapIsUpToDate) {
                if (!options.allowShrinkwrapUpdates) {
                    console.log();
                    console.log(colors.red(`The ${this._shrinkwrapFilePhrase} is out of date. You need to run "rush update".`));
                    throw new AlreadyReportedError_1.AlreadyReportedError();
                }
            }
            yield this._installCommonModules(Object.assign({ shrinkwrapIsUpToDate,
                variantIsUpToDate }, options));
            if (!options.noLink) {
                const linkManager = LinkManagerFactory_1.LinkManagerFactory.getLinkManager(this._rushConfiguration);
                yield linkManager.createSymlinksForProjects(false);
            }
            else {
                console.log(os.EOL + colors.yellow('Since "--no-link" was specified, you will need to run "rush link" manually.'));
            }
        });
    }
    /**
     * If the "(p)npm-local" symlink hasn't been set up yet, this creates it, installing the
     * specified (P)npm version in the user's home directory if needed.
     */
    ensureLocalPackageManager() {
        // Example: "C:\Users\YourName\.rush"
        const rushUserFolder = this._rushGlobalFolder.nodeSpecificPath;
        if (!node_core_library_1.FileSystem.exists(rushUserFolder)) {
            console.log('Creating ' + rushUserFolder);
            node_core_library_1.FileSystem.ensureFolder(rushUserFolder);
        }
        const packageManager = this._rushConfiguration.packageManager;
        const packageManagerVersion = this._rushConfiguration.packageManagerToolVersion;
        const packageManagerAndVersion = `${packageManager}-${packageManagerVersion}`;
        // Example: "C:\Users\YourName\.rush\pnpm-1.2.3"
        const packageManagerToolFolder = path.join(rushUserFolder, packageManagerAndVersion);
        const packageManagerMarker = new LastInstallFlag_1.LastInstallFlag(packageManagerToolFolder, {
            node: process.versions.node
        });
        console.log(`Trying to acquire lock for ${packageManagerAndVersion}`);
        return node_core_library_1.LockFile.acquire(rushUserFolder, packageManagerAndVersion).then((lock) => {
            console.log(`Acquired lock for ${packageManagerAndVersion}`);
            if (!packageManagerMarker.isValid() || lock.dirtyWhenAcquired) {
                console.log(colors.bold(`Installing ${packageManager} version ${packageManagerVersion}${os.EOL}`));
                // note that this will remove the last-install flag from the directory
                Utilities_1.Utilities.installPackageInDirectory({
                    directory: packageManagerToolFolder,
                    packageName: packageManager,
                    version: this._rushConfiguration.packageManagerToolVersion,
                    tempPackageTitle: `${packageManager}-local-install`,
                    maxInstallAttempts: MAX_INSTALL_ATTEMPTS,
                    // This is using a local configuration to install a package in a shared global location.
                    // Generally that's a bad practice, but in this case if we can successfully install
                    // the package at all, we can reasonably assume it's good for all the repositories.
                    // In particular, we'll assume that two different NPM registries cannot have two
                    // different implementations of the same version of the same package.
                    // This was needed for: https://github.com/microsoft/rushstack/issues/691
                    commonRushConfigFolder: this._rushConfiguration.commonRushConfigFolder
                });
                console.log(`Successfully installed ${packageManager} version ${packageManagerVersion}`);
            }
            else {
                console.log(`Found ${packageManager} version ${packageManagerVersion} in ${packageManagerToolFolder}`);
            }
            packageManagerMarker.create();
            // Example: "C:\MyRepo\common\temp"
            node_core_library_1.FileSystem.ensureFolder(this._rushConfiguration.commonTempFolder);
            // Example: "C:\MyRepo\common\temp\pnpm-local"
            const localPackageManagerToolFolder = path.join(this._rushConfiguration.commonTempFolder, `${packageManager}-local`);
            console.log(os.EOL + 'Symlinking "' + localPackageManagerToolFolder + '"');
            console.log('  --> "' + packageManagerToolFolder + '"');
            // We cannot use FileSystem.exists() to test the existence of a symlink, because it will
            // return false for broken symlinks.  There is no way to test without catching an exception.
            try {
                node_core_library_1.FileSystem.deleteFolder(localPackageManagerToolFolder);
            }
            catch (error) {
                if (error.code !== 'ENOENT') {
                    throw error;
                }
            }
            node_core_library_1.FileSystem.createSymbolicLinkJunction({
                linkTargetPath: packageManagerToolFolder,
                newLinkPath: localPackageManagerToolFolder
            });
            lock.release();
        });
    }
    /**
     * Regenerates the common/package.json and all temp_modules projects.
     * If shrinkwrapFile is provided, this function also validates whether it contains
     * everything we need to install and returns true if so; in all other cases,
     * the return value is false.
     */
    _createTempModulesAndCheckShrinkwrap(options) {
        const { shrinkwrapFile, variant } = options;
        const stopwatch = Stopwatch_1.Stopwatch.start();
        // Example: "C:\MyRepo\common\temp\projects"
        const tempProjectsFolder = path.join(this._rushConfiguration.commonTempFolder, RushConstants_1.RushConstants.rushTempProjectsFolderName);
        console.log(os.EOL + colors.bold('Updating temp projects in ' + tempProjectsFolder));
        Utilities_1.Utilities.createFolderWithRetry(tempProjectsFolder);
        const shrinkwrapWarnings = [];
        // We will start with the assumption that it's valid, and then set it to false if
        // any of the checks fail
        let shrinkwrapIsUpToDate = true;
        if (!shrinkwrapFile) {
            shrinkwrapIsUpToDate = false;
        }
        // dependency name --> version specifier
        const allExplicitPreferredVersions = this._rushConfiguration.getCommonVersions(variant)
            .getAllPreferredVersions();
        if (shrinkwrapFile) {
            // Check any (explicitly) preferred dependencies first
            allExplicitPreferredVersions.forEach((version, dependency) => {
                const dependencySpecifier = new DependencySpecifier_1.DependencySpecifier(dependency, version);
                if (!shrinkwrapFile.hasCompatibleTopLevelDependency(dependencySpecifier)) {
                    shrinkwrapWarnings.push(`"${dependency}" (${version}) required by the preferred versions from `
                        + RushConstants_1.RushConstants.commonVersionsFilename);
                    shrinkwrapIsUpToDate = false;
                }
            });
            if (this._findOrphanedTempProjects(shrinkwrapFile)) {
                // If there are any orphaned projects, then "npm install" would fail because the shrinkwrap
                // contains references such as "resolved": "file:projects\\project1" that refer to nonexistent
                // file paths.
                shrinkwrapIsUpToDate = false;
            }
        }
        // Also copy down the committed .npmrc file, if there is one
        // "common\config\rush\.npmrc" --> "common\temp\.npmrc"
        // Also ensure that we remove any old one that may be hanging around
        Utilities_1.Utilities.syncNpmrc(this._rushConfiguration.commonRushConfigFolder, this._rushConfiguration.commonTempFolder);
        // also, copy the pnpmfile.js if it exists
        if (this._rushConfiguration.packageManager === 'pnpm') {
            const committedPnpmFilePath = this._rushConfiguration.getPnpmfilePath(this._options.variant);
            const tempPnpmFilePath = path.join(this._rushConfiguration.commonTempFolder, RushConstants_1.RushConstants.pnpmfileFilename);
            // ensure that we remove any old one that may be hanging around
            this._syncFile(committedPnpmFilePath, tempPnpmFilePath);
        }
        const commonPackageJson = {
            dependencies: {},
            description: 'Temporary file generated by the Rush tool',
            name: 'rush-common',
            private: true,
            version: '0.0.0'
        };
        // Find the implicitly preferred versions
        // These are any first-level dependencies for which we only consume a single version range
        // (e.g. every package that depends on react uses an identical specifier)
        // dependency name --> version specifier
        const allPreferredVersions = InstallManager.collectImplicitlyPreferredVersions(this._rushConfiguration, {
            variant
        });
        // Add in the explicitly preferred versions.
        // Note that these take precedence over implicitly preferred versions.
        node_core_library_1.MapExtensions.mergeFromMap(allPreferredVersions, allExplicitPreferredVersions);
        // Add any preferred versions to the top of the commonPackageJson
        // do this in alphabetical order for simpler debugging
        for (const dependency of Array.from(allPreferredVersions.keys()).sort()) {
            commonPackageJson.dependencies[dependency] = allPreferredVersions.get(dependency);
        }
        // To make the common/package.json file more readable, sort alphabetically
        // according to rushProject.tempProjectName instead of packageName.
        const sortedRushProjects = this._rushConfiguration.projects.slice(0);
        node_core_library_1.Sort.sortBy(sortedRushProjects, x => x.tempProjectName);
        for (const rushProject of sortedRushProjects) {
            const packageJson = rushProject.packageJsonEditor;
            // Example: "C:\MyRepo\common\temp\projects\my-project-2.tgz"
            const tarballFile = this._getTarballFilePath(rushProject);
            // Example: "my-project-2"
            const unscopedTempProjectName = rushProject.unscopedTempProjectName;
            // Example: dependencies["@rush-temp/my-project-2"] = "file:./projects/my-project-2.tgz"
            commonPackageJson.dependencies[rushProject.tempProjectName]
                = `file:./${RushConstants_1.RushConstants.rushTempProjectsFolderName}/${rushProject.unscopedTempProjectName}.tgz`;
            const tempPackageJson = {
                name: rushProject.tempProjectName,
                version: '0.0.0',
                private: true,
                dependencies: {}
            };
            // Collect pairs of (packageName, packageVersion) to be added as dependencies of the @rush-temp package.json
            const tempDependencies = new Map();
            // These can be regular, optional, or peer dependencies (but NOT dev dependencies).
            // (A given packageName will never appear more than once in this list.)
            for (const dependency of packageJson.dependencyList) {
                // If there are any optional dependencies, copy directly into the optionalDependencies field.
                if (dependency.dependencyType === "optionalDependencies" /* Optional */) {
                    if (!tempPackageJson.optionalDependencies) {
                        tempPackageJson.optionalDependencies = {};
                    }
                    tempPackageJson.optionalDependencies[dependency.name] = dependency.version;
                }
                else {
                    tempDependencies.set(dependency.name, dependency.version);
                }
            }
            for (const dependency of packageJson.devDependencyList) {
                // If there are devDependencies, we need to merge them with the regular dependencies.  If the same
                // library appears in both places, then the dev dependency wins (because presumably it's saying what you
                // want right now for development, not the range that you support for consumers).
                tempDependencies.set(dependency.name, dependency.version);
            }
            node_core_library_1.Sort.sortMapKeys(tempDependencies);
            for (const [packageName, packageVersion] of tempDependencies.entries()) {
                const dependencySpecifier = new DependencySpecifier_1.DependencySpecifier(packageName, packageVersion);
                // Is there a locally built Rush project that could satisfy this dependency?
                // If so, then we will symlink to the project folder rather than to common/temp/node_modules.
                // In this case, we don't want "npm install" to process this package, but we do need
                // to record this decision for "rush link" later, so we add it to a special 'rushDependencies' field.
                const localProject = this._rushConfiguration.getProjectByName(packageName);
                if (localProject) {
                    // Don't locally link if it's listed in the cyclicDependencyProjects
                    if (!rushProject.cyclicDependencyProjects.has(packageName)) {
                        // Also, don't locally link if the SemVer doesn't match
                        const localProjectVersion = localProject.packageJsonEditor.version;
                        if (semver.satisfies(localProjectVersion, packageVersion)) {
                            // We will locally link this package, so instead add it to our special "rushDependencies"
                            // field in the package.json file.
                            if (!tempPackageJson.rushDependencies) {
                                tempPackageJson.rushDependencies = {};
                            }
                            tempPackageJson.rushDependencies[packageName] = packageVersion;
                            continue;
                        }
                    }
                }
                // We will NOT locally link this package; add it as a regular dependency.
                tempPackageJson.dependencies[packageName] = packageVersion;
                if (shrinkwrapFile) {
                    if (!shrinkwrapFile.tryEnsureCompatibleDependency(dependencySpecifier, rushProject.tempProjectName)) {
                        shrinkwrapWarnings.push(`"${packageName}" (${packageVersion}) required by`
                            + ` "${rushProject.packageName}"`);
                        shrinkwrapIsUpToDate = false;
                    }
                }
            }
            // NPM expects the root of the tarball to have a directory called 'package'
            const npmPackageFolder = 'package';
            // Example: "C:\MyRepo\common\temp\projects\my-project-2"
            const tempProjectFolder = path.join(this._rushConfiguration.commonTempFolder, RushConstants_1.RushConstants.rushTempProjectsFolderName, unscopedTempProjectName);
            // Example: "C:\MyRepo\common\temp\projects\my-project-2\package.json"
            const tempPackageJsonFilename = path.join(tempProjectFolder, "package.json" /* PackageJson */);
            // we only want to overwrite the package if the existing tarball's package.json is different from tempPackageJson
            let shouldOverwrite = true;
            try {
                // if the tarball and the temp file still exist, then compare the contents
                if (node_core_library_1.FileSystem.exists(tarballFile) && node_core_library_1.FileSystem.exists(tempPackageJsonFilename)) {
                    // compare the extracted package.json with the one we are about to write
                    const oldBuffer = node_core_library_1.FileSystem.readFileToBuffer(tempPackageJsonFilename);
                    const newBuffer = Buffer.from(node_core_library_1.JsonFile.stringify(tempPackageJson));
                    if (Buffer.compare(oldBuffer, newBuffer) === 0) {
                        shouldOverwrite = false;
                    }
                }
            }
            catch (error) {
                // ignore the error, we will go ahead and create a new tarball
            }
            if (shouldOverwrite) {
                try {
                    // ensure the folder we are about to zip exists
                    Utilities_1.Utilities.createFolderWithRetry(tempProjectFolder);
                    // remove the old tarball & old temp package json, this is for any cases where new tarball creation
                    // fails, and the shouldOverwrite logic is messed up because the my-project-2\package.json
                    // exists and is updated, but the tarball is not accurate
                    node_core_library_1.FileSystem.deleteFile(tarballFile);
                    node_core_library_1.FileSystem.deleteFile(tempPackageJsonFilename);
                    // write the expected package.json file into the zip staging folder
                    node_core_library_1.JsonFile.save(tempPackageJson, tempPackageJsonFilename);
                    // create the new tarball
                    tar.create({
                        gzip: true,
                        file: tarballFile,
                        cwd: tempProjectFolder,
                        portable: true,
                        noMtime: true,
                        noPax: true,
                        sync: true,
                        prefix: npmPackageFolder
                    }, ["package.json" /* PackageJson */]);
                    console.log(`Updating ${tarballFile}`);
                }
                catch (error) {
                    // delete everything in case of any error
                    node_core_library_1.FileSystem.deleteFile(tarballFile);
                    node_core_library_1.FileSystem.deleteFile(tempPackageJsonFilename);
                }
            }
        }
        // Example: "C:\MyRepo\common\temp\package.json"
        const commonPackageJsonFilename = path.join(this._rushConfiguration.commonTempFolder, "package.json" /* PackageJson */);
        if (shrinkwrapFile) {
            // If we have a (possibly incomplete) shrinkwrap file, save it as the temporary file.
            shrinkwrapFile.save(this._rushConfiguration.tempShrinkwrapFilename);
            shrinkwrapFile.save(this._rushConfiguration.tempShrinkwrapPreinstallFilename);
        }
        else {
            // Otherwise delete the temporary file
            node_core_library_1.FileSystem.deleteFile(this._rushConfiguration.tempShrinkwrapFilename);
            if (this._rushConfiguration.packageManager === 'pnpm') {
                const commonNodeModulesFolder = path.join(this._rushConfiguration.commonTempFolder, 'node_modules');
                // Workaround for https://github.com/pnpm/pnpm/issues/1890
                //
                // When "rush update --full" is run, rush deletes common/temp/pnpm-lock.yaml so that
                // a new lockfile can be generated. But because of the above bug "pnpm install" would
                // respect "common/temp/node_modules/.pnpm-lock.yaml" and thus would not generate a
                // new lockfile. Deleting this file in addition to deleting common/temp/pnpm-lock.yaml
                // ensures that a new lockfile will be generated with "rush update --full".
                // Note that there is period in the file name: common/temp/node_modules/.pnpm-lock.yaml
                const pnpmShrinkwrapInNodeModulesFolder = path.join(commonNodeModulesFolder, '.'
                    + this._rushConfiguration.shrinkwrapFilename);
                node_core_library_1.FileSystem.deleteFile(pnpmShrinkwrapInNodeModulesFolder);
            }
        }
        // Don't update the file timestamp unless the content has changed, since "rush install"
        // will consider this timestamp
        node_core_library_1.JsonFile.save(commonPackageJson, commonPackageJsonFilename, { onlyIfChanged: true });
        stopwatch.stop();
        console.log(`Finished creating temporary modules (${stopwatch.toString()})`);
        if (shrinkwrapWarnings.length > 0) {
            console.log();
            console.log(colors.yellow(Utilities_1.Utilities.wrapWords(`The ${this._shrinkwrapFilePhrase} is missing the following dependencies:`)));
            for (const shrinkwrapWarning of shrinkwrapWarnings) {
                console.log(colors.yellow('  ' + shrinkwrapWarning));
            }
            console.log();
        }
        return shrinkwrapIsUpToDate;
    }
    /**
     * Runs "npm install" in the common folder.
     */
    _installCommonModules(options) {
        const { shrinkwrapIsUpToDate, variantIsUpToDate } = options;
        return Promise.resolve().then(() => {
            console.log(os.EOL + colors.bold('Checking node_modules in ' + this._rushConfiguration.commonTempFolder)
                + os.EOL);
            const commonNodeModulesFolder = path.join(this._rushConfiguration.commonTempFolder, 'node_modules');
            // This marker file indicates that the last "rush install" completed successfully
            const markerFileExistedAndWasValidAtStart = this._commonNodeModulesMarker.isValid();
            // If "--clean" or "--full-clean" was specified, or if the last install was interrupted,
            // then we will need to delete the node_modules folder.  Otherwise, we can do an incremental
            // install.
            const deleteNodeModules = !markerFileExistedAndWasValidAtStart;
            // Based on timestamps, can we skip this install entirely?
            if (shrinkwrapIsUpToDate && !deleteNodeModules && variantIsUpToDate) {
                const potentiallyChangedFiles = [];
                // Consider the timestamp on the node_modules folder; if someone tampered with it
                // or deleted it entirely, then we can't skip this install
                potentiallyChangedFiles.push(commonNodeModulesFolder);
                // Additionally, if they pulled an updated npm-shrinkwrap.json file from Git,
                // then we can't skip this install
                potentiallyChangedFiles.push(this._rushConfiguration.getCommittedShrinkwrapFilename(options.variant));
                if (this._rushConfiguration.packageManager === 'pnpm') {
                    // If the repo is using pnpmfile.js, consider that also
                    const pnpmFileFilename = this._rushConfiguration.getPnpmfilePath(options.variant);
                    if (node_core_library_1.FileSystem.exists(pnpmFileFilename)) {
                        potentiallyChangedFiles.push(pnpmFileFilename);
                    }
                }
                // Also consider timestamps for all the temp tarballs. (createTempModulesAndCheckShrinkwrap() will
                // carefully preserve these timestamps unless something has changed.)
                // Example: "C:\MyRepo\common\temp\projects\my-project-2.tgz"
                potentiallyChangedFiles.push(...this._rushConfiguration.projects.map(x => {
                    return this._getTarballFilePath(x);
                }));
                // NOTE: If commonNodeModulesMarkerFilename (or any of the potentiallyChangedFiles) does not
                // exist, then isFileTimestampCurrent() returns false.
                if (Utilities_1.Utilities.isFileTimestampCurrent(this._commonNodeModulesMarker.path, potentiallyChangedFiles)) {
                    // Nothing to do, because everything is up to date according to time stamps
                    return;
                }
            }
            return this._checkIfReleaseIsPublished()
                .catch((error) => {
                // If the user is working in an environment that can't reach the registry,
                // don't bother them with errors.
                return undefined;
            }).then((publishedRelease) => {
                if (publishedRelease === false) {
                    console.log(colors.yellow('Warning: This release of the Rush tool was unpublished; it may be unstable.'));
                }
                // Since we're going to be tampering with common/node_modules, delete the "rush link" flag file if it exists;
                // this ensures that a full "rush link" is required next time
                Utilities_1.Utilities.deleteFile(this._rushConfiguration.rushLinkJsonFilename);
                // Delete the successful install file to indicate the install transaction has started
                this._commonNodeModulesMarker.clear();
                // NOTE: The PNPM store is supposed to be transactionally safe, so we don't delete it automatically.
                // The user must request that via the command line.
                if (deleteNodeModules) {
                    if (this._rushConfiguration.packageManager === 'npm') {
                        console.log(`Deleting the "npm-cache" folder`);
                        // This is faster and more thorough than "npm cache clean"
                        this._commonTempFolderRecycler.moveFolder(this._rushConfiguration.npmCacheFolder);
                        console.log(`Deleting the "npm-tmp" folder`);
                        this._commonTempFolderRecycler.moveFolder(this._rushConfiguration.npmTmpFolder);
                    }
                }
                // Example: "C:\MyRepo\common\temp\npm-local\node_modules\.bin\npm"
                const packageManagerFilename = this._rushConfiguration.packageManagerToolFilename;
                // Is there an existing "node_modules" folder to consider?
                if (node_core_library_1.FileSystem.exists(commonNodeModulesFolder)) {
                    // Should we delete the entire "node_modules" folder?
                    if (deleteNodeModules) {
                        // YES: Delete "node_modules"
                        // Explain to the user why we are hosing their node_modules folder
                        console.log('Deleting files from ' + commonNodeModulesFolder);
                        this._commonTempFolderRecycler.moveFolder(commonNodeModulesFolder);
                        Utilities_1.Utilities.createFolderWithRetry(commonNodeModulesFolder);
                    }
                    else {
                        // NO: Prepare to do an incremental install in the "node_modules" folder
                        // note: it is not necessary to run "prune" with pnpm
                        if (this._rushConfiguration.packageManager === 'npm') {
                            console.log(`Running "${this._rushConfiguration.packageManager} prune"`
                                + ` in ${this._rushConfiguration.commonTempFolder}`);
                            const args = ['prune'];
                            this._pushConfigurationArgs(args, options);
                            Utilities_1.Utilities.executeCommandWithRetry(MAX_INSTALL_ATTEMPTS, packageManagerFilename, args, this._rushConfiguration.commonTempFolder);
                            // Delete the (installed image of) the temp projects, since "npm install" does not
                            // detect changes for "file:./" references.
                            // We recognize the temp projects by their names, which always start with "rush-".
                            // Example: "C:\MyRepo\common\temp\node_modules\@rush-temp"
                            const pathToDeleteWithoutStar = path.join(commonNodeModulesFolder, RushConstants_1.RushConstants.rushTempNpmScope);
                            console.log(`Deleting ${pathToDeleteWithoutStar}\\*`);
                            // Glob can't handle Windows paths
                            const normalizedpathToDeleteWithoutStar = node_core_library_1.Text.replaceAll(pathToDeleteWithoutStar, '\\', '/');
                            // Example: "C:/MyRepo/common/temp/node_modules/@rush-temp/*"
                            for (const tempModulePath of glob.sync(globEscape(normalizedpathToDeleteWithoutStar) + '/*')) {
                                // We could potentially use AsyncRecycler here, but in practice these folders tend
                                // to be very small
                                Utilities_1.Utilities.dangerouslyDeletePath(tempModulePath);
                            }
                        }
                    }
                }
                if (this._rushConfiguration.packageManager === 'yarn') {
                    // Yarn does not correctly detect changes to a tarball, so we need to forcibly clear its cache
                    const yarnRushTempCacheFolder = path.join(this._rushConfiguration.yarnCacheFolder, 'v2', 'npm-@rush-temp');
                    if (node_core_library_1.FileSystem.exists(yarnRushTempCacheFolder)) {
                        console.log('Deleting ' + yarnRushTempCacheFolder);
                        Utilities_1.Utilities.dangerouslyDeletePath(yarnRushTempCacheFolder);
                    }
                }
                // Run "npm install" in the common folder
                const installArgs = ['install'];
                this._pushConfigurationArgs(installArgs, options);
                console.log(os.EOL + colors.bold(`Running "${this._rushConfiguration.packageManager} install" in`
                    + ` ${this._rushConfiguration.commonTempFolder}`) + os.EOL);
                // If any diagnostic options were specified, then show the full command-line
                if (options.debug || options.collectLogFile || options.networkConcurrency) {
                    console.log(os.EOL + colors.green('Invoking package manager: ')
                        + node_core_library_1.FileSystem.getRealPath(packageManagerFilename) + ' ' + installArgs.join(' ') + os.EOL);
                }
                try {
                    Utilities_1.Utilities.executeCommandWithRetry(MAX_INSTALL_ATTEMPTS, packageManagerFilename, installArgs, this._rushConfiguration.commonTempFolder, undefined, false, () => {
                        if (this._rushConfiguration.packageManager === 'pnpm') {
                            console.log(colors.yellow(`Deleting the "node_modules" folder`));
                            this._commonTempFolderRecycler.moveFolder(commonNodeModulesFolder);
                            // Leave the pnpm-store as is for the retry. This ensures that packages that have already
                            // been downloaded need not be downloaded again, thereby potentially increasing the chances
                            // of a subsequent successful install.
                            Utilities_1.Utilities.createFolderWithRetry(commonNodeModulesFolder);
                        }
                    });
                }
                catch (error) {
                    // All the install attempts failed.
                    if (this._rushConfiguration.packageManager === 'pnpm') {
                        // If the installation has failed even after the retries, then pnpm store may
                        // have got into a corrupted, irrecoverable state. Delete the store so that a
                        // future install can create the store afresh.
                        console.log(colors.yellow(`Deleting the "pnpm-store" folder`));
                        this._commonTempFolderRecycler.moveFolder(this._rushConfiguration.pnpmStoreFolder);
                    }
                    throw error;
                }
                if (this._rushConfiguration.packageManager === 'npm') {
                    console.log(os.EOL + colors.bold('Running "npm shrinkwrap"...'));
                    const npmArgs = ['shrinkwrap'];
                    this._pushConfigurationArgs(npmArgs, options);
                    Utilities_1.Utilities.executeCommand(this._rushConfiguration.packageManagerToolFilename, npmArgs, this._rushConfiguration.commonTempFolder);
                    console.log('"npm shrinkwrap" completed' + os.EOL);
                    this._fixupNpm5Regression();
                }
                if (options.allowShrinkwrapUpdates && !shrinkwrapIsUpToDate) {
                    // Copy (or delete) common\temp\pnpm-lock.yaml --> common\config\rush\pnpm-lock.yaml
                    this._syncFile(this._rushConfiguration.tempShrinkwrapFilename, this._rushConfiguration.getCommittedShrinkwrapFilename(options.variant));
                }
                else {
                    // TODO: Validate whether the package manager updated it in a nontrivial way
                }
                // Finally, create the marker file to indicate a successful install
                this._commonNodeModulesMarker.create();
                console.log('');
            });
        });
    }
    _checkIfReleaseIsPublished() {
        return Promise.resolve().then(() => {
            const lastCheckFile = path.join(this._rushGlobalFolder.nodeSpecificPath, 'rush-' + Rush_1.Rush.version, 'last-check.flag');
            if (node_core_library_1.FileSystem.exists(lastCheckFile)) {
                let cachedResult = undefined;
                try {
                    // NOTE: mtimeMs is not supported yet in Node.js 6.x
                    const nowMs = new Date().getTime();
                    const ageMs = nowMs - node_core_library_1.FileSystem.getStatistics(lastCheckFile).mtime.getTime();
                    const HOUR = 60 * 60 * 1000;
                    // Is the cache too old?
                    if (ageMs < 24 * HOUR) {
                        // No, read the cached result
                        cachedResult = node_core_library_1.JsonFile.load(lastCheckFile);
                    }
                }
                catch (e) {
                    // Unable to parse file
                }
                if (cachedResult === 'error') {
                    return Promise.reject(new Error('Unable to contact server'));
                }
                if (cachedResult === true || cachedResult === false) {
                    return cachedResult;
                }
            }
            // Before we start the network operation, record a failed state.  If the process exits for some reason,
            // this will record the error.  It will also update the timestamp to prevent other Rush instances
            // from attempting to update the file.
            node_core_library_1.JsonFile.save('error', lastCheckFile, { ensureFolderExists: true });
            // For this check we use the official registry, not the private registry
            return this._queryIfReleaseIsPublished('https://registry.npmjs.org:443')
                .then((publishedRelease) => {
                // Cache the result
                node_core_library_1.JsonFile.save(publishedRelease, lastCheckFile, { ensureFolderExists: true });
                return publishedRelease;
            })
                .catch((error) => {
                node_core_library_1.JsonFile.save('error', lastCheckFile, { ensureFolderExists: true });
                return Promise.reject(error);
            });
        });
    }
    _queryIfReleaseIsPublished(registryUrl) {
        let queryUrl = registryUrl;
        if (queryUrl[-1] !== '/') {
            queryUrl += '/';
        }
        // Note that the "@" symbol does not normally get URL-encoded
        queryUrl += RushConstants_1.RushConstants.rushPackageName.replace('/', '%2F');
        const userAgent = `pnpm/? npm/? node/${process.version} ${os.platform()} ${os.arch()}`;
        const headers = new fetch.Headers();
        headers.append('user-agent', userAgent);
        headers.append('accept', 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*');
        let agent = undefined;
        if (process.env.HTTP_PROXY) {
            agent = new HttpsProxyAgent(process.env.HTTP_PROXY);
        }
        return fetch.default(queryUrl, {
            headers: headers,
            agent: agent
        })
            .then((response) => {
            if (!response.ok) {
                return Promise.reject(new Error('Failed to query'));
            }
            return response
                .json()
                .then((data) => {
                let url;
                try {
                    if (!data.versions[Rush_1.Rush.version]) {
                        // Version was not published
                        return false;
                    }
                    url = data.versions[Rush_1.Rush.version].dist.tarball;
                    if (!url) {
                        return Promise.reject(new Error(`URL not found`));
                    }
                }
                catch (e) {
                    return Promise.reject(new Error('Error parsing response'));
                }
                // Make sure the tarball wasn't deleted from the CDN
                headers.set('accept', '*/*');
                return fetch.default(url, {
                    headers: headers,
                    agent: agent
                })
                    .then((response2) => {
                    if (!response2.ok) {
                        if (response2.status === 404) {
                            return false;
                        }
                        else {
                            return Promise.reject(new Error('Failed to fetch'));
                        }
                    }
                    return true;
                });
            });
        });
    }
    /**
     * Used when invoking the NPM tool.  Appends the common configuration options
     * to the command-line.
     */
    _pushConfigurationArgs(args, options) {
        if (this._rushConfiguration.packageManager === 'npm') {
            if (semver.lt(this._rushConfiguration.packageManagerToolVersion, '5.0.0')) {
                // NOTE:
                //
                // When using an npm version older than v5.0.0, we do NOT install optional dependencies for
                // Rush, because npm does not generate the shrinkwrap file consistently across platforms.
                //
                // Consider the "fsevents" package. This is a Mac specific package
                // which is an optional second-order dependency. Optional dependencies work by attempting to install
                // the package, but removes the package if the install failed.
                // This means that someone running generate on a Mac WILL have fsevents included in their shrinkwrap.
                // When someone using Windows attempts to install from the shrinkwrap, the install will fail.
                //
                // If someone generates the shrinkwrap using Windows, then fsevents will NOT be listed in the shrinkwrap.
                // When someone using Mac attempts to install from the shrinkwrap, they will NOT have the
                // optional dependency installed.
                //
                // This issue has been fixed as of npm v5.0.0: https://github.com/npm/npm/releases/tag/v5.0.0
                //
                // For more context, see https://github.com/microsoft/rushstack/issues/761#issuecomment-428689600
                args.push('--no-optional');
            }
            args.push('--cache', this._rushConfiguration.npmCacheFolder);
            args.push('--tmp', this._rushConfiguration.npmTmpFolder);
            if (options.collectLogFile) {
                args.push('--verbose');
            }
        }
        else if (this._rushConfiguration.packageManager === 'pnpm') {
            args.push('--store', this._rushConfiguration.pnpmStoreFolder);
            // we are using the --no-lock flag for now, which unfortunately prints a warning, but should be OK
            // since rush already has its own install lock file which will invalidate the cache for us.
            // we theoretically could use the lock file, but we would need to clean the store if the
            // lockfile existed, otherwise PNPM would hang indefinitely. it is simpler to rely on Rush's
            // last install flag, which encapsulates the entire installation
            args.push('--no-lock');
            // Ensure that Rush's tarball dependencies get synchronized properly with the pnpm-lock.yaml file.
            // See this GitHub issue: https://github.com/pnpm/pnpm/issues/1342
            if (semver.gte(this._rushConfiguration.packageManagerToolVersion, '3.0.0')) {
                args.push('--no-prefer-frozen-lockfile');
            }
            else {
                args.push('--no-prefer-frozen-shrinkwrap');
            }
            if (options.collectLogFile) {
                args.push('--reporter', 'ndjson');
            }
            if (options.networkConcurrency) {
                args.push('--network-concurrency', options.networkConcurrency.toString());
            }
            if (this._rushConfiguration.pnpmOptions.strictPeerDependencies) {
                args.push('--strict-peer-dependencies');
            }
            if (this._rushConfiguration.packageManagerWrapper.supportsResolutionStrategy) {
                args.push('--resolution-strategy', this._rushConfiguration.pnpmOptions.resolutionStrategy);
            }
        }
        else if (this._rushConfiguration.packageManager === 'yarn') {
            args.push('--link-folder', 'yarn-link');
            args.push('--cache-folder', this._rushConfiguration.yarnCacheFolder);
            // Without this option, Yarn will sometimes stop and ask for user input on STDIN
            // (e.g. "Which command would you like to run?").
            args.push('--non-interactive');
            if (options.networkConcurrency) {
                args.push('--network-concurrency', options.networkConcurrency.toString());
            }
            if (this._rushConfiguration.yarnOptions.ignoreEngines) {
                args.push('--ignore-engines');
            }
        }
    }
    /**
     * Copies the file "sourcePath" to "destinationPath", overwriting the target file location.
     * If the source file does not exist, then the target file is deleted.
     */
    _syncFile(sourcePath, destinationPath) {
        if (node_core_library_1.FileSystem.exists(sourcePath)) {
            console.log('Updating ' + destinationPath);
            node_core_library_1.FileSystem.copyFile({ sourcePath, destinationPath });
        }
        else {
            if (node_core_library_1.FileSystem.exists(destinationPath)) {
                console.log('Deleting ' + destinationPath);
                node_core_library_1.FileSystem.deleteFile(destinationPath);
            }
        }
    }
    /**
     * Gets the path to the tarball
     * Example: "C:\MyRepo\common\temp\projects\my-project-2.tgz"
     */
    _getTarballFilePath(project) {
        return path.join(this._rushConfiguration.commonTempFolder, RushConstants_1.RushConstants.rushTempProjectsFolderName, `${project.unscopedTempProjectName}.tgz`);
    }
    /**
     * This is a workaround for a bug introduced in NPM 5 (and still unfixed as of NPM 5.5.1):
     * https://github.com/npm/npm/issues/19006
     *
     * The regression is that "npm install" sets the package.json "version" field for the
     * @rush-temp projects to a value like "file:projects/example.tgz", when it should be "0.0.0".
     * This causes "rush link" to fail later, when read-package-tree tries to parse the bad version.
     * The error looks like this:
     *
     * ERROR: Failed to parse package.json for foo: Invalid version: "file:projects/example.tgz"
     *
     * Our workaround is to rewrite the package.json files for each of the @rush-temp projects
     * in the node_modules folder, after "npm install" completes.
     */
    _fixupNpm5Regression() {
        const pathToDeleteWithoutStar = path.join(this._rushConfiguration.commonTempFolder, 'node_modules', RushConstants_1.RushConstants.rushTempNpmScope);
        // Glob can't handle Windows paths
        const normalizedpathToDeleteWithoutStar = node_core_library_1.Text.replaceAll(pathToDeleteWithoutStar, '\\', '/');
        let anyChanges = false;
        // Example: "C:/MyRepo/common/temp/node_modules/@rush-temp/*/package.json"
        for (const packageJsonPath of glob.sync(globEscape(normalizedpathToDeleteWithoutStar) + '/*/package.json')) {
            // Example: "C:/MyRepo/common/temp/node_modules/@rush-temp/example/package.json"
            const packageJsonObject = node_core_library_1.JsonFile.load(packageJsonPath);
            // The temp projects always use "0.0.0" as their version
            packageJsonObject.version = '0.0.0';
            if (node_core_library_1.JsonFile.save(packageJsonObject, packageJsonPath, { onlyIfChanged: true })) {
                anyChanges = true;
            }
        }
        if (anyChanges) {
            console.log(os.EOL + colors.yellow(Utilities_1.Utilities.wrapWords(`Applied workaround for NPM 5 bug`)) + os.EOL);
        }
    }
    /**
     * Checks for temp projects that exist in the shrinkwrap file, but don't exist
     * in rush.json.  This might occur, e.g. if a project was recently deleted or renamed.
     *
     * @returns true if orphans were found, or false if everything is okay
     */
    _findOrphanedTempProjects(shrinkwrapFile) {
        // We can recognize temp projects because they are under the "@rush-temp" NPM scope.
        for (const tempProjectName of shrinkwrapFile.getTempProjectNames()) {
            if (!this._rushConfiguration.findProjectByTempName(tempProjectName)) {
                console.log(os.EOL + colors.yellow(Utilities_1.Utilities.wrapWords(`Your ${this._shrinkwrapFilePhrase} references a project "${tempProjectName}" which no longer exists.`))
                    + os.EOL);
                return true; // found one
            }
        }
        return false; // none found
    }
    get _shrinkwrapFilePhrase() {
        return this._rushConfiguration.shrinkwrapFilePhrase;
    }
}
exports.InstallManager = InstallManager;
//# sourceMappingURL=InstallManager.js.map