import { ITaskWriter } from '@microsoft/stream-collator';
import { RushConfiguration } from '../../api/RushConfiguration';
import { RushConfigurationProject } from '../../api/RushConfigurationProject';
import { TaskStatus } from './TaskStatus';
import { ITaskDefinition } from '../taskRunner/ITask';
import { PackageChangeAnalyzer } from '../PackageChangeAnalyzer';
export interface IProjectTaskOptions {
    rushProject: RushConfigurationProject;
    rushConfiguration: RushConfiguration;
    commandToRun: string;
    isIncrementalBuildAllowed: boolean;
    packageChangeAnalyzer: PackageChangeAnalyzer;
    packageDepsFilename: string;
}
/**
 * A TaskRunner task which cleans and builds a project
 */
export declare class ProjectTask implements ITaskDefinition {
    readonly name: string;
    isIncrementalBuildAllowed: boolean;
    hadEmptyScript: boolean;
    private _hasWarningOrError;
    private _rushProject;
    private _rushConfiguration;
    private _commandToRun;
    private _packageChangeAnalyzer;
    private _packageDepsFilename;
    constructor(options: IProjectTaskOptions);
    execute(writer: ITaskWriter): Promise<TaskStatus>;
    private _getPackageDependencies;
    private _executeTask;
    private _writeLogsToDisk;
}
/**
 * When running a command from the "scripts" block in package.json, if the command
 * contains Unix-style path slashes and the OS is Windows, the package managers will
 * convert slashes to backslashes.  This is a complicated undertaking.  For example, they
 * need to convert "node_modules/bin/this && ./scripts/that --name keep/this"
 * to "node_modules\bin\this && .\scripts\that --name keep/this", and they don't want to
 * convert ANY of the slashes in "cmd.exe /c echo a/b".  NPM and PNPM use npm-lifecycle for this,
 * but it unfortunately has a dependency on the entire node-gyp kitchen sink.  Yarn has a
 * simplified implementation in fix-cmd-win-slashes.js, but it's not exposed as a library.
 *
 * Fundamentally NPM's whole feature seems misguided:  They start by inviting people to write
 * shell scripts that will be executed by wildly different shell languages (e.g. cmd.exe and Bash).
 * It's very tricky for a developer to guess what's safe to do without testing every OS.
 * Even simple path separators are not portable, so NPM added heuristics to figure out which
 * slashes are part of a path or not, and convert them.  These workarounds end up having tons
 * of special cases.  They probably could have implemented their own entire minimal cross-platform
 * shell language with less code and less confusion than npm-lifecycle's approach.
 *
 * We've deprecated shell operators inside package.json.  Instead, we advise people to move their
 * scripts into conventional script files, and put only a file path in package.json.  So, for
 * Rush's workaround here, we really only care about supporting the small set of cases seen in the
 * unit tests.  For anything that doesn't fit those patterns, we leave the string untouched
 * (i.e. err on the side of not breaking anything).  We could revisit this later if someone
 * complains about it, but so far nobody has.  :-)
 */
export declare function convertSlashesForWindows(command: string): string;
//# sourceMappingURL=ProjectTask.d.ts.map