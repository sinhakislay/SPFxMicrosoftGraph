"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const semver = require("semver");
const node_core_library_1 = require("@microsoft/node-core-library");
const true_case_path_1 = require("true-case-path");
const Rush_1 = require("../api/Rush");
const RushConfigurationProject_1 = require("./RushConfigurationProject");
const RushConstants_1 = require("../logic/RushConstants");
const ApprovedPackagesPolicy_1 = require("./ApprovedPackagesPolicy");
const EventHooks_1 = require("./EventHooks");
const VersionPolicyConfiguration_1 = require("./VersionPolicyConfiguration");
const EnvironmentConfiguration_1 = require("./EnvironmentConfiguration");
const CommonVersionsConfiguration_1 = require("./CommonVersionsConfiguration");
const Utilities_1 = require("../utilities/Utilities");
const NpmPackageManager_1 = require("./packageManager/NpmPackageManager");
const YarnPackageManager_1 = require("./packageManager/YarnPackageManager");
const PnpmPackageManager_1 = require("./packageManager/PnpmPackageManager");
const ExperimentsConfiguration_1 = require("./ExperimentsConfiguration");
const MINIMUM_SUPPORTED_RUSH_JSON_VERSION = '0.0.0';
/**
 * A list of known config filenames that are expected to appear in the "./common/config/rush" folder.
 * To avoid confusion/mistakes, any extra files will be reported as an error.
 */
const knownRushConfigFilenames = [
    '.npmrc',
    RushConstants_1.RushConstants.pinnedVersionsFilename,
    RushConstants_1.RushConstants.commonVersionsFilename,
    RushConstants_1.RushConstants.browserApprovedPackagesFilename,
    RushConstants_1.RushConstants.nonbrowserApprovedPackagesFilename,
    RushConstants_1.RushConstants.versionPoliciesFilename,
    RushConstants_1.RushConstants.commandLineFilename,
    RushConstants_1.RushConstants.experimentsFilename
];
/**
 * Options that are only used when the PNPM package manager is selected.
 *
 * @remarks
 * It is valid to define these options in rush.json even if the PNPM package manager
 * is not being used.
 *
 * @public
 */
class PnpmOptionsConfiguration {
    /** @internal */
    constructor(json) {
        this.strictPeerDependencies = !!json.strictPeerDependencies;
        this.resolutionStrategy = json.resolutionStrategy || 'fewer-dependencies';
    }
}
exports.PnpmOptionsConfiguration = PnpmOptionsConfiguration;
/**
 * Options that are only used when the yarn package manager is selected.
 *
 * @remarks
 * It is valid to define these options in rush.json even if the yarn package manager
 * is not being used.
 *
 * @public
 */
class YarnOptionsConfiguration {
    /** @internal */
    constructor(json) {
        this.ignoreEngines = !!json.ignoreEngines;
    }
}
exports.YarnOptionsConfiguration = YarnOptionsConfiguration;
/**
 * This represents the Rush configuration for a repository, based on the "rush.json"
 * configuration file.
 * @public
 */
class RushConfiguration {
    /**
     * Use RushConfiguration.loadFromConfigurationFile() or Use RushConfiguration.loadFromDefaultLocation()
     * instead.
     */
    constructor(rushConfigurationJson, rushJsonFilename) {
        EnvironmentConfiguration_1.EnvironmentConfiguration.initialize();
        if (rushConfigurationJson.nodeSupportedVersionRange) {
            if (!semver.validRange(rushConfigurationJson.nodeSupportedVersionRange)) {
                throw new Error('Error parsing the node-semver expression in the "nodeSupportedVersionRange"'
                    + ` field from rush.json: "${rushConfigurationJson.nodeSupportedVersionRange}"`);
            }
            if (!semver.satisfies(process.version, rushConfigurationJson.nodeSupportedVersionRange)) {
                const message = `Your dev environment is running Node.js version ${process.version} which does`
                    + ` not meet the requirements for building this repository.  (The rush.json configuration`
                    + ` requires nodeSupportedVersionRange="${rushConfigurationJson.nodeSupportedVersionRange}")`;
                if (EnvironmentConfiguration_1.EnvironmentConfiguration.allowUnsupportedNodeVersion) {
                    console.warn(message);
                }
                else {
                    throw new Error(message);
                }
            }
        }
        this._rushJsonFile = rushJsonFilename;
        this._rushJsonFolder = path.dirname(rushJsonFilename);
        this._commonFolder = path.resolve(path.join(this._rushJsonFolder, RushConstants_1.RushConstants.commonFolderName));
        this._commonRushConfigFolder = path.join(this._commonFolder, 'config', 'rush');
        this._commonTempFolder = EnvironmentConfiguration_1.EnvironmentConfiguration.rushTempFolderOverride ||
            path.join(this._commonFolder, RushConstants_1.RushConstants.rushTempFolderName);
        this._commonScriptsFolder = path.join(this._commonFolder, 'scripts');
        this._npmCacheFolder = path.resolve(path.join(this._commonTempFolder, 'npm-cache'));
        this._npmTmpFolder = path.resolve(path.join(this._commonTempFolder, 'npm-tmp'));
        this._pnpmStoreFolder = path.resolve(path.join(this._commonTempFolder, 'pnpm-store'));
        this._yarnCacheFolder = path.resolve(path.join(this._commonTempFolder, 'yarn-cache'));
        this._changesFolder = path.join(this._commonFolder, RushConstants_1.RushConstants.changeFilesFolderName);
        this._rushLinkJsonFilename = path.join(this._commonTempFolder, 'rush-link.json');
        this._currentVariantJsonFilename = path.join(this._commonTempFolder, 'current-variant.json');
        this._suppressNodeLtsWarning = !!rushConfigurationJson.suppressNodeLtsWarning;
        this._ensureConsistentVersions = !!rushConfigurationJson.ensureConsistentVersions;
        const experimentsConfigFile = path.join(this._commonRushConfigFolder, RushConstants_1.RushConstants.experimentsFilename);
        this._experimentsConfiguration = new ExperimentsConfiguration_1.ExperimentsConfiguration(experimentsConfigFile);
        this._pnpmOptions = new PnpmOptionsConfiguration(rushConfigurationJson.pnpmOptions || {});
        this._yarnOptions = new YarnOptionsConfiguration(rushConfigurationJson.yarnOptions || {});
        // TODO: Add an actual "packageManager" field in rush.json
        const packageManagerFields = [];
        if (rushConfigurationJson.npmVersion) {
            this._packageManager = 'npm';
            packageManagerFields.push('npmVersion');
        }
        if (rushConfigurationJson.pnpmVersion) {
            this._packageManager = 'pnpm';
            packageManagerFields.push('pnpmVersion');
        }
        if (rushConfigurationJson.yarnVersion) {
            this._packageManager = 'yarn';
            packageManagerFields.push('yarnVersion');
        }
        if (packageManagerFields.length === 0) {
            throw new Error(`The rush.json configuration must specify one of: npmVersion, pnpmVersion, or yarnVersion`);
        }
        if (packageManagerFields.length > 1) {
            throw new Error(`The rush.json configuration cannot specify both ${packageManagerFields[0]}`
                + ` and ${packageManagerFields[1]} `);
        }
        if (this._packageManager === 'npm') {
            this._packageManagerToolVersion = rushConfigurationJson.npmVersion;
            this._packageManagerWrapper = new NpmPackageManager_1.NpmPackageManager(this._packageManagerToolVersion);
        }
        else if (this._packageManager === 'pnpm') {
            this._packageManagerToolVersion = rushConfigurationJson.pnpmVersion;
            this._packageManagerWrapper = new PnpmPackageManager_1.PnpmPackageManager(this._packageManagerToolVersion);
        }
        else {
            this._packageManagerToolVersion = rushConfigurationJson.yarnVersion;
            this._packageManagerWrapper = new YarnPackageManager_1.YarnPackageManager(this._packageManagerToolVersion);
        }
        this._shrinkwrapFilename = this._packageManagerWrapper.shrinkwrapFilename;
        this._tempShrinkwrapFilename = path.join(this._commonTempFolder, this._shrinkwrapFilename);
        this._packageManagerToolFilename = path.resolve(path.join(this._commonTempFolder, `${this.packageManager}-local`, 'node_modules', '.bin', `${this.packageManager}`));
        /// From "C:\repo\common\temp\pnpm-lock.yaml" --> "C:\repo\common\temp\pnpm-lock-preinstall.yaml"
        const parsedPath = path.parse(this._tempShrinkwrapFilename);
        this._tempShrinkwrapPreinstallFilename = path.join(parsedPath.dir, parsedPath.name + '-preinstall' + parsedPath.ext);
        RushConfiguration._validateCommonRushConfigFolder(this._commonRushConfigFolder, this.packageManager, this._shrinkwrapFilename);
        this._projectFolderMinDepth = rushConfigurationJson.projectFolderMinDepth !== undefined
            ? rushConfigurationJson.projectFolderMinDepth : 1;
        if (this._projectFolderMinDepth < 1) {
            throw new Error('Invalid projectFolderMinDepth; the minimum possible value is 1');
        }
        this._projectFolderMaxDepth = rushConfigurationJson.projectFolderMaxDepth !== undefined
            ? rushConfigurationJson.projectFolderMaxDepth : 2;
        if (this._projectFolderMaxDepth < this._projectFolderMinDepth) {
            throw new Error('The projectFolderMaxDepth cannot be smaller than the projectFolderMinDepth');
        }
        this._approvedPackagesPolicy = new ApprovedPackagesPolicy_1.ApprovedPackagesPolicy(this, rushConfigurationJson);
        this._gitAllowedEmailRegExps = [];
        this._gitSampleEmail = '';
        if (rushConfigurationJson.gitPolicy) {
            if (rushConfigurationJson.gitPolicy.sampleEmail) {
                this._gitSampleEmail = rushConfigurationJson.gitPolicy.sampleEmail;
            }
            if (rushConfigurationJson.gitPolicy.allowedEmailRegExps) {
                this._gitAllowedEmailRegExps = rushConfigurationJson.gitPolicy.allowedEmailRegExps;
                if (this._gitSampleEmail.trim().length < 1) {
                    throw new Error('The rush.json file is missing the "sampleEmail" option, ' +
                        'which is required when using "allowedEmailRegExps"');
                }
            }
            if (rushConfigurationJson.gitPolicy.versionBumpCommitMessage) {
                this._gitVersionBumpCommitMessage = rushConfigurationJson.gitPolicy.versionBumpCommitMessage;
            }
        }
        this._hotfixChangeEnabled = false;
        if (rushConfigurationJson.hotfixChangeEnabled) {
            this._hotfixChangeEnabled = rushConfigurationJson.hotfixChangeEnabled;
        }
        if (rushConfigurationJson.repository) {
            this._repositoryUrl = rushConfigurationJson.repository.url;
        }
        this._telemetryEnabled = !!rushConfigurationJson.telemetryEnabled;
        if (rushConfigurationJson.eventHooks) {
            this._eventHooks = new EventHooks_1.EventHooks(rushConfigurationJson.eventHooks);
        }
        const versionPolicyConfigFile = path.join(this._commonRushConfigFolder, RushConstants_1.RushConstants.versionPoliciesFilename);
        this._versionPolicyConfiguration = new VersionPolicyConfiguration_1.VersionPolicyConfiguration(versionPolicyConfigFile);
        this._projects = [];
        this._projectsByName = new Map();
        // We sort the projects array in alphabetical order.  This ensures that the packages
        // are processed in a deterministic order by the various Rush algorithms.
        const sortedProjectJsons = rushConfigurationJson.projects.slice(0);
        sortedProjectJsons.sort((a, b) => a.packageName.localeCompare(b.packageName));
        const tempNamesByProject = RushConfiguration._generateTempNamesForProjects(sortedProjectJsons);
        for (const projectJson of sortedProjectJsons) {
            const tempProjectName = tempNamesByProject.get(projectJson);
            if (tempProjectName) {
                const project = new RushConfigurationProject_1.RushConfigurationProject(projectJson, this, tempProjectName);
                this._projects.push(project);
                if (this._projectsByName.get(project.packageName)) {
                    throw new Error(`The project name "${project.packageName}" was specified more than once`
                        + ` in the rush.json configuration file.`);
                }
                this._projectsByName.set(project.packageName, project);
            }
        }
        for (const project of this._projects) {
            project.cyclicDependencyProjects.forEach((cyclicDependencyProject) => {
                if (!this.getProjectByName(cyclicDependencyProject)) {
                    throw new Error(`In rush.json, the "${cyclicDependencyProject}" project does not exist,`
                        + ` but was referenced by the cyclicDependencyProjects for ${project.packageName}`);
                }
            });
            // Compute the downstream dependencies within the list of Rush projects.
            this._populateDownstreamDependencies(project.packageJson.dependencies, project.packageName);
            this._populateDownstreamDependencies(project.packageJson.devDependencies, project.packageName);
            this._versionPolicyConfiguration.validate(this._projectsByName);
        }
        const variants = {};
        if (rushConfigurationJson.variants) {
            for (const variantOptions of rushConfigurationJson.variants) {
                const { variantName } = variantOptions;
                if (variants[variantName]) {
                    throw new Error(`Duplicate variant named '${variantName}' specified in configuration.`);
                }
                variants[variantName] = true;
            }
        }
        this._variants = variants;
    }
    /**
     * Loads the configuration data from an Rush.json configuration file and returns
     * an RushConfiguration object.
     */
    static loadFromConfigurationFile(rushJsonFilename) {
        let resolvedRushJsonFilename = path.resolve(rushJsonFilename);
        // Load the rush.json before we fix the casing. If the case is wrong on a case-sensitive filesystem,
        // the next line show throw.
        const rushConfigurationJson = node_core_library_1.JsonFile.load(resolvedRushJsonFilename);
        try {
            resolvedRushJsonFilename = true_case_path_1.trueCasePathSync(resolvedRushJsonFilename);
        }
        catch (error) {
            /* ignore errors from true-case-path */
        }
        // Check the Rush version *before* we validate the schema, since if the version is outdated
        // then the schema may have changed. This should no longer be a problem after Rush 4.0 and the C2R wrapper,
        // but we'll validate anyway.
        const expectedRushVersion = rushConfigurationJson.rushVersion;
        const rushJsonBaseName = path.basename(resolvedRushJsonFilename);
        // If the version is missing or malformed, fall through and let the schema handle it.
        if (expectedRushVersion && semver.valid(expectedRushVersion)) {
            // Make sure the requested version isn't too old
            if (semver.lt(expectedRushVersion, MINIMUM_SUPPORTED_RUSH_JSON_VERSION)) {
                throw new Error(`${rushJsonBaseName} is version ${expectedRushVersion}, which is too old for this tool. ` +
                    `The minimum supported version is ${MINIMUM_SUPPORTED_RUSH_JSON_VERSION}.`);
            }
            // Make sure the requested version isn't too new.
            //
            // If the major/minor versions are the same, then we consider the file to be compatible.
            // This is somewhat lax, e.g. "5.0.2-dev.3" will be assumed to be loadable by rush-lib 5.0.0.
            //
            // IMPORTANT: Whenever a breaking change is introduced for one of the config files, we must
            // increment the minor version number for Rush.
            if (semver.major(Rush_1.Rush.version) !== semver.major(expectedRushVersion)
                || semver.minor(Rush_1.Rush.version) !== semver.minor(expectedRushVersion)) {
                // If the major/minor are different, then make sure it's an older version.
                if (semver.lt(Rush_1.Rush.version, expectedRushVersion)) {
                    throw new Error(`Unable to load ${rushJsonBaseName} because its RushVersion is`
                        + ` ${rushConfigurationJson.rushVersion}, whereas @microsoft/rush-lib is version ${Rush_1.Rush.version}.`
                        + ` Consider upgrading the library.`);
                }
            }
        }
        RushConfiguration._jsonSchema.validateObject(rushConfigurationJson, resolvedRushJsonFilename);
        return new RushConfiguration(rushConfigurationJson, resolvedRushJsonFilename);
    }
    static loadFromDefaultLocation(options) {
        const rushJsonLocation = RushConfiguration.tryFindRushJsonLocation(options);
        if (rushJsonLocation) {
            return RushConfiguration.loadFromConfigurationFile(rushJsonLocation);
        }
        else {
            throw Utilities_1.Utilities.getRushConfigNotFoundError();
        }
    }
    /**
     * Find the rush.json location and return the path, or undefined if a rush.json can't be found.
     */
    static tryFindRushJsonLocation(options) {
        const optionsIn = options || {};
        const verbose = optionsIn.showVerbose || false;
        let currentFolder = optionsIn.startingFolder || process.cwd();
        // Look upwards at parent folders until we find a folder containing rush.json
        for (let i = 0; i < 10; ++i) {
            const rushJsonFilename = path.join(currentFolder, 'rush.json');
            if (node_core_library_1.FileSystem.exists(rushJsonFilename)) {
                if (i > 0 && verbose) {
                    console.log('Found configuration in ' + rushJsonFilename);
                }
                if (verbose) {
                    console.log('');
                }
                return rushJsonFilename;
            }
            const parentFolder = path.dirname(currentFolder);
            if (parentFolder === currentFolder) {
                break;
            }
            currentFolder = parentFolder;
        }
        return undefined;
    }
    /**
     * This generates the unique names that are used to create temporary projects
     * in the Rush common folder.
     * NOTE: sortedProjectJsons is sorted by the caller.
     */
    static _generateTempNamesForProjects(sortedProjectJsons) {
        const tempNamesByProject = new Map();
        const usedTempNames = new Set();
        // NOTE: projectJsons was already sorted in alphabetical order by the caller.
        for (const projectJson of sortedProjectJsons) {
            // If the name is "@ms/MyProject", extract the "MyProject" part
            const unscopedName = node_core_library_1.PackageName.getUnscopedName(projectJson.packageName);
            // Generate a unique like name "@rush-temp/MyProject", or "@rush-temp/MyProject-2" if
            // there is a naming conflict
            let counter = 0;
            let tempProjectName = `${RushConstants_1.RushConstants.rushTempNpmScope}/${unscopedName}`;
            while (usedTempNames.has(tempProjectName)) {
                ++counter;
                tempProjectName = `${RushConstants_1.RushConstants.rushTempNpmScope}/${unscopedName}-${counter}`;
            }
            usedTempNames.add(tempProjectName);
            tempNamesByProject.set(projectJson, tempProjectName);
        }
        return tempNamesByProject;
    }
    /**
     * If someone adds a config file in the "common/rush/config" folder, it would be a bad
     * experience for Rush to silently ignore their file simply because they misspelled the
     * filename, or maybe it's an old format that's no longer supported.  The
     * _validateCommonRushConfigFolder() function makes sure that this folder only contains
     * recognized config files.
     */
    static _validateCommonRushConfigFolder(commonRushConfigFolder, packageManager, shrinkwrapFilename) {
        if (!node_core_library_1.FileSystem.exists(commonRushConfigFolder)) {
            console.log(`Creating folder: ${commonRushConfigFolder}`);
            node_core_library_1.FileSystem.ensureFolder(commonRushConfigFolder);
            return;
        }
        for (const filename of node_core_library_1.FileSystem.readFolder(commonRushConfigFolder)) {
            // Ignore things that aren't actual files
            const stat = node_core_library_1.FileSystem.getLinkStatistics(path.join(commonRushConfigFolder, filename));
            if (!stat.isFile() && !stat.isSymbolicLink()) {
                continue;
            }
            // Ignore harmless file extensions
            const fileExtension = path.extname(filename);
            if (['.bak', '.disabled', '.md', '.old', '.orig'].indexOf(fileExtension) >= 0) {
                continue;
            }
            const knownSet = new Set(knownRushConfigFilenames.map(x => x.toUpperCase()));
            // Add the shrinkwrap filename for the package manager to the known set.
            knownSet.add(shrinkwrapFilename.toUpperCase());
            // If the package manager is pnpm, then also add the pnpm file to the known set.
            if (packageManager === 'pnpm') {
                knownSet.add(RushConstants_1.RushConstants.pnpmfileFilename.toUpperCase());
            }
            // Is the filename something we know?  If not, report an error.
            if (!knownSet.has(filename.toUpperCase())) {
                throw new Error(`An unrecognized file "${filename}" was found in the Rush config folder:`
                    + ` ${commonRushConfigFolder}`);
            }
        }
        const pinnedVersionsFilename = path.join(commonRushConfigFolder, RushConstants_1.RushConstants.pinnedVersionsFilename);
        if (node_core_library_1.FileSystem.exists(pinnedVersionsFilename)) {
            throw new Error('The "pinned-versions.json" config file is no longer supported;'
                + ' please move your settings to the "preferredVersions" field of a "common-versions.json" config file.'
                + ` (See the ${RushConstants_1.RushConstants.rushWebSiteUrl} documentation for details.)\n\n`
                + pinnedVersionsFilename);
        }
    }
    /**
     * The name of the package manager being used to install dependencies
     */
    get packageManager() {
        return this._packageManager;
    }
    /**
     * {@inheritdoc PackageManager}
     *
     * @privateremarks
     * In the next major breaking API change, we will rename this property to "packageManager" and eliminate the
     * old property with that name.
     *
     * @beta
     */
    get packageManagerWrapper() {
        return this._packageManagerWrapper;
    }
    /**
     * The absolute path to the "rush.json" configuration file that was loaded to construct this object.
     */
    get rushJsonFile() {
        return this._rushJsonFile;
    }
    /**
     * The absolute path of the folder that contains rush.json for this project.
     */
    get rushJsonFolder() {
        return this._rushJsonFolder;
    }
    /**
     * The folder that contains all change files.
     */
    get changesFolder() {
        return this._changesFolder;
    }
    /**
     * The fully resolved path for the "common" folder where Rush will store settings that
     * affect all Rush projects.  This is always a subfolder of the folder containing "rush.json".
     * Example: `C:\MyRepo\common`
     */
    get commonFolder() {
        return this._commonFolder;
    }
    /**
     * The folder where Rush's additional config files are stored.  This folder is always a
     * subfolder called `config\rush` inside the common folder.  (The `common\config` folder
     * is reserved for configuration files used by other tools.)  To avoid confusion or mistakes,
     * Rush will report an error if this this folder contains any unrecognized files.
     *
     * Example: `C:\MyRepo\common\config\rush`
     */
    get commonRushConfigFolder() {
        return this._commonRushConfigFolder;
    }
    /**
     * The folder where temporary files will be stored.  This is always a subfolder called "temp"
     * under the common folder.
     * Example: `C:\MyRepo\common\temp`
     */
    get commonTempFolder() {
        return this._commonTempFolder;
    }
    /**
     * The folder where automation scripts are stored.  This is always a subfolder called "scripts"
     * under the common folder.
     * Example: `C:\MyRepo\common\scripts`
     */
    get commonScriptsFolder() {
        return this._commonScriptsFolder;
    }
    /**
     * The local folder that will store the NPM package cache.  Rush does not rely on the
     * npm's default global cache folder, because npm's caching implementation does not
     * reliably handle multiple processes.  (For example, if a build box is running
     * "rush install" simultaneously for two different working folders, it may fail randomly.)
     *
     * Example: `C:\MyRepo\common\temp\npm-cache`
     */
    get npmCacheFolder() {
        return this._npmCacheFolder;
    }
    /**
     * The local folder where npm's temporary files will be written during installation.
     * Rush does not rely on the global default folder, because it may be on a different
     * hard disk.
     *
     * Example: `C:\MyRepo\common\temp\npm-tmp`
     */
    get npmTmpFolder() {
        return this._npmTmpFolder;
    }
    /**
     * The local folder where PNPM stores a global installation for every installed package
     *
     * Example: `C:\MyRepo\common\temp\pnpm-store`
     */
    get pnpmStoreFolder() {
        return this._pnpmStoreFolder;
    }
    /**
     * The local folder that will store the Yarn package cache.
     *
     * Example: `C:\MyRepo\common\temp\yarn-cache`
     */
    get yarnCacheFolder() {
        return this._yarnCacheFolder;
    }
    /**
     * The full path of the shrinkwrap file that is tracked by Git.  (The "rush install"
     * command uses a temporary copy, whose path is tempShrinkwrapFilename.)
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `C:\MyRepo\common\npm-shrinkwrap.json` or `C:\MyRepo\common\pnpm-lock.yaml`
     *
     * @deprecated Use `getCommittedShrinkwrapFilename` instead, which gets the correct common
     * shrinkwrap file name for a given active variant.
     */
    get committedShrinkwrapFilename() {
        return this.getCommittedShrinkwrapFilename();
    }
    /**
     * The filename (without any path) of the shrinkwrap file that is used by the package manager.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `npm-shrinkwrap.json` or `pnpm-lock.yaml`
     */
    get shrinkwrapFilename() {
        return this._shrinkwrapFilename;
    }
    /**
     * The full path of the temporary shrinkwrap file that is used during "rush install".
     * This file may get rewritten by the package manager during installation.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `C:\MyRepo\common\temp\npm-shrinkwrap.json` or `C:\MyRepo\common\temp\pnpm-lock.yaml`
     */
    get tempShrinkwrapFilename() {
        return this._tempShrinkwrapFilename;
    }
    /**
     * The full path of a backup copy of tempShrinkwrapFilename. This backup copy is made
     * before installation begins, and can be compared to determine how the package manager
     * modified tempShrinkwrapFilename.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `C:\MyRepo\common\temp\npm-shrinkwrap-preinstall.json`
     * or `C:\MyRepo\common\temp\pnpm-lock-preinstall.yaml`
     */
    get tempShrinkwrapPreinstallFilename() {
        return this._tempShrinkwrapPreinstallFilename;
    }
    /**
     * Returns an English phrase such as "shrinkwrap file" that can be used in logging messages
     * to refer to the shrinkwrap file using appropriate terminology for the currently selected
     * package manager.
     */
    get shrinkwrapFilePhrase() {
        if (this._packageManager === 'yarn') {
            // Eventually we'd like to be consistent with Yarn's terminology of calling this a "lock file",
            // but a lot of Rush documentation uses "shrinkwrap" file and would all need to be updated.
            return 'shrinkwrap file (yarn.lock)';
        }
        else {
            return 'shrinkwrap file';
        }
    }
    /**
     * The filename of the build dependency data file.  By default this is
     * called 'rush-link.json' resides in the Rush common folder.
     * Its data structure is defined by IRushLinkJson.
     *
     * Example: `C:\MyRepo\common\temp\rush-link.json`
     */
    get rushLinkJsonFilename() {
        return this._rushLinkJsonFilename;
    }
    /**
     * The filename of the variant dependency data file.  By default this is
     * called 'current-variant.json' resides in the Rush common folder.
     * Its data structure is defined by ICurrentVariantJson.
     *
     * Example: `C:\MyRepo\common\temp\current-variant.json`
     */
    get currentVariantJsonFilename() {
        return this._currentVariantJsonFilename;
    }
    /**
     * The version of the locally installed NPM tool.  (Example: "1.2.3")
     */
    get packageManagerToolVersion() {
        return this._packageManagerToolVersion;
    }
    /**
     * The absolute path to the locally installed NPM tool.  If "rush install" has not
     * been run, then this file may not exist yet.
     * Example: `C:\MyRepo\common\temp\npm-local\node_modules\.bin\npm`
     */
    get packageManagerToolFilename() {
        return this._packageManagerToolFilename;
    }
    /**
     * The minimum allowable folder depth for the projectFolder field in the rush.json file.
     * This setting provides a way for repository maintainers to discourage nesting of project folders
     * that makes the directory tree more difficult to navigate.  The default value is 2,
     * which implements a standard 2-level hierarchy of <categoryFolder>/<projectFolder>/package.json.
     */
    get projectFolderMinDepth() {
        return this._projectFolderMinDepth;
    }
    /**
     * The maximum allowable folder depth for the projectFolder field in the rush.json file.
     * This setting provides a way for repository maintainers to discourage nesting of project folders
     * that makes the directory tree more difficult to navigate.  The default value is 2,
     * which implements on a standard convention of <categoryFolder>/<projectFolder>/package.json.
     */
    get projectFolderMaxDepth() {
        return this._projectFolderMaxDepth;
    }
    /**
     * The "approvedPackagesPolicy" settings.
     */
    get approvedPackagesPolicy() {
        return this._approvedPackagesPolicy;
    }
    /**
     * [Part of the "gitPolicy" feature.]
     * A list of regular expressions describing allowable email patterns for Git commits.
     * They are case-insensitive anchored JavaScript RegExps.
     * Example: `".*@example\.com"`
     * This array will never be undefined.
     */
    get gitAllowedEmailRegExps() {
        return this._gitAllowedEmailRegExps;
    }
    /**
     * [Part of the "gitPolicy" feature.]
     * An example valid email address that conforms to one of the allowedEmailRegExps.
     * Example: `"foxtrot@example\.com"`
     * This will never be undefined, and will always be nonempty if gitAllowedEmailRegExps is used.
     */
    get gitSampleEmail() {
        return this._gitSampleEmail;
    }
    /**
     * [Part of the "gitPolicy" feature.]
     * The commit message to use when committing changes during 'rush publish'
     */
    get gitVersionBumpCommitMessage() {
        return this._gitVersionBumpCommitMessage;
    }
    /**
     * [Part of the "hotfixChange" feature.]
     * Enables creating hotfix changes
     */
    get hotfixChangeEnabled() {
        return this._hotfixChangeEnabled;
    }
    /**
     * The remote url of the repository. This helps "rush change" find the right remote to compare against.
     */
    get repositoryUrl() {
        return this._repositoryUrl;
    }
    /**
      * Odd-numbered major versions of Node.js are experimental.  Even-numbered releases
      * spend six months in a stabilization period before the first Long Term Support (LTS) version.
      * For example, 8.9.0 was the first LTS version of Node.js 8.  Pre-LTS versions are not recommended
      * for production usage because they frequently have bugs.  They may cause Rush itself
      * to malfunction.
      *
      * Rush normally prints a warning if it detects a pre-LTS Node.js version.  If you are testing
      * pre-LTS versions in preparation for supporting the first LTS version, you can use this setting
      * to disable Rush's warning.
     */
    get suppressNodeLtsWarning() {
        return this._suppressNodeLtsWarning;
    }
    /**
     * If true, then consistent version specifiers for dependencies will be enforced.
     * I.e. "rush check" is run before some commands.
     */
    get ensureConsistentVersions() {
        return this._ensureConsistentVersions;
    }
    /**
     * Indicates whether telemetry collection is enabled for Rush runs.
     * @beta
     */
    get telemetryEnabled() {
        return this._telemetryEnabled;
    }
    get projects() {
        return this._projects;
    }
    get projectsByName() {
        return this._projectsByName;
    }
    /**
     * {@inheritDoc PnpmOptionsConfiguration}
     */
    get pnpmOptions() {
        return this._pnpmOptions;
    }
    /**
     * {@inheritDoc YarnOptionsConfiguration}
     */
    get yarnOptions() {
        return this._yarnOptions;
    }
    /**
     * Settings from the common-versions.json config file.
     * @remarks
     * If the common-versions.json file is missing, this property will not be undefined.
     * Instead it will be initialized in an empty state, and calling CommonVersionsConfiguration.save()
     * will create the file.
     *
     * @deprecated Use `getCommonVersions` instead, which gets the correct common version data
     * for a given active variant.
     */
    get commonVersions() {
        return this.getCommonVersions();
    }
    /**
     * Gets the currently-installed variant, if an installation has occurred.
     * For Rush operations which do not take a --variant parameter, this method
     * determines which variant, if any, was last specified when performing "rush install"
     * or "rush update".
     */
    get currentInstalledVariant() {
        let variant;
        if (node_core_library_1.FileSystem.exists(this._currentVariantJsonFilename)) {
            const currentVariantJson = node_core_library_1.JsonFile.load(this._currentVariantJsonFilename);
            variant = currentVariantJson.variant || undefined;
        }
        return variant;
    }
    /**
     * The rush hooks. It allows customized scripts to run at the specified point.
     * @beta
     */
    get eventHooks() {
        return this._eventHooks;
    }
    /**
     * Gets the path to the common-versions.json config file for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getCommonVersionsFilePath(variant) {
        const commonVersionsFilename = path.join(this.commonRushConfigFolder, ...(variant ? [RushConstants_1.RushConstants.rushVariantsFolderName, variant] : []), RushConstants_1.RushConstants.commonVersionsFilename);
        return commonVersionsFilename;
    }
    /**
     * Gets the settings from the common-versions.json config file for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getCommonVersions(variant) {
        const commonVersionsFilename = this.getCommonVersionsFilePath(variant);
        return CommonVersionsConfiguration_1.CommonVersionsConfiguration.loadFromFile(commonVersionsFilename);
    }
    /**
     * Gets the committed shrinkwrap file name for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getCommittedShrinkwrapFilename(variant) {
        if (variant) {
            if (!this._variants[variant]) {
                throw new Error(`Invalid variant name '${variant}'. The provided variant parameter needs to be ` +
                    `one of the following from rush.json: ` +
                    `${Object.keys(this._variants).map((name) => `"${name}"`).join(', ')}.`);
            }
        }
        const variantConfigFolderPath = this._getVariantConfigFolderPath(variant);
        return path.join(variantConfigFolderPath, this._shrinkwrapFilename);
    }
    /**
     * Gets the absolute path for "pnpmfile.js" for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     * @remarks
     * The file path is returned even if PNPM is not configured as the package manager.
     */
    getPnpmfilePath(variant) {
        const variantConfigFolderPath = this._getVariantConfigFolderPath(variant);
        return path.join(variantConfigFolderPath, RushConstants_1.RushConstants.pnpmfileFilename);
    }
    /**
     * Looks up a project in the projectsByName map.  If the project is not found,
     * then undefined is returned.
     */
    getProjectByName(projectName) {
        return this._projectsByName.get(projectName);
    }
    /**
     * This is used e.g. by command-line interfaces such as "rush build --to example".
     * If "example" is not a project name, then it also looks for a scoped name
     * like `@something/example`.  If exactly one project matches this heuristic, it
     * is returned.  Otherwise, undefined is returned.
     */
    findProjectByShorthandName(shorthandProjectName) {
        // Is there an exact match?
        let result = this._projectsByName.get(shorthandProjectName);
        if (result) {
            return result;
        }
        // Is there an approximate match?
        for (const project of this._projects) {
            if (node_core_library_1.PackageName.getUnscopedName(project.packageName) === shorthandProjectName) {
                if (result) {
                    // Ambiguous -- there is more than one match
                    return undefined;
                }
                else {
                    result = project;
                }
            }
        }
        return result;
    }
    /**
     * Looks up a project by its RushConfigurationProject.tempProjectName field.
     * @returns The found project, or undefined if no match was found.
     */
    findProjectByTempName(tempProjectName) {
        // Is there an approximate match?
        for (const project of this._projects) {
            if (project.tempProjectName === tempProjectName) {
                return project;
            }
        }
        return undefined;
    }
    /**
     * @beta
     */
    get versionPolicyConfiguration() {
        return this._versionPolicyConfiguration;
    }
    /**
     * This configuration object contains settings repo maintainers have specified to enable
     * and disable experimental Rush features.
     *
     * @beta
     */
    get experimentsConfiguration() {
        return this._experimentsConfiguration;
    }
    /**
     * Returns the project for which the specified path is underneath that project's folder.
     * If the path is not under any project's folder, returns undefined.
     */
    tryGetProjectForPath(currentFolderPath) {
        const resolvedPath = path.resolve(currentFolderPath);
        for (const project of this.projects) {
            if (node_core_library_1.Path.isUnderOrEqual(resolvedPath, project.projectFolder)) {
                return project;
            }
        }
        return undefined;
    }
    _populateDownstreamDependencies(dependencies, packageName) {
        if (!dependencies) {
            return;
        }
        Object.keys(dependencies).forEach(dependencyName => {
            const depProject = this._projectsByName.get(dependencyName);
            if (depProject) {
                depProject.downstreamDependencyProjects.push(packageName);
            }
        });
    }
    _getVariantConfigFolderPath(variant) {
        if (variant) {
            if (!this._variants[variant]) {
                throw new Error(`Invalid variant name '${variant}'. The provided variant parameter needs to be ` +
                    `one of the following from rush.json: ` +
                    `${Object.keys(this._variants).map((name) => `"${name}"`).join(', ')}.`);
            }
        }
        return path.join(this._commonRushConfigFolder, ...(variant ? [RushConstants_1.RushConstants.rushVariantsFolderName, variant] : []));
    }
}
RushConfiguration._jsonSchema = node_core_library_1.JsonSchema.fromFile(path.join(__dirname, '../schemas/rush.schema.json'));
exports.RushConfiguration = RushConfiguration;
//# sourceMappingURL=RushConfiguration.js.map