"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const path = require("path");
const true_case_path_1 = require("true-case-path");
/**
 * Provides Rush-specific environment variable data. All Rush environment variables must start with "RUSH_". This class
 * is designed to be used by RushConfiguration.
 *
 * @remarks
 * Initialize will throw if any unknown parameters are present.
 */
class EnvironmentConfiguration {
    /**
     * An override for the common/temp folder path.
     */
    static get rushTempFolderOverride() {
        EnvironmentConfiguration._ensureInitialized();
        return EnvironmentConfiguration._rushTempFolderOverride;
    }
    /**
     * If "true", create symlinks with absolute paths instead of relative paths.
     * See {@link EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS}
     */
    static get absoluteSymlinks() {
        EnvironmentConfiguration._ensureInitialized();
        return EnvironmentConfiguration._absoluteSymlinks;
    }
    /**
     * If this environment variable is set to "true", the Node.js version check will print a warning
     * instead of causing a hard error if the environment's Node.js version doesn't match the
     * version specifier in `rush.json`'s "nodeSupportedVersionRange" property.
     *
     * See {@link EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS}.
     */
    static get allowUnsupportedNodeVersion() {
        EnvironmentConfiguration._ensureInitialized();
        return EnvironmentConfiguration._allowUnsupportedNodeVersion;
    }
    /**
     * Reads and validates environment variables. If any are invalid, this function will throw.
     */
    static initialize(options = {}) {
        EnvironmentConfiguration.reset();
        const unknownEnvVariables = [];
        for (const envVarName in process.env) {
            if (process.env.hasOwnProperty(envVarName) && envVarName.match(/^RUSH_/i)) {
                const value = process.env[envVarName];
                // Environment variables are only case-insensitive on Windows
                const normalizedEnvVarName = os.platform() === 'win32' ? envVarName.toUpperCase() : envVarName;
                switch (normalizedEnvVarName) {
                    case "RUSH_TEMP_FOLDER" /* RUSH_TEMP_FOLDER */: {
                        EnvironmentConfiguration._rushTempFolderOverride = (value && !options.doNotNormalizePaths)
                            ? EnvironmentConfiguration._normalizeDeepestParentFolderPath(value) || value
                            : value;
                        break;
                    }
                    case "RUSH_ABSOLUTE_SYMLINKS" /* RUSH_ABSOLUTE_SYMLINKS */: {
                        EnvironmentConfiguration._absoluteSymlinks = value === 'true';
                        break;
                    }
                    case "RUSH_ALLOW_UNSUPPORTED_NODEJS" /* RUSH_ALLOW_UNSUPPORTED_NODEJS */: {
                        EnvironmentConfiguration._allowUnsupportedNodeVersion = value === 'true';
                        break;
                    }
                    case "RUSH_PREVIEW_VERSION" /* RUSH_PREVIEW_VERSION */:
                    case "RUSH_VARIANT" /* RUSH_VARIANT */:
                        // Handled by @microsoft/rush front end
                        break;
                    default:
                        unknownEnvVariables.push(envVarName);
                        break;
                }
            }
        }
        // This strictness intends to catch mistakes where variables are misspelled or not used correctly.
        if (unknownEnvVariables.length > 0) {
            throw new Error('The following environment variables were found with the "RUSH_" prefix, but they are not ' +
                `recognized by this version of Rush: ${unknownEnvVariables.join(', ')}`);
        }
        EnvironmentConfiguration._hasBeenInitialized = true;
    }
    /**
     * Resets EnvironmentConfiguration into an un-initialized state.
     */
    static reset() {
        EnvironmentConfiguration._rushTempFolderOverride = undefined;
        EnvironmentConfiguration._hasBeenInitialized = false;
    }
    static _ensureInitialized() {
        if (!EnvironmentConfiguration._hasBeenInitialized) {
            throw new Error('The EnvironmentConfiguration must be initialized before values can be accessed.');
        }
    }
    /**
     * Given a path to a folder (that may or may not exist), normalize the path, including casing,
     * to the first existing parent folder in the path.
     *
     * If no existing path can be found (for example, if the root is a volume that doesn't exist),
     * this function returns undefined.
     *
     * @example
     * If the following path exists on disk: C:\Folder1\folder2\
     * _normalizeFirstExistingFolderPath('c:\\folder1\\folder2\\temp\\subfolder')
     * returns 'C:\\Folder1\\folder2\\temp\\subfolder'
     */
    static _normalizeDeepestParentFolderPath(folderPath) {
        folderPath = path.normalize(folderPath);
        const endsWithSlash = folderPath.charAt(folderPath.length - 1) === path.sep;
        const parsedPath = path.parse(folderPath);
        const pathRoot = parsedPath.root;
        const pathWithoutRoot = parsedPath.dir.substr(pathRoot.length);
        const pathParts = [...pathWithoutRoot.split(path.sep), parsedPath.name].filter((part) => !!part);
        // Starting with all path sections, and eliminating one from the end during each loop iteration,
        // run trueCasePathSync. If trueCasePathSync returns without exception, we've found a subset
        // of the path that exists and we've now gotten the correct casing.
        //
        // Once we've found a parent folder that exists, append the path sections that didn't exist.
        for (let i = pathParts.length; i >= 0; i--) {
            const constructedPath = path.join(pathRoot, ...pathParts.slice(0, i));
            try {
                const normalizedConstructedPath = true_case_path_1.trueCasePathSync(constructedPath);
                const result = path.join(normalizedConstructedPath, ...pathParts.slice(i));
                if (endsWithSlash) {
                    return `${result}${path.sep}`;
                }
                else {
                    return result;
                }
            }
            catch (e) {
                // This path doesn't exist, continue to the next subpath
            }
        }
        return undefined;
    }
}
EnvironmentConfiguration._hasBeenInitialized = false;
EnvironmentConfiguration._absoluteSymlinks = false;
EnvironmentConfiguration._allowUnsupportedNodeVersion = false;
exports.EnvironmentConfiguration = EnvironmentConfiguration;
//# sourceMappingURL=EnvironmentConfiguration.js.map