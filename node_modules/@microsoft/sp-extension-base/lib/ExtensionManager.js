import { _ComponentBaseKillSwitches, _LegacyThirdPartyFabricCoreLoader } from '@microsoft/sp-component-base';
import { Guid, Text } from '@microsoft/sp-core-library';
import { _LogSource, _QosMonitor, _TraceLogger } from '@microsoft/sp-diagnostics';
import { SPComponentLoader } from '@microsoft/sp-loader';
import { _PerformanceLogger } from '@ms/sp-telemetry';
import BaseExtension from './BaseExtension';
import strings from './ExtensionStrings.resx';
/**
 * `ExtensionManager` manages a collection of extensions and provides APIs to create, dispose
 * and access its managed extensions.
 *
 * @remarks
 * Any application that needs to use extensions, should use `ExtensionManager` to create those extensions
 * by passing in their `componentId` and properties. `ExtensionManager` takes care of loading modules and
 * creating the instances for the extensions and provides APIs to manage the created extensions.
 *
 * @internal
 */
var ExtensionManager = /** @class */ (function () {
    /**
     * Creates a new instance of `ExtensionManager`.
     *
     * @remarks
     * If you construct an instance of this class, you must dispose it by calling `ExtensionManager.dispose()`;
     * otherwise resource leaks may occur.
     *
     * @param serviceScope - The serviceScope provided by the caller application
     * @param expectedType - for validation purposes, a base class that the resulting object
     *   is expected to extend
     */
    function ExtensionManager(serviceScope, expectedType) {
        this._serviceScope = serviceScope;
        this._expectedType = expectedType;
        this._extensions = [];
    }
    /**
     * Creates an extension instance by loading its module based on the provided componentId and then creates an instance
     * of the extension by passing in the provided properties JSON and context creator.
     *
     * @remarks
     * The provided componentId is a Guid that identifies the module containing the extension (as its default export).
     * The module loader of SharePoint Framework will load the module if its manifest is found on the page
     * (for example, if the extension is installed) and create an instace of the extension and initialize it using
     * the provided contextCreator and propertiesJson. Since this process is asynchronous, the manager returns a promise
     * that resolves once the extension instance is ready.
     *
     * The extension will be disposed by `ExtensionManager.dispose()`.
     *
     * @param componentId - the client-side component ID for the extension.
     * @param propertiesJson - a text string containing an optional JSON object.
     * @param contextCreator - a callback function that constructs an appropriate ExtensionContext
     */
    ExtensionManager.prototype.createExtension = function (componentId, propertiesJson, contextCreator) {
        var _this = this;
        var qosMonitor = new _QosMonitor('Extension.Create', true);
        var manifest = SPComponentLoader.tryGetManifestById(componentId);
        if (!manifest) {
            var manifestError = new Error(Text.format(strings.manifestNotFound, componentId));
            qosMonitor.writeUnexpectedFailure('ManifestNotFound', manifestError, { componentId: componentId });
            return Promise.reject(manifestError);
        }
        var extraData = this._createQosExtraData(manifest);
        try {
            var instanceId = Guid.newGuid().toString();
            var loggingTag = "Extension." + manifest.id + "." + instanceId;
            var context_1 = contextCreator({
                manifest: manifest,
                parentServiceScope: this._serviceScope,
                instanceId: instanceId,
                loggingTag: loggingTag
            });
            var perfLogKeyCreate_1 = loggingTag + '.Extension.Create';
            var perfLogKeyScriptLoad_1 = loggingTag + '.Extension.ScriptLoad';
            _PerformanceLogger.startMarkForComponent(perfLogKeyCreate_1);
            var error_1 = undefined;
            _PerformanceLogger.startMarkForComponent(perfLogKeyScriptLoad_1);
            var createPromise = SPComponentLoader.loadComponent(manifest).then(function (component) {
                _PerformanceLogger.endMarkForComponent(perfLogKeyScriptLoad_1);
                _PerformanceLogger.logPerformanceMetricToConsole(perfLogKeyScriptLoad_1, 'Extension.ScriptLoad', manifest.id, manifest.alias);
                var extensionClass = component.default;
                var extension = new extensionClass();
                if (!(extension instanceof BaseExtension)) {
                    error_1 = new Error(strings.expectingBaseExtension);
                    qosMonitor.writeExpectedFailure('DoesNotExtendBaseExtension', error_1, extraData);
                    throw error_1;
                }
                if (!(extension instanceof _this._expectedType)) {
                    error_1 = Error(Text.format(strings.wrongExtensionType, _this._expectedType));
                    qosMonitor.writeExpectedFailure('WrongExtensionType', error_1, extraData);
                    throw error_1;
                }
                return extension._init(context_1, propertiesJson).then(function () {
                    return extension;
                }).catch(function (e) {
                    error_1 = new Error(Text.format(strings.extensionInitFailure, componentId));
                    qosMonitor.writeExpectedFailure('ExtensionInitFailure', error_1, extraData);
                    throw error_1;
                });
            }, function (e) {
                if (!error_1) {
                    error_1 = new Error(Text.format(strings.extensionLoadFailure, componentId));
                    qosMonitor.writeExpectedFailure('ExtensionLoadFailure', error_1, extraData);
                }
                throw error_1;
            }).then(function (extension) {
                qosMonitor.writeSuccess(extraData);
                _PerformanceLogger.endMarkForComponent(perfLogKeyCreate_1);
                _PerformanceLogger.logPerformanceMetricToConsole(perfLogKeyScriptLoad_1, 'Extension.Create', manifest.id, manifest.alias);
                _this._extensions.push(extension);
                return extension;
            });
            // Async Loading of legacy fabric core styles (for third-party backward compatibility).
            // We do not want to wait until the load finishes as it might effect actual page render time.
            // Wait on this call to complete only if there is considerable flicker on the page.
            var fabricLoadingPromise = (_ComponentBaseKillSwitches.isStopLoadingLegacyFabricCSSKillSwitchActivated()
                ? _LegacyThirdPartyFabricCoreLoader.load(manifest.isInternal)
                : _LegacyThirdPartyFabricCoreLoader.forceLoad(manifest));
            fabricLoadingPromise.catch(function (e) { return _TraceLogger.logError(ExtensionManager._logSource, new Error("Failed to load legacy fabric core styles: " + e)); });
            return createPromise;
        }
        catch (e) {
            qosMonitor.writeUnexpectedFailure('UnhandledCreateError', e, extraData);
            // If the synchronous code throws an exception, reject the promise
            return Promise.reject(e);
        }
    };
    /**
     * Disposes any extensions that were created via `createExtension()`.
     * This is performed by calling `BaseExtension.dispose()` for each extension.
     */
    ExtensionManager.prototype.dispose = function () {
        if (!this._isDisposed) {
            this.disposeExtensions();
            delete this._serviceScope;
            delete this._extensions;
            delete this._expectedType;
        }
        this._isDisposed = true;
    };
    Object.defineProperty(ExtensionManager.prototype, "isDisposed", {
        /** {@inheritDoc @microsoft/sp-core-library#IDisposable.isDisposed} */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes all extensions created using this extensions manager.
     */
    ExtensionManager.prototype.disposeExtensions = function () {
        for (var _i = 0, _a = this._extensions; _i < _a.length; _i++) {
            var extension = _a[_i];
            try {
                extension.dispose();
            }
            catch (e) {
                var manifest = extension.manifest;
                _TraceLogger.logError(ExtensionManager._logSource, new Error("Failed to dispose extension \"" + manifest.alias + "\"\n            + \" with id=" + manifest.id + ": " + e.message));
            }
        }
        this._extensions = [];
    };
    /**
     * Creates a new extra data object the `Extension.Create` QoS monitor.
     */
    ExtensionManager.prototype._createQosExtraData = function (manifest) {
        var qosExtraData = {
            alias: manifest.alias,
            isInternal: manifest.isInternal,
            manifestId: manifest.id,
            extensionType: manifest.extensionType
        };
        return qosExtraData;
    };
    ExtensionManager._logSource = _LogSource.create('ExtensionManager');
    return ExtensionManager;
}());
export default ExtensionManager;
//# sourceMappingURL=ExtensionManager.js.map