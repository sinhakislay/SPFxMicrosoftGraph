// Copyright (c) Microsoft. All rights reserved.
import { _EngagementLogger, _LogSource, _TraceLogger } from '@microsoft/sp-diagnostics';
import { Flights } from './../common/Flights';
import KillSwitches from './../common/KillSwitches';
import { Validate } from '@microsoft/sp-core-library';
import * as lodash from '@microsoft/sp-lodash-subset';
import strings from './loc/Strings.resx';
// TODO: VSO#421046 ViewportLoader adopt ScrollEventHandler after Ignite fork on 9/8/17
/**
 * The source which triggered loading of the web part.
 */
var WebPartLoadSource;
(function (WebPartLoadSource) {
    /**
     * Web part is loaded during register as it was found in viewport.
     */
    WebPartLoadSource[WebPartLoadSource["viewport"] = 1] = "viewport";
    /**
     * Web part is loaded due to scroll.
     */
    WebPartLoadSource[WebPartLoadSource["scroll"] = 2] = "scroll";
    /**
     * Web part is loaded for loading outside viewport once viewport web parts are rendered.
     */
    WebPartLoadSource[WebPartLoadSource["loadOutsideViewport"] = 3] = "loadOutsideViewport";
})(WebPartLoadSource || (WebPartLoadSource = {}));
var INTERSECTION_OBSERVER = 'IntersectionObserver';
/**
 * Class that helps lazy loading of web parts. This class centrally manages
 * registered web parts to be rendered lazily when in the viewport. i.e. Web parts
 * that are not in the view port will not be rendered on the initial load. They will
 * be rendered only when the user scrolls to the web part. This class manages the
 * scroll/resize event handling and notification to the web parts to render when
 * they are near the viewport.
 *
 * E.g. Modern pages web parts in viewport will be loaded. All other web parts are
 * lazily loaded when the user scrolls the view port and that perticular web part is
 * in the view.
 *
 * @internal
 */
var ViewportLoader = /** @class */ (function () {
    /**
    * Private Contructor of singleton class
    */
    function ViewportLoader() {
        /**
         * Registered web parts.
         */
        this._webparts = new Set();
        this._observerMap = new Map();
        /**
         * This attribute managed the number of scroll event handlers that are registered to
         * a scrollable parent. When the number of events becomes zero, the event handler is
         * unregistered.
         */
        this._lazyLoadedTrackerAttribute = 'data-sp-webpart-lazycount';
        this.SCROLL = 'scroll';
        this.RESIZE = 'resize';
        this._isInitialized = false;
        this._logSource = _LogSource.create('ViewportLoader');
        this._isListeningWindow = false;
        /**
         * These are the web parts being loaded proactivery by increasing viewport offset.
         * It is used to track when all are rendered so viewport offset can be increased further.
         */
        this._offsetWebpartsToLoad = [];
        this._bind();
        ViewportLoader._useIntersectionObserver = !!window[INTERSECTION_OBSERVER];
        if (ViewportLoader._useIntersectionObserver) {
            this._observer = new IntersectionObserver(this._onObserved, { threshold: [0.01] });
        }
    }
    Object.defineProperty(ViewportLoader, "deprecatedInstance", {
        /**
         * Singleton instance of the original, web part-specific viewport loader.
         */
        get: function () {
            // Lazy initialize the singleton
            if (ViewportLoader._instance === undefined) {
                ViewportLoader._instance = new ViewportLoader();
            }
            return ViewportLoader._instance;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns true if the web part is in the initial page viewport.
     */
    ViewportLoader.isInInitialViewport = function (webpart) {
        if (ViewportLoader.optimizeViewportLoader()) {
            return webpart._registeredInViewport;
        }
        Validate.isNotNullOrUndefined(webpart, 'webpart');
        var viewportHeight = window.innerHeight || document.documentElement.clientHeight;
        var top = webpart.domElement && webpart.domElement.getBoundingClientRect().top;
        // 10% Offset from the bottom of the viewport for which we want to ignore from EUPL.
        // So web part top should be at least 10% above from bottom to be counted into viewport
        var euplViewportOffset = Math.floor(viewportHeight * 0.1);
        if ((window.pageYOffset + top) < (viewportHeight - euplViewportOffset)) {
            return true;
        }
        return false;
    };
    ViewportLoader.optimizeViewportLoader = function () {
        if (KillSwitches.isIE11IntersectionObserverBugFixEnabled()) {
            return !!window[INTERSECTION_OBSERVER];
        }
        else {
            return ViewportLoader._useIntersectionObserver;
        }
    };
    /**
     * Determines if a web part should be lazily loaded and register such web parts.
     */
    ViewportLoader.prototype.register = function (webpart, scrollableParent) {
        var _this = this;
        Validate.isNotNullOrUndefined(webpart, 'webpart');
        webpart._registeredInViewport = false;
        if (!this._isInitialized) {
            this._initialize();
        }
        if (ViewportLoader.optimizeViewportLoader() && Flights.isSyncLoadWebpartInViewportEnabled()) {
            this._webparts.add(webpart);
        }
        this._checkVisibilityAndRender(webpart, WebPartLoadSource.viewport);
        // The web part is in the view port and has started rendering.
        if (webpart._registeredInViewport) {
            return;
        }
        // Use if scrollable parent is provided, as that is more performant.
        var parents = scrollableParent ? [scrollableParent] : this._findScrollableParents(webpart.domElement);
        // We want to listen to the scrollable parent's scroll event, if one exists.
        parents.forEach(function (parent, index, allPatents) {
            var count = _this._updateRegisteredChildren(parent, 1);
            // We want to add event listener once per common scrollable parent of web parts.
            if (count === 1) {
                _this._listenEvents(parent);
            }
        });
        this._listenEvents(window);
        if (!ViewportLoader.optimizeViewportLoader() || !Flights.isSyncLoadWebpartInViewportEnabled()) {
            this._webparts.add(webpart);
        }
        if (!!this._noMoreLazy) {
            // By this time, Viewport loader has loaded all web parts registered and now received request to load one
            // more web part. Mark _noMoreLazy to false so we know ViewportLoader is again in the business of loading
            // outside the viewport.
            // Even in no more lazy state, we use this channel to load web parts to ensure we don't end up loading a web part
            // at far bottom of the page before one just below view port.
            _TraceLogger.logVerbose(this._logSource, 'Web part to load after no more lazy state');
            this._noMoreLazy = false;
            this._loadOutsideViewPort();
        }
    };
    /**
     * Render web part if in the waiting queue of viewport loader
     * @param webPart
     */
    ViewportLoader.prototype.release = function (webPart) {
        Validate.isNotNullOrUndefined(webPart, 'release Web part');
        if (this._webparts.has(webPart)) {
            this._renderWebpartInViewport(webPart, WebPartLoadSource.viewport);
            this.unregister(webPart);
            return true;
        }
        return false;
    };
    /**
     * Unregister a loaded web part which should not be tracked any more.
     */
    ViewportLoader.prototype.unregister = function (webpart) {
        var _this = this;
        Validate.isNotNullOrUndefined(webpart, 'unregister Web part');
        if (!this._webparts.has(webpart)) {
            return;
        }
        this._webparts.delete(webpart);
        var parents = this._findScrollableParents(webpart.domElement);
        parents.forEach(function (parent, index, allParents) {
            var count = _this._updateRegisteredChildren(parent, -1);
            if (count <= 0) {
                _this._unlistenEvents(parent);
            }
        });
        if (this._webparts.size === 0 && !!this._noMoreLazy) {
            // Done loading all lazily loaded web parts.
            this._unlistenEvents(window);
            this._dispose();
        }
    };
    /**
     * Load registered web parts not in the viewport, by gradually increasing viewport offset.
     */
    ViewportLoader.prototype.loadOutsideViewPort = function () {
        _TraceLogger.logVerbose(this._logSource, "loadOutsideViewPort is called to load rest of the " + this._webparts.size + " web parts");
        this._loadOutsideViewPort();
        _TraceLogger.logVerbose(this._logSource, "loadOutsideViewPort is completed");
    };
    /**
     * Bind all functions to this instance
     */
    ViewportLoader.prototype._bind = function () {
        this.register = this.register.bind(this);
        this.unregister = this.unregister.bind(this);
        this._checkVisibilityAndRender = this._checkVisibilityAndRender.bind(this);
        this._dispose = this._dispose.bind(this);
        this._findScrollableParent = this._findScrollableParent.bind(this);
        this._findScrollableParents = this._findScrollableParents.bind(this);
        this._initialize = this._initialize.bind(this);
        this._isCloseToViewport = this._isCloseToViewport.bind(this);
        this._renderWebpartInViewport = this._renderWebpartInViewport.bind(this);
        this._unlistenEvents = this._unlistenEvents.bind(this);
        this._updateRegisteredChildren = this._updateRegisteredChildren.bind(this);
        this._loadOutsideViewPort = this._loadOutsideViewPort.bind(this);
        this._onObserved = this._onObserved.bind(this);
    };
    /**
     * Event handler which is called upon scroll and resize events.
     */
    ViewportLoader.prototype._lazyLoaderEventHandler = function () {
        this._loadWebPartsInViewport(WebPartLoadSource.scroll);
    };
    ViewportLoader.prototype._loadWebPartsInViewport = function (loadSource) {
        var _this = this;
        if (!this._webparts || this._webparts.size === 0) {
            _TraceLogger.logVerbose(this._logSource, strings.LazyEventOnNoLazyWebpart, 'InViewportHandler');
            return;
        }
        this._webparts.forEach(function (value, index, theSet) {
            _this._checkVisibilityAndRender(value, loadSource);
        });
    };
    /**
    * Handler to start rendering web part if it is close enough to the viewport.
    */
    ViewportLoader.prototype._checkVisibilityAndRender = function (webPart, loadSource) {
        // This webpart has already been loaded, just unregister if not already.
        if (webPart._registeredInViewport) {
            this.unregister(webPart);
            return;
        }
        if (ViewportLoader.optimizeViewportLoader()) {
            this._observerMap.set(webPart.domElement, webPart);
            this._observer.observe(webPart.domElement);
            // Load sync if already in viewport
            this._onObserved(this._observer.takeRecords());
        }
        else if (this._isCloseToViewport(webPart.domElement)) {
            this._renderWebpartInViewport(webPart, loadSource);
            this.unregister(webPart);
        }
    };
    ViewportLoader.prototype._onObserved = function (observedEntries) {
        var _this = this;
        observedEntries.forEach(function (entry) {
            if ((entry.isIntersecting || entry.intersectionRatio > 0) && entry.boundingClientRect) {
                _this._observer.unobserve(entry.target);
                var webPart = _this._observerMap.get(entry.target);
                if (webPart) {
                    _this._observerMap.delete(entry.target);
                    _this.release(webPart);
                }
            }
        });
    };
    /**
    * Check if web part is close enough to the viewport to be shown.
    */
    ViewportLoader.prototype._isCloseToViewport = function (webpartNode) {
        try {
            var parent_1 = this._findScrollableParent(webpartNode);
            var _a = webpartNode.getBoundingClientRect(), top_1 = _a.top, height = _a.height;
            var documentHeight = window.innerHeight || document.documentElement.clientHeight;
            if (!parent_1) {
                // There is no overflow parent, check distance from window
                var topInOrAboveViewport = (top_1 - this._offset) <= documentHeight;
                var bottomNotAboveViewport = (top_1 + height + this._offset) >= 0;
                return topInOrAboveViewport && bottomNotAboveViewport;
            }
            // tslint:disable-next-line:no-use-before-declare
            var _b = parent_1.getBoundingClientRect(), parentTop = _b.top, parentHeight = _b.height;
            // Parent and viewport's intersection. 0 is top of the viewport
            var parentIntersectionTop = Math.max(0, parentTop);
            var parentIntersectionHeight = Math.min(parentTop + parentHeight, documentHeight) - parentIntersectionTop;
            // element's top relative to intersection
            var offsetTop = top_1 - parentIntersectionTop;
            var parentTopInOrAboveViewport = (offsetTop - this._offset) <= parentIntersectionHeight;
            var parentBottomNotAboveViewport = (offsetTop + height + this._offset) >= 0;
            return parentTopInOrAboveViewport && parentBottomNotAboveViewport;
        }
        catch (error) {
            _TraceLogger.logError(this._logSource, error);
            // We want to avoid lazy loading as a fallback
            return true;
        }
    };
    /**
    * Returns all scrollable parent DOM Elements of the given element
    */
    ViewportLoader.prototype._findScrollableParents = function (startingElement) {
        var parents = [];
        var parent = startingElement;
        while (parent) {
            parent = this._findScrollableParent(parent);
            if (parent) {
                parents.push(parent);
                parent = parent.parentElement;
            }
        }
        return parents;
    };
    /**
     * Traverses up the DOM tree for the element with the data-is-scrollable=true attribute,
     * or return the window object.
     */
    ViewportLoader.prototype._findScrollableParent = function (startingElement) {
        var DATA_IS_SCROLLABLE_ATTRIBUTE = 'data-is-scrollable';
        var el = startingElement;
        var body = document.body;
        // First do a quick scan for the scrollable attribute.
        while (el && el !== body) {
            if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) === 'true') {
                return el;
            }
            el = el.parentElement;
        }
        // If we haven't found it, the use the slower method: compute styles to evaluate if overflow is set.
        el = startingElement;
        while (el && el !== body) {
            if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) !== 'false') {
                var styles = getComputedStyle(el);
                if (styles) {
                    var overflowY = styles.getPropertyValue('overflow-y');
                    if (overflowY && (overflowY === this.SCROLL || overflowY === 'auto')) {
                        return el;
                    }
                }
            }
            el = el.parentElement;
        }
        // Fall back to window scroll.
        if (!el || el === body) {
            el = undefined;
        }
        return el;
    };
    ViewportLoader.prototype._initialize = function () {
        this._offset = 0;
        this._initTime = new Date();
        this._lazyHandler = lodash.throttle(this._lazyLoaderEventHandler, 100).bind(this);
        _TraceLogger.logVerbose(this._logSource, 'ViewportLoader is Initialized');
        this._isInitialized = true;
    };
    ViewportLoader.prototype._dispose = function () {
        _TraceLogger.logVerbose(this._logSource, 'ViewportLoader is disposed');
        var timeSpent = (new Date()).getTime() - this._initTime.getTime();
        _EngagementLogger.logEvent('Webpart.ViewportLoad.Completed', timeSpent.toString());
        this._isInitialized = false;
        this._initTime = undefined;
    };
    /**
    * Start listening to scroll and resize events. It is safe to call this API multiple times on a DOM
    * element, it does not lead to multiple attached events.
    */
    ViewportLoader.prototype._listenEvents = function (parent) {
        if (!parent) {
            return;
        }
        var isWindow = parent === window;
        if (!isWindow || (isWindow && !this._isListeningWindow)) {
            this._addEventListerer(parent);
            if (isWindow) {
                this._isListeningWindow = true;
            }
        }
    };
    /**
     * Add Listener to scroll and resize events for given element or window
     */
    ViewportLoader.prototype._addEventListerer = function (element) {
        element.addEventListener(this.SCROLL, this._lazyHandler, false);
        element.addEventListener(this.RESIZE, this._lazyHandler, false);
    };
    /**
    * Stop listening to scroll and resize events.
    */
    ViewportLoader.prototype._unlistenEvents = function (parent) {
        if (!parent) {
            return;
        }
        var isWindow = parent === window;
        if (!isWindow || (isWindow && this._isListeningWindow)) {
            this._removeEventListener(parent);
            if (isWindow) {
                this._isListeningWindow = false;
            }
        }
    };
    /**
     * Remove Listeners from scroll and resize events for given element or window
     */
    ViewportLoader.prototype._removeEventListener = function (element) {
        element.removeEventListener(this.SCROLL, this._lazyHandler);
        element.removeEventListener(this.RESIZE, this._lazyHandler);
    };
    /**
     * It keeps track of how many lazily loaded children are registered to a scrollable parent.
     * This record keeping is required to deregister event handler from the parent when There
     * are no children listening to events.
     */
    ViewportLoader.prototype._updateRegisteredChildren = function (element, count) {
        var lazyChilds = count + Number(element.getAttribute(this._lazyLoadedTrackerAttribute));
        if (count !== 0) {
            element.setAttribute(this._lazyLoadedTrackerAttribute, lazyChilds.toString());
        }
        return lazyChilds;
    };
    /**
     * Ask web part to load.
     */
    ViewportLoader.prototype._renderWebpartInViewport = function (webpart, loadSource) {
        if (webpart && !webpart._registeredInViewport) {
            webpart._onInViewport();
            switch (loadSource) {
                case WebPartLoadSource.viewport:
                    webpart._registeredInViewport = true;
                    _TraceLogger.logVerbose(this._logSource, 'Web part is loaded in initial viewport.');
                    break;
            }
        }
    };
    /**
     * Load registered web parts not in the viewport, by gradually increasing viewport offset.
     * It also tracks when web parts are rendered to reduce the gap between increasing offset
     */
    ViewportLoader.prototype._loadOutsideViewPort = function () {
        var _this = this;
        if (!this._webparts || this._webparts.size === 0) {
            // Done loading all web parts, take note of this state.
            this._noMoreLazy = true;
            return;
        }
        if (ViewportLoader.optimizeViewportLoader()) {
            this._webparts.forEach(function (webpart, index, theSet) { return ViewportLoader.deprecatedInstance.release(webpart); });
            this._noMoreLazy = true;
            return;
        }
        for (var index = 0; this._offsetWebpartsToLoad && index < this._offsetWebpartsToLoad.length; index++) {
            if (!this._offsetWebpartsToLoad[index]._renderedOnce) {
                // Stil some web part has not loaded, lets wait to recheck again after 100 ms
                window.setTimeout(this._loadOutsideViewPort, 100);
                return;
            }
        }
        // All web parts renderd, empty the array for next lot and increase offset by 2 page height
        this._offsetWebpartsToLoad = [];
        var documentHeight = window.innerHeight || document.documentElement.clientHeight;
        this._offset = this._offset + documentHeight * 2;
        this._webparts.forEach(function (webpart, index, theSet) {
            if (_this._isCloseToViewport(webpart.domElement)) {
                _this._offsetWebpartsToLoad.push(webpart);
            }
        });
        // We are done increasing the offset, let Viewport loader do it's job now.
        this._loadWebPartsInViewport(WebPartLoadSource.loadOutsideViewport);
        // Check if more to be done
        if (this._webparts.size > 0) {
            // Not using setTimeout here to reduce wait period when web parts already rendered,
            // say because they are sync rendered.
            this._loadOutsideViewPort();
        }
        else {
            // Done loading all web parts, take note of this state.
            this._noMoreLazy = true;
        }
    };
    return ViewportLoader;
}());
export default ViewportLoader;
//# sourceMappingURL=ViewportLoader.js.map