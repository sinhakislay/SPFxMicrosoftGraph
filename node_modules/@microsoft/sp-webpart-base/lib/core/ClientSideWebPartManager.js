// Copyright (c) Microsoft. All rights reserved.
// This file contains code for the ClientSideWebPartManager. The web part host is expected to
// load and interact with web parts only through the web part manager APIs.
'use strict';
import { _ComponentBaseKillSwitches, _LegacyThirdPartyFabricCoreLoader } from '@microsoft/sp-component-base';
import { DisplayMode, Environment, EnvironmentType, Guid, SPEvent, Text, UrlQueryParameterCollection, UrlUtilities, Validate, _SPEventManager, _SPFlight } from '@microsoft/sp-core-library';
import { _EngagementLogger, _LogEntry, _LogSource, _LogType, _QosMonitor, _TraceLogger } from '@microsoft/sp-diagnostics';
import { SPHttpClient } from '@microsoft/sp-http';
import { SPComponentLoader } from '@microsoft/sp-loader';
import * as lodash from '@microsoft/sp-lodash-subset';
import { PageContext } from '@microsoft/sp-page-context';
import * as loadThemedStyles from '@ms/sp-load-themed-styles';
import { _PerformanceLogger } from '@ms/sp-telemetry';
import PropertyPaneLoader from '../PropertyPaneLoader';
import { executeWithoutFailing } from '../utils/ExecuteWithoutFailing';
import KillSwitches from './../common/KillSwitches';
import BaseClientSideWebPart from './BaseClientSideWebPart';
import ClassicPageUtils from './classicPages/ClassicPageUtils';
import ClientSideWebPartStatusRenderer from './ClientSideWebPartStatusRenderer';
import { SPWebPartError, SPWebPartErrorCode } from './error/SPWebPartError';
import { WebPartIsolationLevel } from './IWebPartData';
import IframedWebPartControllerLoader from './loaders/IframedWebPartControllerLoader';
import ViewportLoaderUtility from './ViewportLoaderUtility';
import ViewportLoader from './ViewportLoader';
import WebPartContext from './WebPartContext';
import WebPartLoadDataCollector from './WebPartLoadDataCollector';
import strings from './loc/Strings.resx';
var THUMBNAIL_MAX_URL_LENGTH = 255; // All SharePoint URL field types have this limit
var DOCVIZ_REGEX = /(\/_layouts\/15\/getpreview.ashx\/?(|(\?(.*?)))$)/i;
// Flight name is 'SppplatIframedWebPartControllerLoadingFeature'
var SPPPLAT_IFRAMED_WEBPART_CONTROLLER_FLIGHT_ID = 1147;
/**
 * The ClientSideWebPartManager is expected to be the public interface to client-side web parts. Each
 * host is expected to create an instance of this class and manage loading of all web parts in that host
 * through that one instance. e.g. On one page, if there are multiple Canvas objects, each one could have
 * one instance of this class. If the page hosts web parts without the Canvas, then the page can have an
 * instance of this class. Overall this class is expected to provide the following purpose:
 *
 *    - Orchestrates loading of one or more web parts in a host.
 *    - It takes care of loading web part dependencies asynchronously. Each web part loads completely
 *      independently of the other web parts in the host.
 *    - Keep a reference to all the loaded web parts and help provide bulk operations on the web parts.
 *    - Help manage memory leak type issues in one place.
 *    - Integrate the web parts with the PropertyPane and other external entities.
 *    - Help troubleshoot web parts during escalations.
 *
 * @internal
 */
var ClientSideWebPartManager = /** @class */ (function () {
    /**
     * Initialize the ClientSideWebPartManager.
     *
     * @param host - Reference to the host. A web part host is a component that is deemed capable of hosting a web
     * part. Any component that implements the IWebPartHost is allowed to host a web part.
     */
    function ClientSideWebPartManager(host) {
        /**
         * Dictionary of all the active web parts in this insance of the manager.
         */
        this._webparts = new Map();
        /**
         * Number of web parts asked to load, including web parts failed to load.
         */
        this._loadWebPartRequests = 0;
        /**
         * Web part status renderer instance scoped to this web part manager instance.
         */
        this._statusRenderer = new ClientSideWebPartStatusRenderer();
        /**
         * Dictionary of all the iframed web parts in this instance of the manager.
         */
        this._iframedWebpartInstanceIds = new Set();
        this._propertyPaneConsumerQueue = new Map();
        /**
         * Number of web parts that has finished rendering, including those that have failed
         */
        this._webPartRenderedCount = 0;
        this._displayMode = DisplayMode.Read;
        Validate.isNotNullOrUndefined(host, 'host');
        this._host = host;
        this._pageContext = host.serviceScope.consume(PageContext.serviceKey);
        this._onContainerResize = this._onContainerResize.bind(this);
        this._onPropertyPaneNotifications = this._onPropertyPaneNotifications.bind(this);
        this.requestPropertyPaneAction = this.requestPropertyPaneAction.bind(this);
        this.isPropertyPaneRenderedByWebPart = this.isPropertyPaneRenderedByWebPart.bind(this);
        this.isPropertyPaneOpen = this.isPropertyPaneOpen.bind(this);
        this._instantiateWebPart = this._instantiateWebPart.bind(this);
        this._handleErrorLoadingWebpart = this._handleErrorLoadingWebpart.bind(this);
        this._handleModulePromiseRejection = this._handleModulePromiseRejection.bind(this);
        this._onFirstTimeWebpartRender = this._onFirstTimeWebpartRender.bind(this);
        this._getViewportRenderedEndTime = this._getViewportRenderedEndTime.bind(this);
        // TODO: Remove along with graduation of flight WEXOptimizeViewportLoader
        this._getViewportRenderedEndTimeLegacy = this._getViewportRenderedEndTimeLegacy.bind(this);
        this._onAllWebpartsAdded = this._onAllWebpartsAdded.bind(this);
        if (_SPFlight.isEnabled(1314 /* ViewportLoaderGeneralized */)) {
            this._viewportLoader = host.viewportLoader;
        }
        if (KillSwitches.isIE11IntersectionObserverBugFixEnabled()) {
            this._deprecatedIsObserverEnabled = this._viewportLoader
                ? this._viewportLoader.optimizeViewportLoader()
                : ViewportLoader.optimizeViewportLoader();
        }
        if (ClientSideWebPartManager._webPartManagerList.length === 0) {
            this._initialzeOnResizeEventHandler();
        }
        ClientSideWebPartManager._webPartManagerList.push(this);
    }
    ClientSideWebPartManager._instanceOfBase = function (wp) {
        if (!wp) {
            return false;
        }
        else if (wp instanceof BaseClientSideWebPart) {
            return true;
        }
        else {
            /* tslint:disable-next-line:no-string-literal */
            var objectType = wp['__type'];
            return objectType === 'BaseClientSideWebPart' || objectType === 'BaseMRClientSideWebPart';
        }
    };
    ClientSideWebPartManager._addPerfProperty = function (key, value, addToExistingValue) {
        if (addToExistingValue === void 0) { addToExistingValue = false; }
        if (addToExistingValue) {
            var previousValue = _PerformanceLogger.getPerformanceProperty(key);
            if (previousValue && !isNaN(previousValue)) {
                value = value + previousValue;
            }
        }
        _PerformanceLogger.setPerformanceProperty(key, value);
    };
    ClientSideWebPartManager._getWebPartTag = function (wp) {
        if (!KillSwitches.ensureWebPartTag()) {
            return wp && wp.context.webPartTag;
        }
        var errorReason;
        if (!ClientSideWebPartManager._instanceOfBase(wp)) {
            errorReason = 'WebpartTag requested for non-webpart';
        }
        else if (!wp.context) { // wp not being defined is checked by _instanceOfBase
            errorReason = 'WebpartTag requested for instance that is missing context';
        }
        if (errorReason) {
            _TraceLogger.logError(ClientSideWebPartManager._logSource, new Error(errorReason));
            return undefined;
        }
        return wp.context.webPartTag;
    };
    Object.defineProperty(ClientSideWebPartManager, "isMaintenanceMode", {
        /**
         * Returns true if the maintenanceMode query string parameter is provided.
         */
        get: function () {
            var urlParams = new UrlQueryParameterCollection(window.location.href);
            return urlParams.getValue('maintenanceMode') === 'true';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Load a web part in the provided DOM element. Does the following steps
     *
     *    1. Validate params.
     *    2. Validate the web part manifest.
     *    3. Perform an async import of the web part modules from the provided manifest
     *      - i.e ClientSideWebPartManager._loadWebPartModules
     *    4. Instantiate and initialize the web part object
     *      - i.e. ClientSideWebPartManager._initializeWebPart
     *    5. Render the web part in the provided DOM element
     *      - i.e. ClientSideWebPartManager._renderWebPart
     *
     * If an error happens during any of the above steps, catch the error and log it.
     *
     * @param context - web part manager context.
     */
    ClientSideWebPartManager.prototype.loadWebPart = function (context) {
        var _this = this;
        this._loadWebPartRequests++;
        var instanceRequestCount = this._loadWebPartRequests;
        var loadModulePromise = undefined;
        var loadWebPartPromise = new Promise(function (resolve, reject) {
            _this._validateInput(context);
            // If this web part is being loaded in an iframe, load with IframedWebPartController.
            if (_SPFlight.isEnabled(SPPPLAT_IFRAMED_WEBPART_CONTROLLER_FLIGHT_ID) &&
                // The next two conditions are neccessary because the same web part
                // will cross this path twice, once when determining if we should load in an
                // iframe and the second time is when we are loading the web part inside
                // the iframe.
                context.webpartLoadExtraLogInfo.pageLayoutType &&
                context.webpartLoadExtraLogInfo.pageLayoutType !== "Isolated" /* Isolated */ &&
                (context.manifest.isolationLevel === WebPartIsolationLevel.DomIsolation ||
                    // 'isolatedDomain' is a string and we want to check if 'isolatedDomain' has value,
                    // instead of undefined or "".
                    !!context.manifest.isolatedDomain)) {
                _this._iframedWebpartInstanceIds.add(context.instanceId);
                var domainUrl_1 = _this._ensureUrl(context.manifest.isolatedDomain, _this._pageContext.site.absoluteUrl);
                return IframedWebPartControllerLoader().then(function (iframedWebPartControllerModule) {
                    if (!_this._iframedWebPartController) {
                        _this._iframedWebPartController = new iframedWebPartControllerModule(_this._host);
                    }
                    resolve(_this._iframedWebPartController.loadWebPart(domainUrl_1, _this._pageContext, context));
                }).catch(function (error) {
                    reject(error);
                });
            }
            else {
                // Performance and QoS markers
                var qosMonitor_1 = _this._createLoadQosMonitor();
                var webPartTag_1 = _this._createWebPartTag(context.manifest, context.instanceId);
                if (KillSwitches.ensureWebPartTag()) {
                    try {
                        qosMonitor_1.extraData = {
                            'alias': context.manifest.alias,
                            'webPartTag': webPartTag_1
                        };
                    }
                    catch (e) { /* no-op for debugging */ }
                }
                _TraceLogger.logVerboseData({
                    source: ClientSideWebPartManager._logSource,
                    message: Text.format(strings.LoadWebpartCalled, _this._loadWebPartRequests, context.totalWebparts, context.manifest.alias + "." + context.instanceId),
                    serviceScope: _this._host.serviceScope
                });
                _PerformanceLogger.devMark("ClientSideWebPartManager.loadWebPart(" + webPartTag_1 + ").start");
                if (context.displayMode === undefined) {
                    context.displayMode = DisplayMode.Read;
                }
                _this._displayMode = context.displayMode;
                var webpartLoadExtraData = context.webpartLoadExtraLogInfo;
                // We use webpartTag to make sure this one is unique for one kind of web part.
                webpartLoadExtraData.alias = _this._createWebPartTag(context.manifest, context.manifest.id);
                var logEntry = new _LogEntry('ClientSideWebPartManager', 'WebPartLoad', _LogType.Event, webpartLoadExtraData);
                _EngagementLogger.logEventWithLogEntry(logEntry);
                // Step-2: Validate the web part manifest.
                // If manifest is null, we should display an error. This can be a legitimate case when the manifest has
                // been deleted or web part removed from the tenant level repository or the web part is not being shipped
                // anymore but some page still contains a reference to an instance of that web part.
                if (!_this._validateManifest(context.manifest, context.displayMode, webPartTag_1)) {
                    var error = SPWebPartError.create(SPWebPartErrorCode.ManifestInvalid, webPartTag_1);
                    _this.renderError(context.domElement, error);
                    reject(error);
                }
                var manifest_1 = context.manifest; /* tslint:disable-line:no-any */
                var instanceId_1 = context.instanceId;
                var domElement_1 = context.domElement;
                // If the web part has data, take the title from the data.
                // If the web part has just been created from the Toolbox, use the title from the picked up entry.
                // Otherwise we know nothing, use the title from the first pre-configured entry in the manifest.
                var title = context.webPartData && context.webPartData.title
                    ? context.webPartData.title
                    : (manifest_1.title && manifest_1.title.default /* tslint:disable-line:no-any */
                        ? manifest_1.title.default /* tslint:disable-line:no-any */
                        : manifest_1.preconfiguredEntries[0].title.default);
                if (!KillSwitches.isWebPartLoadShimmerKSActivated() && _this._statusRenderer._displayLoadingIndicator) {
                    _this._statusRenderer._displayLoadingIndicator(domElement_1, title, webPartTag_1, context.reservedHeight, manifest_1.isInternal);
                }
                else {
                    // Start the loading indicator
                    if (manifest_1.isInternal && _this._statusRenderer._displayLoadingIndicator) {
                        // call the internal version to write a performance marker when the loading indicator renders
                        // after the optional loading indicator wait time
                        _this._statusRenderer._displayLoadingIndicator(domElement_1, title, webPartTag_1, context.reservedHeight);
                    }
                    else {
                        _this._statusRenderer.displayLoadingIndicator(domElement_1, title);
                    }
                }
                // It is important that the 'startMarkForComponent' and 'endMarkForComponent'
                // performance logging are in the same method for readability.
                _PerformanceLogger.startMarkForComponent(webPartTag_1);
                // Step-3: Load all the modules and dependencies for the web part.
                loadModulePromise = _this._loadWebPartModules(context, webPartTag_1, qosMonitor_1);
                loadModulePromise.then(function (baseComponent) {
                    _PerformanceLogger.devMark("ClientSideWebPartManager.loadWebPart(" + webPartTag_1 + ").end");
                    // Step-4: Initialize the web part
                    try {
                        _this._initializeWebPart({
                            context: context,
                            moduleLibrary: baseComponent,
                            webPartTag: webPartTag_1,
                            qosMonitor: qosMonitor_1
                        });
                    }
                    catch (error) {
                        // Process error in Step-4 i.e. _renderWebPart.
                        // Error displaying is taken care of in 'this._initializeWebPart'
                        reject(error);
                        return;
                    }
                    // Step-5: Render the web part
                    return _this._renderWebPart({
                        context: context,
                        webPartTag: webPartTag_1,
                        qosMonitor: qosMonitor_1,
                        instanceRequestCount: instanceRequestCount
                    })
                        .then(function () {
                        _this._handleRenderComplete(webPartTag_1, manifest_1, qosMonitor_1, context, resolve);
                    }).catch(function (error) {
                        if (!KillSwitches.isLogWebPartLoadRenderDoneKillSwitchActivated()
                            && error instanceof SPWebPartError && error.id === SPWebPartErrorCode.RenderTimeout) {
                            qosMonitor_1.writeUnexpectedFailure('RenderTimeout', error);
                            // For Render timeout error case, we don't want show error message in web part zone
                            // and we still need perf data, so resolve it as success case.
                            _this._handleRenderComplete(webPartTag_1, manifest_1, qosMonitor_1, context, resolve);
                            return;
                        }
                        throw error;
                    }); // Process error in Step-5 i.e. _renderWebPart. (error display is taken care of there).
                })
                    .then(function () {
                    return _this._loadLegacyFabricCssIfRequired(context, qosMonitor_1);
                })
                    .catch(function (err) {
                    _this._handleModulePromiseRejection(manifest_1, instanceId_1, domElement_1, webPartTag_1, err, qosMonitor_1);
                    reject(err);
                });
            }
        });
        /**
         * We cannot assume the last web part will successfully load, and need to execute
         * _onAllWebpartsAdded to not break the page.
         *
         * If for some reason the promise rejected due to an invalid context we still pass a
         * fake context. Although if this happens, there are probably a lot more things broken.
         *
         * [VSO:SPPPlat:481999]
         */
        if (Environment.type !== EnvironmentType.ClassicSharePoint &&
            context.totalWebparts &&
            context.totalWebparts === instanceRequestCount) {
            // Capture the timing all web part has been processed by framework.
            // This does not include variable web part's module loading initialization and rendering speed
            // but speed of the framework to process the web parts.
            ClientSideWebPartManager._addPerfProperty('allWebPartsAdded', _PerformanceLogger.now());
            // If we were never able to load a module, use a rejected Promise.
            var addedPromise = loadModulePromise ||
                Promise.reject('No module promise');
            addedPromise.then(function () {
                _TraceLogger.logVerboseData({
                    source: ClientSideWebPartManager._logSource,
                    message: "All " + context.totalWebparts + " web parts requested to load, has been processed",
                    serviceScope: _this._host.serviceScope
                });
                _this._onAllWebpartsAdded(context);
            }, function () { return _this._onAllWebpartsAdded(context || { totalWebparts: 1 }); });
        }
        return loadWebPartPromise.then(function () {
            _this._onWebPartRendered(context, _PerformanceLogger.now());
            return Promise.resolve();
        }, function (error) {
            _this._onWebPartRendered(context, _PerformanceLogger.now());
            return Promise.reject(error);
        });
    };
    /**
     * Set a IPropertyPaneConsumer object into the set of the Client-side Web Part Manager's
     * managed web parts.
     *
     * @param id - A unique instance id.
     * @param control - A component which wants to use the property Pane.
     *
     * @internal
     */
    ClientSideWebPartManager.prototype.setPropertyPaneConsumer = function (id, control) {
        Validate.isNonemptyString(id, 'id');
        Validate.isNotNullOrUndefined(control, 'control');
        this._webparts.set(id, control);
        this._registerWebPartAsPropertyPaneConsumer(id);
    };
    /**
     * Fetch web part manifests. This makes a REST call to load the current site's web parts into the module loader.
     */
    ClientSideWebPartManager.prototype.fetchWebPartManifests = function () {
        var _this = this;
        if (!this._toolboxManifestsPromise && (
        // If the webServerRelativeUrl is missing we don't have anything to do here.
        !this._pageContext.web ||
            !this._pageContext.web.serverRelativeUrl ||
            Environment.type === EnvironmentType.Local ||
            Environment.type === EnvironmentType.Test)) {
            this._toolboxManifestsPromise = Promise.resolve();
        }
        // if web parts have already been fetched we don't have anything to do here.
        if (!this._toolboxManifestsPromise) {
            var requestCorrelationId_1;
            var qosMonitor_2 = new _QosMonitor('ClientSideWebPartManager.FetchWebParts');
            var requestUrl_1 = UrlUtilities.removeEndSlash(this._pageContext.web.serverRelativeUrl) + "/_api/web/GetClientSideWebParts";
            this._host.serviceScope.whenFinished(function () {
                var httpClient = _this._host.serviceScope.consume(SPHttpClient.serviceKey);
                _this._toolboxManifestsPromise = (!KillSwitches.cacheWebPartManifestFetchKSActive() ?
                    _this._fetchManifestsWithCache(httpClient, requestUrl_1) :
                    httpClient.get(requestUrl_1, SPHttpClient.configurations.v1)).then(function (response) {
                    requestCorrelationId_1 = response.correlationId ? response.correlationId.toString() : undefined;
                    if (response.ok) {
                        if (!KillSwitches.cacheWebPartManifestFetchKSActive()) {
                            // .json() is only able to be called once on a response object, cache it
                            return response.jsonCached || (response.jsonCached = Promise.resolve(response.json()));
                        }
                        else {
                            return response.json();
                        }
                    }
                    else {
                        throw SPWebPartError.create(SPWebPartErrorCode.ManifestDownloadFailed);
                    }
                })
                    .then(function (value) {
                    var manifests = value.value.map(function (manifestObject) { return JSON.parse(manifestObject.Manifest); });
                    _this._disambiguateWebPartManifestLocales(manifests);
                    SPComponentLoader.registerManifests(manifests);
                    _TraceLogger.logVerboseData({
                        source: ClientSideWebPartManager._logSource,
                        message: strings.CompletedLoadingWebPartManifests,
                        serviceScope: _this._host.serviceScope
                    });
                    qosMonitor_2.writeSuccess();
                })
                    .catch(function (error) {
                    // Clear out the promise so we can try again if we enter edit mode again.
                    _this._toolboxManifestsPromise = undefined;
                    if (!KillSwitches.cacheWebPartManifestFetchKSActive()) {
                        _this._clearManifestCacheItem(requestUrl_1);
                    }
                    _TraceLogger.logErrorData({
                        source: ClientSideWebPartManager._logSource,
                        error: error,
                        serviceScope: _this._host.serviceScope
                    });
                    qosMonitor_2.writeUnexpectedFailure('Rejected', error, {
                        correlationId: requestCorrelationId_1
                    });
                    throw error;
                });
            });
        }
        return this._toolboxManifestsPromise;
    };
    /**
     * Get list of active web part manifests.
     *
     * @returns - array of manifests.
     */
    ClientSideWebPartManager.prototype.getWebPartManifests = function () {
        var manifests = SPComponentLoader._getManifestReferences();
        var result = []; /* tslint:disable-line:no-any */
        if (manifests) {
            for (var _i = 0, manifests_1 = manifests; _i < manifests_1.length; _i++) {
                var manifest = manifests_1[_i];
                if (manifest && manifest.componentType === 'WebPart') {
                    result.push(manifest); /* tslint:disable-line:no-any */
                }
            }
        }
        return result;
    };
    /**
     * Set the display mode of the specified web part. If no web part id is specified, switch mode of all web parts.
     * If the display mode passed is same as the current mode, no change is applied.
     *
     * @param displayMode - the new DisplayMode.
     * @param instanceId - instance id of the web part.
     */
    ClientSideWebPartManager.prototype.setDisplayMode = function (displayMode, instanceId) {
        this._setDisplayMode(displayMode, instanceId);
    };
    /**
     * @internalremarks Only use this API if you need to immediately call property pane APIs after switching the mode.
     * @internal
     */
    ClientSideWebPartManager.prototype._setDisplayMode = function (displayMode, instanceId) {
        var _this = this;
        this._displayMode = displayMode;
        if (this._displayMode === DisplayMode.Read) {
            this._closeIsolatedPropertyPaneIfRequired();
        }
        // We only want to indicate we have loaded, if needed, the property pane
        /* tslint:disable-next-line:no-any */
        var setDisplayModePromise = this._loadPropertyPaneModule();
        // Set the display mode for the requested or all web parts.
        this._executeForIdsOrAll(this._getArrayOrUndefined(instanceId), function (id, webPart) {
            if (webPart) {
                webPart._internalSetDisplayMode(displayMode);
            }
            else if (_this._iframedWebpartInstanceIds.has(id)) {
                Validate.isNotNullOrUndefined(_this._iframedWebPartController, 'IFramedWebPartController is undefined');
                _this._iframedWebPartController.setDisplayMode(displayMode, id);
            }
        });
        // Start the dirty bit timer if required
        this._startDirtyBitTimer(displayMode);
        return setDisplayModePromise;
    };
    /**
     * Serialize the specified web part. If no web part is specified, serialize all web parts.
     *
     * @param instanceId - instance id of the web part.
     */
    ClientSideWebPartManager.prototype.serialize = function (instanceId) {
        var _this = this;
        var sd = new Map();
        this._executeForIdsOrAll(this._getArrayOrUndefined(instanceId), function (id, webPart) {
            if (webPart) {
                sd.set(id, webPart._internalSerialize());
            }
            else if (_this._iframedWebpartInstanceIds.has(id)) {
                Validate.isNotNullOrUndefined(_this._iframedWebPartController, 'IFramedWebPartController is undefined');
                sd.set(id, _this._iframedWebPartController.serialize(id));
            }
        });
        return sd;
    };
    /**
     * Set the web part data for the specified web part.
     *
     * The setWebPartData API has 3 possible scenarios when the web part data is updated externally.
     * - Web part declares useFallbackWhenPropertiesUpdatedExternally manifest field as `true`, web part manager will
     *   trigger the default fallback logic which disposes the web part and reload it using the given context.
     * - Web part overrides `onAfterPropertiesUpdatedExternally` life cycle events, web part manager will first
     *   deserialize the web part data, then invokes the `onAfterPropertiesUpdatedExternally` event to allow web part to
     *   do their customized handling logic.
     * - If useFallbackWhenPropertiesUpdatedExternally manifest field is `false` or `undefined`, and web part does not
     *   override `onAfterPropertiesUpdatedExternally` life cycle events, web part manager will first deserialize the
     *   web part data, then invokes the `_refresh` life cycle to re-render the web part.
     *
     * @param webPartData - the new web part data.
     * @param instanceId - instance id of the web part.
     * @param shouldFallback - whether it should fallback to dispose & reload logic.
     * @returns - A promise that resolves immediately if fallback is not used, or returns the loadWebPart promise
     *  when fallback is used.
     */
    ClientSideWebPartManager.prototype.setWebPartData = function (context, instanceId, shouldFallback) {
        if (shouldFallback === void 0) { shouldFallback = false; }
        Validate.isNotNullOrUndefined(context, 'web part manager context');
        Validate.isNonemptyString(instanceId, 'web part instance id');
        var wp = this._webparts.get(instanceId);
        var webPartData = context.webPartData;
        Validate.isNotNullOrUndefined(webPartData, 'web part data');
        if (wp && webPartData) {
            if (shouldFallback) {
                this.disposeWebparts(instanceId);
                return this.loadWebPart(context);
            }
            else {
                wp._internalSetWebPartData(webPartData);
                _SPEventManager.instance.raiseEvent(this._getDataUpdatedEventName(webPartData.instanceId), {});
            }
        }
        return Promise.resolve();
    };
    /**
     * Dispose of the current webpart manager and all of the webparts it has loaded.
     */
    ClientSideWebPartManager.prototype.dispose = function () {
        this.disposeWebparts();
        var currentIdx = ClientSideWebPartManager._webPartManagerList.indexOf(this);
        if (currentIdx >= 0) {
            ClientSideWebPartManager._webPartManagerList.splice(currentIdx, 1);
        }
    };
    /**
     * Dispose the specified web part. If no web part is specified, dispose all web parts.
     *
     * @param instanceId - instance id of the web part.
     */
    ClientSideWebPartManager.prototype.disposeWebparts = function (instanceId) {
        var _this = this;
        this._executeForIdsOrAll(this._getArrayOrUndefined(instanceId), function (id, webPart) {
            if (webPart) {
                // Remove references to the web part from the manager before disposing it
                _this._deleteWebPart(id);
                // Actually dispose the web part
                executeWithoutFailing(function () { webPart._internalDispose(); }, ClientSideWebPartManager._logSource);
            }
            else if (_this._iframedWebpartInstanceIds.has(id)) {
                Validate.isNotNullOrUndefined(_this._iframedWebPartController, 'IFramedWebPartController is undefined');
                _this._iframedWebPartController.deleteWebPart(id);
            }
        });
    };
    /*
     * Get the first web part with preview image url specified. If no web parts are specified, try to get the preview
     * image from all web parts.
     *
     * @param instanceIds - instance ids of the web parts.
     */
    ClientSideWebPartManager.prototype.tryGeneratePreviewImageUrl = function (instanceIds) {
        var _this = this;
        var candidatePreviewImageUrl;
        var previewImageUrl = undefined;
        var previewFromAlias = undefined;
        var monitor = new _QosMonitor('ClientSideWebPartManager.tryGeneratePreviewImageUrl');
        this._executeForIdsOrAll(instanceIds, function (instanceId, webPart) {
            if (webPart) {
                // workaround for typescript targeting es5 only support for...of for array and string
                // also Map does not support some or every
                // @todo: Bug 222340 when switching to es6, use for...of and return after first match
                if (!previewImageUrl) {
                    var webPartThumbnail = webPart.previewImageUrl;
                    if (webPartThumbnail) {
                        previewFromAlias = webPart.context.manifest.alias;
                        if (webPartThumbnail.length < THUMBNAIL_MAX_URL_LENGTH) {
                            candidatePreviewImageUrl = webPartThumbnail;
                            // prefer non-canonical paths due to oAuth allowed end points
                            var normalizedPath = candidatePreviewImageUrl.toUpperCase();
                            /* tslint:disable-next-line:max-line-length */
                            // https://onedrive.visualstudio.com/_search?action=contents&text=authEndpoints&type=code&lp=custom-Collection&filters=ProjectFilters%7BOneDrive%20Service%7DRepositoryFilters%7Bnotify-server%7D&pageSize=25&result=DefaultCollection%2FOneDrive%20Service%2Fnotify-server%2FGBmaster%2F%2FActivity%2FOneDrive.Activity.DataAccess%2Fsrc%2FIdentity%2FSpoUserProvider.cs
                            var isSupportedByOAuth = (DOCVIZ_REGEX.test(normalizedPath)
                                || normalizedPath.indexOf('/_API/') >= 0);
                            if (isSupportedByOAuth) {
                                previewImageUrl = candidatePreviewImageUrl;
                            }
                        }
                        else {
                            var imageUrl = webPart.previewImageUrl;
                            _TraceLogger.logVerboseData({
                                source: ClientSideWebPartManager._logSource,
                                eventName: 'tryGeneratePreviewImageUrl',
                                message: previewFromAlias + " attempted preview URL of " + (imageUrl && imageUrl.length) + " chars."
                            });
                        }
                    }
                }
            }
            else if (_this._iframedWebpartInstanceIds.has(instanceId)) {
                // @todo: VSO#612911 - add support tryGeneratePreviewImageUrl for iframed webparts
                monitor.writeExpectedFailure('IframedPart');
                return undefined;
            }
        });
        var extraData = monitor && previewFromAlias
            ? { 'alias': previewFromAlias }
            : undefined;
        if (!previewImageUrl && candidatePreviewImageUrl) {
            previewImageUrl = candidatePreviewImageUrl;
            monitor.writeExpectedFailure('NonLayouts', undefined /* ex */, extraData);
        }
        if (!previewImageUrl && previewFromAlias) {
            monitor.writeUnexpectedFailure('PathTooLong', undefined /* ex */, extraData);
            // Ensure to adjust callers if changing this error message!
            throw new Error('tryGeneratePreviewImageUrl PathLengthError.');
        }
        if (!monitor.hasEnded) {
            monitor.writeSuccess(extraData);
        }
        return previewImageUrl;
    };
    /**
     * Request property pane to perform the given action.
     *
     * @param instanceId - web part instance id.
     * @param propertyPaneAction - indicates what action needs to be performed on the property pane.
     * @param renderedByWebPart - indicates whether the the property pane rendered by a web part or not.
     * @param context - pass additional context to property pane
     */
    ClientSideWebPartManager.prototype.requestPropertyPaneAction = function (instanceId, propertyPaneAction, renderedByWebPart, context /* tslint:disable-line:no-any */) {
        var _this = this;
        if (propertyPaneAction === void 0) { propertyPaneAction = 4 /* Default */; }
        if (this._iframedWebpartInstanceIds.has(instanceId)) { // Iframe controller scenario
            // Hiding the non-iframed property pane if open, before loading the iframed property pane.
            if (this._propertyPane && this._propertyPane.isOpen()) {
                this._propertyPane.requestAction(instanceId, 2 /* Close */, renderedByWebPart);
            }
            /* tslint:disable-next-line:no-any */
            this._iframedWebPartController.requestPropertyPaneAction(propertyPaneAction, instanceId);
        }
        else { // Default scenario
            // Hide the Iframed property pane before opening non-iframe scenario.
            // if no iframed property pane is present then this is a no-op.
            if (this._iframedWebPartController) {
                this._iframedWebPartController.requestPropertyPaneAction(2 /* Close */);
            }
            if (this._propertyPane) {
                this._propertyPane.requestAction(instanceId, propertyPaneAction, /* tslint:disable-line:no-any */ renderedByWebPart);
            }
            else if (propertyPaneAction === 6 /* OpenDetails */) {
                // If the properyPane is not loaded for OpenDetails Action,
                // We have to load the property pane and then execute the action.
                this._loadPropertyPaneModule(true).then(function () {
                    _this._propertyPane.requestAction(instanceId, propertyPaneAction, /* tslint:disable-line:no-any */ renderedByWebPart, context);
                });
            }
        }
    };
    /**
     * Returns true if the current property pane source is a web part and not the Canvas or any other source.
     */
    ClientSideWebPartManager.prototype.isPropertyPaneRenderedByWebPart = function () {
        return this._propertyPane && this._propertyPane.isRenderedByConsumer();
    };
    /**
     * Returns the state of the PropertyPane if it is open or not.
     */
    ClientSideWebPartManager.prototype.isPropertyPaneOpen = function () {
        return this._propertyPane && this._propertyPane.isOpen();
    };
    /**
      * Method to handle the web part delete action from the host. There is a key distinction between delete and dispose.
      * Delete implies that the web part has been deleted from the page and the web part should dispose all the server
      * side or other external resources attached to the web part. Dispose implies that an in-place navigation is
      * happening and the web part manager should delete the web part from its cache.
      *
      * @param instanceId - instance id of the webpart which is deleted.
      */
    ClientSideWebPartManager.prototype.onWebPartDelete = function (instanceId) {
        this.disposeWebparts(instanceId);
    };
    /**
     * Render an error message in the web part container div.  Also logs the error message to the IWebPartHost logger.
     */
    ClientSideWebPartManager.prototype.renderError = function (domElement, error) {
        var _this = this;
        executeWithoutFailing(function () {
            _this._statusRenderer.renderError(domElement, error);
            _TraceLogger.logErrorData({
                source: ClientSideWebPartManager._logSource,
                error: error,
                serviceScope: _this._host.serviceScope
            });
        }, ClientSideWebPartManager._logSource);
    };
    /**
     * Notify webparts that their container has resized.
     *
     * @param instanceId - if specified only notify one webpart that its container has resized
     */
    ClientSideWebPartManager.prototype.notifyWebPartContainerResize = function (instanceId) {
        var _this = this;
        this._executeForIdsOrAll(this._getArrayOrUndefined(instanceId), function (id, webPart) {
            if (webPart) {
                webPart._internalOnAfterResize();
            }
            else if (_this._iframedWebpartInstanceIds.has(id)) {
                Validate.isNotNullOrUndefined(_this._iframedWebPartController, 'IFramedWebPartController is undefined');
                _this._iframedWebPartController.notifyContainerResize(id);
            }
        });
    };
    /**
     * Used to ensure the next request for webpart manifests makes a call to the server.
     */
    ClientSideWebPartManager.prototype.clearManifestPromise = function () {
        this._toolboxManifestsPromise = undefined;
    };
    /** ------------------- PROTECTED ------------------- **/
    /**
     * Generate web part context.
     */
    ClientSideWebPartManager.prototype._getWebPartContext = function (context) {
        var webPartTag = this._createWebPartTag(context.manifest, context.instanceId);
        var sdks = this._host.getAdditionalContextProperties &&
            this._host.getAdditionalContextProperties() ||
            {};
        var microsoftTeams = sdks.microsoftTeams && sdks.microsoftTeams.teamsJs;
        var parameters = {
            sdks: sdks,
            microsoftTeams: microsoftTeams,
            parentServiceScope: context.serviceScope || this._host.serviceScope,
            manifest: this._getManifestInstance(context),
            instanceId: context.instanceId,
            webPartTag: webPartTag,
            domElement: context.domElement,
            statusRenderer: this._statusRenderer,
            isPropertyPaneRenderedByWebPart: this.isPropertyPaneRenderedByWebPart,
            isPropertyPaneOpen: this.isPropertyPaneOpen,
            formFactor: context.formFactor || 0 /* Standard */,
            host: this._host,
            requestPropertyPaneAction: this.requestPropertyPaneAction,
            loggingTag: webPartTag,
            _dataUpdatedEvent: new SPEvent(this._getDataUpdatedEventName(context.instanceId))
        };
        var webPartContext = new WebPartContext(parameters);
        return webPartContext;
    };
    /** ------------------- PRIVATE ------------------- **/
    /**
     * Loads the web part component and any dynamic dependencies.
     */
    ClientSideWebPartManager.prototype._loadWebPartModules = function (context, webPartTag, qosMonitor) {
        _TraceLogger.logVerboseData({
            source: ClientSideWebPartManager._logSource,
            message: Text.format(strings.StartedLoadingWebPart, webPartTag),
            serviceScope: this._host.serviceScope
        });
        var modulePromise = SPComponentLoader.loadComponent(context.manifest);
        var moduleLoadPromises = [];
        // Always push main module at first index.
        moduleLoadPromises.push(modulePromise);
        // Add any dynamic dependency web part has declared through metadata.
        this._loadDynamicComponentDependencies(context.webPartData, webPartTag, moduleLoadPromises);
        return Promise.all(moduleLoadPromises)
            .then(function (moduleLibraries) {
            _PerformanceLogger.devMark("ClientSideWebPartManager.loadWebPart(" + webPartTag + ").end");
            return Promise.resolve(moduleLibraries[0]);
        })
            .catch(function (error) {
            // Reject promise only if main web part promise is rejected.
            return modulePromise;
        });
    };
    ClientSideWebPartManager.prototype._fetchManifestsWithCache = function (httpClient, requestUrl) {
        if (!ClientSideWebPartManager._manifestRequestPromiseCache[requestUrl]) {
            ClientSideWebPartManager._manifestRequestPromiseCache[requestUrl]
                = httpClient.get(requestUrl, SPHttpClient.configurations.v1);
        }
        return ClientSideWebPartManager._manifestRequestPromiseCache[requestUrl];
    };
    ClientSideWebPartManager.prototype._clearManifestCacheItem = function (requestUrl) {
        delete ClientSideWebPartManager._manifestRequestPromiseCache[requestUrl];
    };
    /**
     * Invoked whenever a web part is rendered including situations where any errors have occurred
     */
    ClientSideWebPartManager.prototype._onWebPartRendered = function (context, renderEndTime) {
        this._webPartRenderedCount++;
        var trackingCallback = !!(Environment.type !== EnvironmentType.ClassicSharePoint && context.totalWebparts);
        if (this._isObserverEnabled && trackingCallback) {
            this._onAllWebpartsAdded(context);
        }
        if (context.onAllWebPartsRendered) {
            var lastPartRendered = context.totalWebparts === this._webPartRenderedCount;
            // We do not support classic pages for this feature
            if (trackingCallback && lastPartRendered) {
                window.setTimeout(function () { return context.onAllWebPartsRendered(renderEndTime); }, 0);
            }
        }
    };
    /**
     * Workaround for a server issue - disambiguate manifest locales if they haven't already been disambiguated
     * (VSO#243888) tracks fixing this issue.
     */
    ClientSideWebPartManager.prototype._disambiguateWebPartManifestLocales = function (manifests) {
        // Attempt to disambiguate locale for each manifest if the server didn't already do that
        var currentLocale = this._pageContext.cultureInfo.currentUICultureName
            ? this._pageContext.cultureInfo.currentUICultureName.toLowerCase()
            : undefined;
        if (currentLocale) {
            // This should only get called once, so it doesn't need to be a private function.
            var disambiguateLocale_1 = function (values) {
                var foundMatch = undefined;
                for (var locale in values) {
                    if (locale && locale.toLowerCase() === currentLocale && values[locale]) {
                        foundMatch = values[locale];
                        break;
                    }
                }
                return {
                    default: foundMatch || values.default
                };
            };
            manifests.forEach(function (manifest) {
                if (manifest.componentType === 'WebPart') {
                    var wpManifest = manifest;
                    wpManifest.preconfiguredEntries.forEach(function (entry) {
                        entry.title = disambiguateLocale_1(entry.title);
                        entry.description = disambiguateLocale_1(entry.description);
                        if (entry.group) {
                            entry.group = disambiguateLocale_1(entry.group);
                        }
                    });
                }
            });
        }
    };
    /**
     * Validate and process input parameters.
     */
    ClientSideWebPartManager.prototype._validateInput = function (context) {
        Validate.isNotNullOrUndefined(context, 'web part manager context');
        Validate.isNotNullOrUndefined(context.domElement, 'web part element');
        Validate.isNotNullOrUndefined(context.instanceId, 'web part instanceId');
        Validate.isNotNullOrUndefined(context.manifest, 'web part manifest');
        Validate.isTrue(!this._webparts.get(context.instanceId), "Duplicate web part instanceId is not allowed: " + context.instanceId);
    };
    /**
     * Validate the web part manifest.
     */
    ClientSideWebPartManager.prototype._validateManifest = function (manifest, /* tslint:disable-line:no-any */ mode, webPartTag) {
        // If the manifest is null, then
        //    In read mode, we throw as the host should never attempt to load the webpart without the manifest.
        //    In edit mode, we should display an error
        if (!manifest) {
            if (mode === DisplayMode.Read) {
                throw SPWebPartError.create(SPWebPartErrorCode.ManifestNull, webPartTag);
            }
            else {
                return false;
            }
        }
        // Clone the manifest and then validate the clone. This way we make sure there are no functions and other
        // non-field based types in the manifest.
        /* tslint:disable-next-line:no-any */
        var cm = lodash.cloneDeep(manifest);
        /* tslint:disable-next-line:triple-equals */
        Validate.isTrue(cm.manifestVersion == 2, 'Only version 2 manifests are currently supported');
        Validate.isTrue(!!cm.id, 'web part id cannot be null or undefined');
        Validate.isNotNullOrUndefined(Guid.tryParse(cm.id), 'web part id has to be a GUID');
        Validate.isTrue(!!cm.version, 'webp art version cannot be null or undefined');
        return true;
    };
    /**
     * Execute the provided callback for the list of provided web part ids. If no list if provided,
     * execute the callback on all web parts.
     */
    ClientSideWebPartManager.prototype._executeForIdsOrAll = function (instanceIds, callback) {
        var _this = this;
        if (instanceIds) {
            instanceIds.forEach(function (instanceId) {
                var webPart = _this._webparts.get(instanceId);
                callback(instanceId, webPart);
            });
        }
        else {
            this._webparts.forEach(function (webPart, instanceId) {
                // Check the type because the dictionary can have web parts or property pane controls
                if (ClientSideWebPartManager._instanceOfBase(webPart)) {
                    callback(instanceId, webPart);
                }
            });
            if (this._iframedWebPartController) {
                this._iframedWebPartController.getAllInstanceIds().forEach(function (instanceId) {
                    callback(instanceId);
                });
            }
        }
    };
    Object.defineProperty(ClientSideWebPartManager.prototype, "_isObserverEnabled", {
        get: function () {
            if (KillSwitches.isIE11IntersectionObserverBugFixEnabled()) {
                return this._deprecatedIsObserverEnabled;
            }
            else {
                return this._viewportLoader
                    ? this._viewportLoader.optimizeViewportLoader()
                    : ViewportLoader.optimizeViewportLoader();
            }
        },
        enumerable: true,
        configurable: true
    });
    ClientSideWebPartManager.prototype._getLoadedModuleList = function (moduleLibrary) {
        var loadedModulesString = '';
        for (var m in moduleLibrary) {
            if (moduleLibrary.hasOwnProperty(m)) {
                if (loadedModulesString) {
                    loadedModulesString += ',';
                }
                loadedModulesString += "" + m;
            }
        }
        return loadedModulesString;
    };
    /**
     * This is a temporary implementation of updating the host that a web part has updated properties.
     * Currently we run a timer that regularly checks for updated properties and raises the dirty bit
     * handler to the host. todo (VSO SPPPLAT#200728) tracks fixing this scenario in a better way.
     */
    ClientSideWebPartManager.prototype._startDirtyBitTimer = function (mode) {
        var _this = this;
        // Clear the timer in read mode
        if (mode === DisplayMode.Read) {
            // Do not clear the dirty bit timer in classic pages as there are editable and non-editable
            // web parts on the page simultaneously. Note, only one web part can be truly editable at
            // any give time.
            if (this._dirtyBitTimer && Environment.type !== EnvironmentType.ClassicSharePoint) {
                window.clearInterval(this._dirtyBitTimer);
                this._dirtyBitTimer = undefined;
            }
            // If required start the timer in edit mode
        }
        else if (!this._dirtyBitTimer) {
            this._dirtyBitTimer = window.setInterval(function () {
                _this._executeForIdsOrAll(undefined, function (_instanceId, wp) {
                    if (wp) {
                        wp._internalSetDirtyBit();
                    }
                    else if (_this._iframedWebpartInstanceIds.has(_instanceId)) {
                        _this._iframedWebPartController.startDirtyBitTimer(_instanceId);
                    }
                });
            }, 1000);
        }
    };
    /**
     * Creates a new extra data object for writing unexpected failures to QosMonitor.
     */
    ClientSideWebPartManager.prototype._createUnexpectedFailureExtraData = function (alias, instanceId, isInternal, manifestId) {
        var unexpectedFailureExtraData = {
            alias: alias,
            instanceId: instanceId,
            isInternal: isInternal,
            manifestId: manifestId
        };
        return unexpectedFailureExtraData;
    };
    /**
     * Creates a new QosMonitor with a scenario name specific to the web part type.
     */
    ClientSideWebPartManager.prototype._createLoadQosMonitor = function () {
        // Do NOT change this format without updating BingDat/Alerters first or escalations will ensue!!!
        return new _QosMonitor("WebPart.Load", true);
    };
    /**
     * Create the web part tag. Web part tag is a unique tag per web part instance and is used for logging and telemetry.
     */
    /* tslint:disable-next-line:no-any */
    ClientSideWebPartManager.prototype._createWebPartTag = function (manifest, instanceId) {
        return "WebPart." + manifest.alias + "." + (manifest.isInternal ? 'internal' : 'external') + "." + instanceId;
    };
    ClientSideWebPartManager.prototype._deleteWebPart = function (id) {
        Validate.isNotNullOrUndefined(id, 'id');
        // Since the property pane is defer loaded, check if it exists/loaded before
        // using it.
        if (this._propertyPane) {
            this._propertyPane.onConsumerDelete(id);
        }
        var wp = this._webparts.get(id);
        if (wp && ClientSideWebPartManager._instanceOfBase(wp)) {
            _TraceLogger.logVerboseData({
                source: ClientSideWebPartManager._logSource,
                message: Text.format(strings.WebpartDeleteRequested, ClientSideWebPartManager._getWebPartTag(wp)),
                serviceScope: this._host.serviceScope
            });
            this._loadWebPartRequests--;
            this._webPartRenderedCount--;
            if (this._loadWebPartRequests < 0) {
                _TraceLogger.logErrorData({
                    source: ClientSideWebPartManager._logSource,
                    error: new Error(strings.UnexpectedLoadRequestNegativeCount),
                    serviceScope: this._host.serviceScope
                });
            }
        }
        this._webparts.delete(id);
    };
    /**
     * Get web part manifest instance from manifest. Promotes the pre-configured entries.
     */
    /* tslint:disable:no-any */
    ClientSideWebPartManager.prototype._getManifestInstance = function (context) {
        var manifest = context.manifest;
        var manifestClone = lodash.cloneDeep(manifest);
        delete manifestClone.preconfiguredEntries;
        return manifestClone;
    };
    /* tslint:enable:no-any */
    /**
     * If non-non parameter passed, return array else return undefined.
     */
    ClientSideWebPartManager.prototype._getArrayOrUndefined = function (instanceId) {
        return instanceId ? [instanceId] : undefined;
    };
    ClientSideWebPartManager.prototype._initialzeOnResizeEventHandler = function () {
        window.addEventListener('resize', lodash.debounce(this._onContainerResize, 1000));
        window.addEventListener('message', this._onPropertyPaneNotifications);
    };
    /**
     * Window onresize event handler.
     */
    ClientSideWebPartManager.prototype._onContainerResize = function () {
        ClientSideWebPartManager._webPartManagerList.forEach(function (wpm) {
            wpm._webparts.forEach(function (wp) { wp._internalOnAfterResize(); });
        });
    };
    /**
     * Listener for window post message that the property pane.
     *
     * todo (SPPPLAT Bug #299413): Implement missing schema for property pane post messages
     * todo (SPPPLAT PBI #687467): Refactor IframedWebPartContoller
     */
    ClientSideWebPartManager.prototype._onPropertyPaneNotifications = function (event) {
        if (event && event.origin === window.location.origin) {
            switch (event.data) {
                case 'Property pane will open':
                    this._closeIsolatedPropertyPaneIfRequired();
                    break;
                case 'Property pane toggled':
                    this._onContainerResize();
                    break;
            }
        }
    };
    /**
     * When all web parts added, check if in viewport web parts are rendered
     * If so then notify viewport loader to load rest of the web parts gradually.
     */
    ClientSideWebPartManager.prototype._onAllWebpartsAdded = function (context, startTime) {
        var _this = this;
        if (this._isViewportRendered) {
            return;
        }
        // After 2 seconds let's timeout. If one bad web part is stuck for some reason, let it not
        // block rendering rest of the web parts on the page. 2 Second is good enough time given
        // for normal scenarios.
        var timeout = 2000;
        var endTime = this._getViewportRenderedEndTime();
        if (endTime || (startTime && (_PerformanceLogger.now() - startTime) > timeout)) {
            this._isViewportRendered = true;
            var qosViewportLoad = new _QosMonitor("Viewport.Load", true);
            if (endTime === undefined) {
                qosViewportLoad.writeExpectedFailure('Timed out waiting viewport web parts');
                endTime = _PerformanceLogger.now();
            }
            else {
                qosViewportLoad.writeSuccess();
            }
            // Finish pending work in async manner so thread is freed for pending tasks.
            window.setTimeout(function () { _this._onViewportWebpartsLoaded(context, endTime); }, 0);
        }
        else if (!this._isObserverEnabled) {
            // Let's check again if rendering is completed
            window.setTimeout(function () { return _this._onAllWebpartsAdded(context, startTime ? startTime : _PerformanceLogger.now()); }, 100);
        }
    };
    ClientSideWebPartManager.prototype._onViewportWebpartsLoaded = function (context, endTime) {
        Validate.isNotNullOrUndefined(endTime, 'endTime');
        if (Environment.type !== EnvironmentType.ClassicSharePoint) {
            // All web parts in the view port has rendered, now add those finally in the viewport.
            this._registerWebpartsInViewport();
            _TraceLogger.logVerboseData({
                source: ClientSideWebPartManager._logSource,
                message: 'All Web parts in the viewports are rendered at ' + endTime,
                serviceScope: this._host.serviceScope
            });
        }
        // Let Canvas Renderer know that all viewport web parts are loaded
        if (context.onViewportWebPartsRendered) {
            context.onViewportWebPartsRendered(endTime);
        }
        if (context.totalWebparts || Environment.type === EnvironmentType.ClassicSharePoint) {
            if (this._viewportLoader) {
                this._viewportLoader.loadOutsideViewport();
            }
            else {
                ViewportLoader.deprecatedInstance.loadOutsideViewPort();
            }
        }
    };
    // TODO: Remove function along with graduation of flight WEXOptimizeViewportLoader
    ClientSideWebPartManager.prototype._getViewportRenderedEndTimeLegacy = function () {
        var _this = this;
        var isAllInViewportRendered = true;
        var endTime = undefined;
        var noWebPartInInitialViewport = true;
        this._webparts.forEach(function (wp) {
            var viewPortWebPart = wp;
            var webpartTag = ClientSideWebPartManager._getWebPartTag(wp);
            if (ClientSideWebPartManager._instanceOfBase(wp)
                && (!KillSwitches.ensureWebPartTag() || webpartTag)
                && !_PerformanceLogger.shouldSkipComponent(webpartTag)
                && ViewportLoaderUtility.isInInitialViewport(wp, _this._isObserverEnabled)) {
                noWebPartInInitialViewport = false;
                isAllInViewportRendered = isAllInViewportRendered ? viewPortWebPart._renderedOnce : isAllInViewportRendered;
                if (isAllInViewportRendered) { // Optimization check
                    var curEndTime = _PerformanceLogger.getComponentEndTime(webpartTag);
                    if (curEndTime && (!endTime || curEndTime > endTime)) {
                        endTime = curEndTime;
                    }
                }
            }
        });
        if (noWebPartInInitialViewport) {
            return _PerformanceLogger.now();
        }
        else {
            return isAllInViewportRendered ? endTime : undefined;
        }
    };
    /**
     * Return endtime of last rended web part if all web parts in the view port has rendered for current web part
     * manager instance, undefined otherwise.
     * Always remember hosting app can have multiple CSWPM instance.
     */
    ClientSideWebPartManager.prototype._getViewportRenderedEndTime = function () {
        if (!this._isObserverEnabled) {
            return this._getViewportRenderedEndTimeLegacy();
        }
        var endTime = undefined;
        var breakLoop = false;
        this._webparts.forEach(function (wp) {
            var viewPortWebPart = wp;
            var webpartTag = ClientSideWebPartManager._getWebPartTag(wp);
            if (!breakLoop &&
                ClientSideWebPartManager._instanceOfBase(wp) &&
                (!KillSwitches.ensureWebPartTag() || webpartTag) &&
                !_PerformanceLogger.shouldSkipComponent(webpartTag)) {
                if (!viewPortWebPart._renderedOnce && viewPortWebPart._registeredInViewport) {
                    endTime = undefined;
                    breakLoop = true;
                }
                else if (viewPortWebPart._renderedOnce && viewPortWebPart._registeredInViewport) {
                    var curEndTime = _PerformanceLogger.getComponentEndTime(webpartTag);
                    if (curEndTime && (!endTime || curEndTime > endTime)) {
                        endTime = curEndTime;
                    }
                }
            }
        });
        return endTime;
    };
    /**
     * Add all web parts in the viewport to the EUPL calculation
     */
    ClientSideWebPartManager.prototype._registerWebpartsInViewport = function () {
        var _this = this;
        var externalWebpartsInViewport = 0; // Total external web parts in viewport.
        var internalWebpartsInViewport = 0; // Total internal web parts in viewport.
        var totalInternalWebParts = 0; // Total number of internal web parts in canvas.
        var totalExternalWebParts = 0; // Total number of external web parts in canvas.
        this._webparts.forEach(function (wp) {
            var viewPortWebPart = wp;
            if (ClientSideWebPartManager._instanceOfBase(wp)) {
                var isInternal = (wp.context && wp.context.manifest).isInternal;
                isInternal ? totalInternalWebParts++ : totalExternalWebParts++;
                if (ViewportLoaderUtility.isInInitialViewport(viewPortWebPart, _this._isObserverEnabled)) {
                    var webpartTag = ClientSideWebPartManager._getWebPartTag(wp);
                    if (!KillSwitches.ensureWebPartTag() || webpartTag) {
                        // Add web parts to EUPL if it is in the initial viewport
                        _PerformanceLogger.addComponent(webpartTag);
                    }
                    isInternal ? internalWebpartsInViewport++ : externalWebpartsInViewport++;
                    _TraceLogger.logVerboseData({
                        source: ClientSideWebPartManager._logSource,
                        message: "Web part " + webpartTag + " is added into EUPL calculation.",
                        serviceScope: _this._host.serviceScope
                    });
                }
            }
        });
    };
    /**
   * Converts Module library into Internal Web part object.
   * Throws Exception if unexpectd found
   */
    /* tslint:disable-next-line:no-any */
    ClientSideWebPartManager.prototype._instantiateWebPart = function (moduleLibrary, webPartTag) {
        var wp = moduleLibrary; /* tslint:disable-line:no-any */
        // The following code supports both types of web part modules. Those that are
        // exported as defaults in the webpart code. And those that are not exported
        // as defaults. i.e. This code helps support the case when there are multiple
        // web parts in a single bundle. !!!WARNING!!!  Changing this code without
        // careful vetting can cause serious regressions.
        // If the web part has a default export, use that.
        if (wp && wp.default) {
            wp = wp.default;
        }
        // Web part module not found. Stop any further processing.
        if (!wp) {
            throw SPWebPartError.create(SPWebPartErrorCode.ModuleNotLoaded, webPartTag, this._getLoadedModuleList(moduleLibrary));
        }
        // Try to go one more level deep if required.
        if (typeof (wp) !== 'function' && wp.default) {
            wp = wp.default;
        }
        // Stop any further processing if the type of the module is not correct.
        if (typeof (wp) !== 'function') {
            throw SPWebPartError.createWithLogProperties(SPWebPartErrorCode.IncorrectBoostrapModule, { actualType: typeof (wp), wp: wp }, webPartTag);
        }
        var webPartInstace = new wp();
        if (!webPartInstace._internalInitialize) {
            throw SPWebPartError.createWithLogProperties(SPWebPartErrorCode.MissingExpectedWebPartMemberError, { actualType: typeof (wp), wp: wp }, webPartTag, '_internalInitialize');
        }
        return webPartInstace;
    };
    /**
     * Handle when exception occurred loading web part
     */
    ClientSideWebPartManager.prototype._handleErrorLoadingWebpart = function (manifest, /* tslint:disable-line:no-any */ instanceId, domElement, ex, qosMonitor) {
        var _this = this;
        var wp = this._webparts.get(instanceId);
        if (wp) {
            executeWithoutFailing(function () { _this._statusRenderer.clearLoadingIndicator(domElement); }, ClientSideWebPartManager._logSource);
            executeWithoutFailing(function () { wp._internalDispose(); }, ClientSideWebPartManager._logSource);
            executeWithoutFailing(function () { _this._webparts.delete(instanceId); }, ClientSideWebPartManager._logSource);
        }
        executeWithoutFailing(function () {
            var extraData = _this._createUnexpectedFailureExtraData(manifest.alias, instanceId, manifest.isInternal, manifest.id);
            qosMonitor.writeUnexpectedFailure('UnhandledLoadError', ex, extraData);
        }, ClientSideWebPartManager._logSource);
        this.renderError(domElement, ex);
    };
    /**
     * handle when Module Promise is rejected
     */
    ClientSideWebPartManager.prototype._handleModulePromiseRejection = function (manifest, /* tslint:disable-line:no-any */ instanceId, domElement, webPartTag, error, qosMonitor) {
        var _this = this;
        executeWithoutFailing(function () {
            var extraData = _this._createUnexpectedFailureExtraData(manifest.alias, instanceId, manifest.isInternal, manifest.id);
            qosMonitor.writeUnexpectedFailure('ScriptLoad', error, extraData);
        }, ClientSideWebPartManager._logSource);
        this.renderError(domElement, error);
    };
    ClientSideWebPartManager.prototype._onFirstTimeWebpartRender = function (manifest, /* tslint:disable-line:no-any */ webPartTag, qosMonitor, context) {
        var inViewport;
        if (KillSwitches.collectInViewportData()) {
            var webpart = this._webparts.get(context.instanceId);
            inViewport = webpart && webpart._registeredInViewport;
        }
        WebPartLoadDataCollector.collect(manifest, webPartTag, qosMonitor, this._pageContext, inViewport);
        ClassicPageUtils.removeFabricLinks();
        _TraceLogger.logVerboseData({
            source: ClientSideWebPartManager._logSource,
            message: Text.format(strings.ModulesLoadedForWebPart, webPartTag),
            serviceScope: this._host.serviceScope
        });
        if (!KillSwitches.isLogWebPartLoadRenderDoneKillSwitchActivated()) {
            _EngagementLogger.logEventWithLogEntry(new _LogEntry('ClientSideWebPartManager', 'RenderDone', _LogType.Event, {
                alias: this._createWebPartTag(context.manifest, context.manifest.id),
                displayMode: String(context.displayMode)
            }));
        }
    };
    ClientSideWebPartManager.prototype._getDataUpdatedEventName = function (webPartInstanceId) {
        return "WebPart_" + webPartInstanceId + "_dataUpdated";
    };
    ClientSideWebPartManager.prototype._initializeWebPart = function (options) {
        var context = options.context, moduleLibrary = options.moduleLibrary, webPartTag = options.webPartTag, qosMonitor = options.qosMonitor;
        try {
            _PerformanceLogger.markComponentModuleLoaded(webPartTag);
            _TraceLogger.logVerboseData({
                source: ClientSideWebPartManager._logSource,
                message: Text.format(strings.ModulesLoadedForWebPart, webPartTag),
                serviceScope: this._host.serviceScope
            });
            if (!moduleLibrary) {
                throw SPWebPartError.create(SPWebPartErrorCode.ModuleUndefined, webPartTag);
            }
            var wp = this._instantiateWebPart(moduleLibrary, webPartTag);
            // Actually initialize the web part.
            wp._internalInitialize(this._getWebPartContext(context), 
            // Tell the Web Part it will need to reinstate some properties from server processed content.
            !!context.addedFromPersistedData, context.displayMode);
            // Make sure the web part object is of the correct type.
            if (!ClientSideWebPartManager._instanceOfBase(wp)) {
                throw SPWebPartError.create(SPWebPartErrorCode.NonBaseWebPart, webPartTag);
            }
            this._webparts.set(context.instanceId, wp);
            this._registerWebPartAsPropertyPaneConsumer(context.instanceId);
            // Start the dirty bit timer if required.
            this._startDirtyBitTimer(context.displayMode);
            // VSO#302772 Properly clone web part data
            var webPartData = lodash.cloneDeep(context.webPartData);
            if (webPartData) {
                // Deserialize the web part data
                wp._internalDeserialize(webPartData);
            }
        }
        catch (error) {
            this._handleErrorLoadingWebpart(context.manifest, context.instanceId, context.domElement, error, qosMonitor);
            throw error;
        }
    };
    ClientSideWebPartManager.prototype._handleRenderComplete = function (webPartTag, manifest, /* tslint:disable-line:no-any */ qosMonitor, context, resolve) {
        // By this time assumption is web part has rendered something meaningful to the end user.
        // Web parts rendering with async resources are responsible to report this timing correctly by
        // overriding isRenderAsync to true.
        _PerformanceLogger.endMarkForComponent(webPartTag);
        // Perform post render operation e.g. log telemetry data.
        this._onFirstTimeWebpartRender(manifest, webPartTag, qosMonitor, context);
        // Web part rendering completed successfully, resolve the promise.
        resolve();
    };
    ClientSideWebPartManager.prototype._renderWebPart = function (options) {
        var _this = this;
        var context = options.context, webPartTag = options.webPartTag, qosMonitor = options.qosMonitor, instanceRequestCount = options.instanceRequestCount;
        try {
            // Initialization step always occurs before render and initialization sets the
            // webpart into the '_webparts' map, thus we know it will always exist.
            var wp_1 = this._webparts.get(context.instanceId);
            // Each module loads styles in async mode by default, which is good for performance.
            // In Async mode it gets loaded in batch rather on each call for loadStyles
            // At this time we want to ensure that if any loadStyles request is in buffer is flushed
            // before component starts rendering.
            loadThemedStyles.flush();
            return this._loadPropertyPaneModule().then(function () {
                // internal render will write out specific failures
                var webpartFirstRenderPromise = wp_1._internalFirstTimeRender(
                // Passing scrollableParent as a perf optimization to avoiding discovering again.
                context.scrollableParent, qosMonitor);
                if (Environment.type === EnvironmentType.ClassicSharePoint &&
                    ViewportLoaderUtility.isInInitialViewport(wp_1, _this._isObserverEnabled)) {
                    // Add web parts to EUPL as it is in the initial viewport
                    // Always add for classic pages, otherwise RUMOneLogger will finish fast
                    _PerformanceLogger.addComponent(webPartTag);
                    _TraceLogger.logVerboseData({
                        source: ClientSideWebPartManager._logSource,
                        message: "Web part " + webPartTag + " is added into EUPL calculation.",
                        serviceScope: _this._host.serviceScope
                    });
                }
                if (instanceRequestCount === 1 &&
                    Environment.type === EnvironmentType.ClassicSharePoint &&
                    !_this._host.isViewportLoadingDisabled) {
                    // Handle Classic page case here. In Classic page eath web part loads individually.
                    // So there is no advance knowledge of how many web parts to load. We start early to check.
                    _this._onAllWebpartsAdded(context);
                }
                return webpartFirstRenderPromise;
            }).catch(function (error) { throw error; });
        }
        catch (ex) {
            this._handleErrorLoadingWebpart(context.manifest, context.instanceId, context.domElement, ex, qosMonitor);
            return Promise.reject(ex);
        }
    };
    /**
     * Load all valid dynamic dependencies and adds into moduleLoadPromises param.
     *
     * This is the core of dynamic dependency web part has provided through metadata. Framework ensures that the such
     * dependency is loaded for the web part before it starts rendering. Ideally this component's js bundle should be
     * already downloaded by server script preloading feature for first few web parts in viewport.
     */
    ClientSideWebPartManager.prototype._loadDynamicComponentDependencies = function (webPartData, webPartTag, moduleLoadPromises) {
        if (webPartData
            && webPartData.serverProcessedContent
            && webPartData.serverProcessedContent.componentDependencies) {
            var componentDependencies = webPartData.serverProcessedContent.componentDependencies;
            if (componentDependencies) {
                for (var compDependency in componentDependencies) {
                    if (compDependency && componentDependencies[compDependency]) {
                        var componentId = componentDependencies[compDependency];
                        if (!Guid.tryParse(componentId)) {
                            var error = new Error("Web part (" + webPartTag + ") dynamic dependency " + componentId + " is not a valid guid");
                            _TraceLogger.logErrorData({
                                source: ClientSideWebPartManager._logSource,
                                error: error,
                                serviceScope: this._host.serviceScope
                            });
                        }
                        else {
                            moduleLoadPromises.push(SPComponentLoader.loadComponentById(componentId));
                            _TraceLogger.logVerboseData({
                                source: ClientSideWebPartManager._logSource,
                                message: "Web part (" + webPartTag + ") loading dynamic dependency " + componentId + " started.",
                                serviceScope: this._host.serviceScope
                            });
                        }
                    }
                }
            }
        }
    };
    /**
     * Registers a component as a property pane consumer.
     * @param instanceId - Instance id of the consumer, to be registered with the property pane.
     */
    ClientSideWebPartManager.prototype._registerWebPartAsPropertyPaneConsumer = function (instanceId) {
        if (instanceId) {
            var wp = undefined;
            for (var _i = 0, _a = ClientSideWebPartManager._webPartManagerList; _i < _a.length; _i++) {
                var manager = _a[_i];
                wp = manager._webparts.get(instanceId);
                if (wp) {
                    if (this._propertyPane) {
                        this._propertyPane.registerConsumer(instanceId, wp);
                    }
                    else {
                        this._propertyPaneConsumerQueue.set(instanceId, wp);
                    }
                    break;
                }
            }
        }
    };
    /**
     * Creates an absolute url with the isolatedDomain parameter.
     * @param isolatedDomain - a domain without the protocol. Ex: "PrepSPO-appFEEAB5CE1CB0421FB1AAE5D09E0A8AAA.spgrid.com"
     * @param absoluteUrl - url with protocol that may or may not contain a path. Ex: "https://prepspo.spgrid.com"
     */
    ClientSideWebPartManager.prototype._ensureUrl = function (isolatedDomain, absoluteUrl) {
        if (!isolatedDomain) {
            return absoluteUrl;
        }
        // replace the domain in "https://domain/path" with isolatedDomain
        var slashAdded = false;
        if (absoluteUrl.charAt(absoluteUrl.length - 1) !== '/') {
            absoluteUrl = absoluteUrl + '/';
            slashAdded = true;
        }
        absoluteUrl = absoluteUrl.replace(ClientSideWebPartManager._domainRegex, "https://" + isolatedDomain + "/");
        if (slashAdded) {
            // Remove the ending slash
            absoluteUrl = absoluteUrl.substr(0, absoluteUrl.length - 1);
        }
        return absoluteUrl;
    };
    /**
     * Loads the property pane module asynchronously, if not already loaded.
     */
    ClientSideWebPartManager.prototype._loadPropertyPaneModule = function (renderDetailsPane) {
        var _this = this;
        if ((this._displayMode === DisplayMode.Edit || renderDetailsPane ||
            // Classic pages behave differently, page and web part can be in different modes
            // hence tackling it in a different way. This is to fix a sev 1 so keeping the changes minimal.
            // We might revisit the logic in future, as required.
            Environment.type === EnvironmentType.ClassicSharePoint) &&
            !this._propertyPane) {
            var propertyPaneQosMonitor_1 = new _QosMonitor('ClientSideWebPartManager._loadPropertyPaneModule');
            this._propertyPaneLoader = this._host.serviceScope.consume(PropertyPaneLoader.serviceKey);
            return this._propertyPaneLoader.propertyPane
                .then(function (propertyPane) {
                _this._propertyPane = propertyPane;
                _this._registerPendingPropertyPaneConsumers();
                return propertyPane;
            })
                .catch(function (error) {
                _TraceLogger.logErrorData({
                    source: ClientSideWebPartManager._logSource,
                    error: error
                });
                propertyPaneQosMonitor_1.writeUnexpectedFailure('UnhandledError', error);
                throw error;
            });
        }
        else {
            return Promise.resolve(undefined);
        }
    };
    ClientSideWebPartManager.prototype._registerPendingPropertyPaneConsumers = function () {
        var _this = this;
        this._propertyPaneConsumerQueue.forEach(function (consumer, instanceId) {
            _this._propertyPane.registerConsumer(instanceId, consumer);
        });
    };
    ClientSideWebPartManager.prototype._closeIsolatedPropertyPaneIfRequired = function () {
        ClientSideWebPartManager._webPartManagerList.forEach(function (cswpm) {
            if (cswpm._iframedWebPartController) {
                cswpm._iframedWebPartController.requestPropertyPaneAction(2 /* Close */);
            }
        });
    };
    /**
     * Load the fabric core library, for third-party web parts if required.
     * @param context - Current context of the web part manager
     * @param qosMonitor - qos monitor for the current flow
     */
    ClientSideWebPartManager.prototype._loadLegacyFabricCssIfRequired = function (context, qosMonitor) {
        var _this = this;
        var manifest = context.manifest;
        if (!_ComponentBaseKillSwitches.isAddSpecificityToLegacyWebPartKSActivated()) {
            // We will add the classname for all 3rd party web parts, as many of 3rd party devs use the css not as
            // documentation required.
            if (_LegacyThirdPartyFabricCoreLoader.needLegacyFabricCss(manifest) || !manifest.isInternal) {
                context.domElement.classList.add('ms-SPLegacyFabricBlock');
            }
        }
        if (!_ComponentBaseKillSwitches.isStopLoadingLegacyFabricCSSKillSwitchActivated()) {
            /* tslint:disable-next-line:no-any */
            return _LegacyThirdPartyFabricCoreLoader.forceLoad(manifest)
                .then(function () { return Promise.resolve(); })
                .catch(function (error) {
                _TraceLogger.logErrorData({
                    source: ClientSideWebPartManager._logSource,
                    error: error,
                    serviceScope: _this._host.serviceScope
                });
                qosMonitor.writeUnexpectedFailure('Error loading legacy-third-party-fabric-core.', error);
                Promise.reject(error);
            });
        }
        else {
            return _LegacyThirdPartyFabricCoreLoader.load(context.manifest.isInternal)
                .then(function () { return Promise.resolve(); })
                .catch(function (error) {
                _TraceLogger.logErrorData({
                    source: ClientSideWebPartManager._logSource,
                    error: error,
                    serviceScope: _this._host.serviceScope
                });
                qosMonitor.writeUnexpectedFailure('Error loading legacy-third-party-fabric-core.', error);
                Promise.reject(error);
            });
        }
    };
    /**
     * Reference to the instances of all ClientSideWebPartManager instances in the app.
     */
    ClientSideWebPartManager._webPartManagerList = [];
    ClientSideWebPartManager._domainRegex = new RegExp('^https://[^/]*/');
    /*
     * Web part manager log source
     */
    ClientSideWebPartManager._logSource = _LogSource.create('ClientSideWebPartManager');
    ClientSideWebPartManager._manifestRequestPromiseCache = {};
    return ClientSideWebPartManager;
}());
export default ClientSideWebPartManager;
//# sourceMappingURL=ClientSideWebPartManager.js.map