import { DisplayMode } from '@microsoft/sp-core-library';
import { IClientSideWebPartManifest } from '@microsoft/sp-module-interfaces';
import { IPropertyPaneConsumer, PropertyPaneAction } from '@microsoft/sp-property-pane';
import IWebPartData from './IWebPartData';
import IWebPartHost from '../components/host/IWebPartHost';
import IWebPartManagerContext from './IWebPartManagerContext';
import WebPartContext from './WebPartContext';
/**
 * The ClientSideWebPartManager is expected to be the public interface to client-side web parts. Each
 * host is expected to create an instance of this class and manage loading of all web parts in that host
 * through that one instance. e.g. On one page, if there are multiple Canvas objects, each one could have
 * one instance of this class. If the page hosts web parts without the Canvas, then the page can have an
 * instance of this class. Overall this class is expected to provide the following purpose:
 *
 *    - Orchestrates loading of one or more web parts in a host.
 *    - It takes care of loading web part dependencies asynchronously. Each web part loads completely
 *      independently of the other web parts in the host.
 *    - Keep a reference to all the loaded web parts and help provide bulk operations on the web parts.
 *    - Help manage memory leak type issues in one place.
 *    - Integrate the web parts with the PropertyPane and other external entities.
 *    - Help troubleshoot web parts during escalations.
 *
 * @internal
 */
export default class ClientSideWebPartManager {
    /**
     * Reference to the instances of all ClientSideWebPartManager instances in the app.
     */
    private static readonly _webPartManagerList;
    private static readonly _domainRegex;
    private static readonly _logSource;
    private static _manifestRequestPromiseCache;
    /**
     * Reference to the PropertyPane controller.
     * Note, all instances of ClientSideWebPartManager share the same PropertyPane controller.
     */
    private _propertyPane;
    /**
     * Dictionary of all the active web parts in this insance of the manager.
     */
    private _webparts;
    /**
     * Host for this instance of the web part manager.
     * Note, at the current time there is no support for multiple hosts and the host is not expected to change.
     */
    private readonly _host;
    /**
     * Timer to mark the canvas dirty.
     */
    private _dirtyBitTimer;
    /**
     * Number of web parts asked to load, including web parts failed to load.
     */
    private _loadWebPartRequests;
    /**
     * Web part status renderer instance scoped to this web part manager instance.
     */
    private _statusRenderer;
    /**
     * Page context reference.
     */
    private readonly _pageContext;
    /**
     * Promise for the async call to get edit-time web parts.
     */
    private _toolboxManifestsPromise;
    /**
     * Dictionary of all the iframed web parts in this instance of the manager.
     */
    private _iframedWebpartInstanceIds;
    /**
     * Reference to IframedWebPartController instance.
     * The instance is chunked loaded for the first time in 'this.loadWebPart'
     * and should be checked for existence before using.
     */
    private _iframedWebPartController;
    private _deprecatedIsObserverEnabled;
    private _propertyPaneLoader;
    private _propertyPaneConsumerQueue;
    /**
     * Number of web parts that has finished rendering, including those that have failed
     */
    private _webPartRenderedCount;
    private _displayMode;
    /**
     * True if all web parts inside viewport has been rendered.
     */
    private _isViewportRendered;
    /**
     * The viewport loader generated by the factory.
     */
    private _viewportLoader;
    private static _instanceOfBase;
    private static _addPerfProperty;
    private static _getWebPartTag;
    /**
     * Returns true if the maintenanceMode query string parameter is provided.
     */
    static readonly isMaintenanceMode: boolean;
    /**
     * Initialize the ClientSideWebPartManager.
     *
     * @param host - Reference to the host. A web part host is a component that is deemed capable of hosting a web
     * part. Any component that implements the IWebPartHost is allowed to host a web part.
     */
    constructor(host: IWebPartHost);
    /**
     * Load a web part in the provided DOM element. Does the following steps
     *
     *    1. Validate params.
     *    2. Validate the web part manifest.
     *    3. Perform an async import of the web part modules from the provided manifest
     *      - i.e ClientSideWebPartManager._loadWebPartModules
     *    4. Instantiate and initialize the web part object
     *      - i.e. ClientSideWebPartManager._initializeWebPart
     *    5. Render the web part in the provided DOM element
     *      - i.e. ClientSideWebPartManager._renderWebPart
     *
     * If an error happens during any of the above steps, catch the error and log it.
     *
     * @param context - web part manager context.
     */
    loadWebPart(context: IWebPartManagerContext): Promise<void>;
    /**
     * Set a IPropertyPaneConsumer object into the set of the Client-side Web Part Manager's
     * managed web parts.
     *
     * @param id - A unique instance id.
     * @param control - A component which wants to use the property Pane.
     *
     * @internal
     */
    setPropertyPaneConsumer(id: string, control: IPropertyPaneConsumer): void;
    /**
     * Fetch web part manifests. This makes a REST call to load the current site's web parts into the module loader.
     */
    fetchWebPartManifests(): Promise<void>;
    /**
     * Get list of active web part manifests.
     *
     * @returns - array of manifests.
     */
    getWebPartManifests(): IClientSideWebPartManifest<any>[];
    /**
     * Set the display mode of the specified web part. If no web part id is specified, switch mode of all web parts.
     * If the display mode passed is same as the current mode, no change is applied.
     *
     * @param displayMode - the new DisplayMode.
     * @param instanceId - instance id of the web part.
     */
    setDisplayMode(displayMode: DisplayMode, instanceId?: string): void;
    /**
     * @internalremarks Only use this API if you need to immediately call property pane APIs after switching the mode.
     * @internal
     */
    _setDisplayMode(displayMode: DisplayMode, instanceId?: string): Promise<void>;
    /**
     * Serialize the specified web part. If no web part is specified, serialize all web parts.
     *
     * @param instanceId - instance id of the web part.
     */
    serialize(instanceId?: string): Map<string, IWebPartData | undefined>;
    /**
     * Set the web part data for the specified web part.
     *
     * The setWebPartData API has 3 possible scenarios when the web part data is updated externally.
     * - Web part declares useFallbackWhenPropertiesUpdatedExternally manifest field as `true`, web part manager will
     *   trigger the default fallback logic which disposes the web part and reload it using the given context.
     * - Web part overrides `onAfterPropertiesUpdatedExternally` life cycle events, web part manager will first
     *   deserialize the web part data, then invokes the `onAfterPropertiesUpdatedExternally` event to allow web part to
     *   do their customized handling logic.
     * - If useFallbackWhenPropertiesUpdatedExternally manifest field is `false` or `undefined`, and web part does not
     *   override `onAfterPropertiesUpdatedExternally` life cycle events, web part manager will first deserialize the
     *   web part data, then invokes the `_refresh` life cycle to re-render the web part.
     *
     * @param webPartData - the new web part data.
     * @param instanceId - instance id of the web part.
     * @param shouldFallback - whether it should fallback to dispose & reload logic.
     * @returns - A promise that resolves immediately if fallback is not used, or returns the loadWebPart promise
     *  when fallback is used.
     */
    setWebPartData(context: IWebPartManagerContext, instanceId: string, shouldFallback?: boolean): Promise<void>;
    /**
     * Dispose of the current webpart manager and all of the webparts it has loaded.
     */
    dispose(): void;
    /**
     * Dispose the specified web part. If no web part is specified, dispose all web parts.
     *
     * @param instanceId - instance id of the web part.
     */
    disposeWebparts(instanceId?: string): void;
    tryGeneratePreviewImageUrl(instanceIds?: string[]): string | undefined;
    /**
     * Request property pane to perform the given action.
     *
     * @param instanceId - web part instance id.
     * @param propertyPaneAction - indicates what action needs to be performed on the property pane.
     * @param renderedByWebPart - indicates whether the the property pane rendered by a web part or not.
     * @param context - pass additional context to property pane
     */
    requestPropertyPaneAction(instanceId: string, propertyPaneAction?: PropertyPaneAction, renderedByWebPart?: boolean, context?: any): void;
    /**
     * Returns true if the current property pane source is a web part and not the Canvas or any other source.
     */
    isPropertyPaneRenderedByWebPart(): boolean;
    /**
     * Returns the state of the PropertyPane if it is open or not.
     */
    isPropertyPaneOpen(): boolean;
    /**
      * Method to handle the web part delete action from the host. There is a key distinction between delete and dispose.
      * Delete implies that the web part has been deleted from the page and the web part should dispose all the server
      * side or other external resources attached to the web part. Dispose implies that an in-place navigation is
      * happening and the web part manager should delete the web part from its cache.
      *
      * @param instanceId - instance id of the webpart which is deleted.
      */
    onWebPartDelete(instanceId: string): void;
    /**
     * Render an error message in the web part container div.  Also logs the error message to the IWebPartHost logger.
     */
    renderError(domElement: HTMLElement, error: Error): void;
    /**
     * Notify webparts that their container has resized.
     *
     * @param instanceId - if specified only notify one webpart that its container has resized
     */
    notifyWebPartContainerResize(instanceId?: string): void;
    /**
     * Used to ensure the next request for webpart manifests makes a call to the server.
     */
    clearManifestPromise(): void;
    /** ------------------- PROTECTED ------------------- **/
    /**
     * Generate web part context.
     */
    protected _getWebPartContext(context: IWebPartManagerContext): WebPartContext;
    /** ------------------- PRIVATE ------------------- **/
    /**
     * Loads the web part component and any dynamic dependencies.
     */
    private _loadWebPartModules;
    private _fetchManifestsWithCache;
    private _clearManifestCacheItem;
    /**
     * Invoked whenever a web part is rendered including situations where any errors have occurred
     */
    private _onWebPartRendered;
    /**
     * Workaround for a server issue - disambiguate manifest locales if they haven't already been disambiguated
     * (VSO#243888) tracks fixing this issue.
     */
    private _disambiguateWebPartManifestLocales;
    /**
     * Validate and process input parameters.
     */
    private _validateInput;
    /**
     * Validate the web part manifest.
     */
    private _validateManifest;
    /**
     * Execute the provided callback for the list of provided web part ids. If no list if provided,
     * execute the callback on all web parts.
     */
    private _executeForIdsOrAll;
    private readonly _isObserverEnabled;
    private _getLoadedModuleList;
    /**
     * This is a temporary implementation of updating the host that a web part has updated properties.
     * Currently we run a timer that regularly checks for updated properties and raises the dirty bit
     * handler to the host. todo (VSO SPPPLAT#200728) tracks fixing this scenario in a better way.
     */
    private _startDirtyBitTimer;
    /**
     * Creates a new extra data object for writing unexpected failures to QosMonitor.
     */
    private _createUnexpectedFailureExtraData;
    /**
     * Creates a new QosMonitor with a scenario name specific to the web part type.
     */
    private _createLoadQosMonitor;
    /**
     * Create the web part tag. Web part tag is a unique tag per web part instance and is used for logging and telemetry.
     */
    private _createWebPartTag;
    private _deleteWebPart;
    /**
     * Get web part manifest instance from manifest. Promotes the pre-configured entries.
     */
    private _getManifestInstance;
    /**
     * If non-non parameter passed, return array else return undefined.
     */
    private _getArrayOrUndefined;
    private _initialzeOnResizeEventHandler;
    /**
     * Window onresize event handler.
     */
    private _onContainerResize;
    /**
     * Listener for window post message that the property pane.
     *
     * todo (SPPPLAT Bug #299413): Implement missing schema for property pane post messages
     * todo (SPPPLAT PBI #687467): Refactor IframedWebPartContoller
     */
    private _onPropertyPaneNotifications;
    /**
     * When all web parts added, check if in viewport web parts are rendered
     * If so then notify viewport loader to load rest of the web parts gradually.
     */
    private _onAllWebpartsAdded;
    private _onViewportWebpartsLoaded;
    private _getViewportRenderedEndTimeLegacy;
    /**
     * Return endtime of last rended web part if all web parts in the view port has rendered for current web part
     * manager instance, undefined otherwise.
     * Always remember hosting app can have multiple CSWPM instance.
     */
    private _getViewportRenderedEndTime;
    /**
     * Add all web parts in the viewport to the EUPL calculation
     */
    private _registerWebpartsInViewport;
    /**
   * Converts Module library into Internal Web part object.
   * Throws Exception if unexpectd found
   */
    private _instantiateWebPart;
    /**
     * Handle when exception occurred loading web part
     */
    private _handleErrorLoadingWebpart;
    /**
     * handle when Module Promise is rejected
     */
    private _handleModulePromiseRejection;
    private _onFirstTimeWebpartRender;
    private _getDataUpdatedEventName;
    private _initializeWebPart;
    private _handleRenderComplete;
    private _renderWebPart;
    /**
     * Load all valid dynamic dependencies and adds into moduleLoadPromises param.
     *
     * This is the core of dynamic dependency web part has provided through metadata. Framework ensures that the such
     * dependency is loaded for the web part before it starts rendering. Ideally this component's js bundle should be
     * already downloaded by server script preloading feature for first few web parts in viewport.
     */
    private _loadDynamicComponentDependencies;
    /**
     * Registers a component as a property pane consumer.
     * @param instanceId - Instance id of the consumer, to be registered with the property pane.
     */
    private _registerWebPartAsPropertyPaneConsumer;
    /**
     * Creates an absolute url with the isolatedDomain parameter.
     * @param isolatedDomain - a domain without the protocol. Ex: "PrepSPO-appFEEAB5CE1CB0421FB1AAE5D09E0A8AAA.spgrid.com"
     * @param absoluteUrl - url with protocol that may or may not contain a path. Ex: "https://prepspo.spgrid.com"
     */
    private _ensureUrl;
    /**
     * Loads the property pane module asynchronously, if not already loaded.
     */
    private _loadPropertyPaneModule;
    private _registerPendingPropertyPaneConsumers;
    private _closeIsolatedPropertyPaneIfRequired;
    /**
     * Load the fabric core library, for third-party web parts if required.
     * @param context - Current context of the web part manager
     * @param qosMonitor - qos monitor for the current flow
     */
    private _loadLegacyFabricCssIfRequired;
}
//# sourceMappingURL=ClientSideWebPartManager.d.ts.map