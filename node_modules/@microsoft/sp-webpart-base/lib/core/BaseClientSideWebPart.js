// Copyright (c) Microsoft. All rights reserved.
'use strict';
import * as tslib_1 from "tslib";
import { _PerformanceLogger } from '@ms/sp-telemetry';
import { _EngagementLogger, _LogEntry, _LogSource, _LogType, _QosMonitor, _TraceLogger } from '@microsoft/sp-diagnostics';
import { _SPKillSwitch, DisplayMode, Environment, Guid, Text, _SPFlight } from '@microsoft/sp-core-library';
import BaseWebPart from './BaseWebPart';
import ClassicPageUtils from './classicPages/ClassicPageUtils';
import KillSwitches from './../common/KillSwitches';
import { SPWebPartError, SPWebPartErrorCode } from './error/SPWebPartError';
import ViewportLoader from './ViewportLoader';
import strings from './loc/Strings.resx';
import baseStyles from './styles/cswp-base.module.scss';
import { Flights } from '../common/Flights';
/**
 * This abstract class implements the the base functionality for a client-side web part. Every client-side web part
 * needs to inherit from this class.
 *
 * @remarks
 * Along with the base functionality, this class provides some APIs that can be
 * used by the web part. These APIs fall in two catagories.
 *
 * The first category of APIs provide data and functionality. Example, the web part context (i.e. this.context). This
 * API should be used to access contextual data relevant to this web part instance.
 *
 * The second category of APIs provide a base implementation for the web part lifecycle and can be overridden for an
 * updated implementation. The render() API is the only API that is mandatory to be implemented/overridden by a web
 * part. All other life cycle APIs have a base implementation and can be overridden based on the needs of the web part.
 * Please refer to the documentation of the individual APIs to make the right decision.
 *
 * @public
 */
var BaseClientSideWebPart = /** @class */ (function (_super) {
    tslib_1.__extends(BaseClientSideWebPart, _super);
    /**
     * Constructor for the BaseClientSideWebPart class.
     *
     * @remarks
     * It is highly recommended that the web part use the `onInit()` API to perform any web part specific
     * initialization.  Most of the web part features like this.context and `this.properties` are not
     * available to be used before the the `onInit()` part of the web part loading lifecycle.
     */
    function BaseClientSideWebPart() {
        var _this = _super.call(this) || this;
        _this._logSource = _LogSource.create('BaseClientSideWebPart');
        /**
         * True value reflects that web part is loaded as it was perceived in viewport.
         *
         * NOTE: Don't update it. This flag should be only read to know the lazy loading status.
         * NOTE: Don't use this flag to track position of the web part in viewport. Use this
         * flag only to track if web part rendering has been delayed or not.
         */
        _this._registeredInViewport = false;
        _this._asyncRenderQosMonitor = new _QosMonitor("WebPartAsyncRender");
        // Disallow instantiation of the base class by itself
        if (_this.constructor['name'] === 'BaseClientSideWebPart') { // tslint:disable-line:no-string-literal
            throw SPWebPartError.create(SPWebPartErrorCode.BaseConstructError);
        }
        _this._firstTimeRenderPromises = [];
        return _this;
    }
    Object.defineProperty(BaseClientSideWebPart.prototype, "domElement", {
        // Readonly protected properties. To change these to readonly once TypeScript supports that feature.
        /**
         * This property is a pointer to the root DOM element of the web part. This is a DIV element and contains the whole
         * DOM subtree of the web part.
         *
         * @readonly
         */
        get: function () { return this.context.domElement; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "width", {
        /**
         * This value is the available width of the area in which the web part can render itself.
         * Instead of "Element.clientWidth" which returns an integer, "getComputedStyle" returns
         * a number which is more accurate in sub-pixel.
         *
         * @remarks
         * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth | clientWidth}
         * {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseFloat | parseFloat}
         * {@link https://developer.mozilla.org/en/docs/Web/API/Window/getComputedStyle | getComputedStyle}
         *
         * @readonly
         * @alpha
         */
        get: function () {
            if (this._width === undefined) {
                var width = window.getComputedStyle(this.domElement).width;
                this._width = width ? parseFloat(width) : 0;
            }
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "renderedOnce", {
        /**
         * This property indicates whether the web part has been rendered once or not. After the first time rendering,
         * the value of this property is always true until a full re-render of the web part happens.
         *
         * @readonly
         */
        get: function () { return this._renderedOnce; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "renderedFromPersistedData", {
        /**
         * This property indicates whether the web part was rendered from the persisted data (serialized state from the
         * last time that the web part was saved) or not.
         *
         * @remarks
         * Example: When web part is added for the first time using toolbox then the value is false.
         *
         * @readonly
         */
        get: function () { return this._renderedFromPersistedData; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "canOpenPopupOnRender", {
        /**
         * This property indicates whether a web part can open a popup on initial render.
         *
         * @remarks
         * In some environments the host
         * re-renders the web parts frequently, and therefore opening popups during render will cause popups to open
         * repeatedly, which is a poor user experience. As an example, the classic SharePoint pages perform postbacks
         * causing the page to re-render on all button clicks.
         *
         * If a web part needs to open a popup on render, it should use this API before opening the popup. If this API
         * returns false, the web part should not open popup on initial render. Some web parts that open popups during
         * render are the document embed web part that pops up the file picker on initial render, embedded video web part
         * that pops up the PropertyPane on initial render.
         *
         * @readonly
         */
        get: function () {
            // @todo (SPPPLAT VSO#243602): if the classic page experience is usable, we should remove this API.
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseClientSideWebPart.prototype, "isRenderAsync", {
        /**
         * Indicates whether the web part is rendering in Async mode.
         *
         * @remarks
         * If the web part overrides this field to return true, then it needs to call renderCompleted API
         * after the web part rendering is complete.
         *
         * The default value is false.
         *
         * @virtual
         */
        get: function () { return false; },
        enumerable: true,
        configurable: true
    });
    /**
     * Internal API to update the webpart upon a resize of the DOM window's viewport
     *
     * See onAfterResize for more details.
     *
     * @internal
     */
    BaseClientSideWebPart.prototype._internalOnAfterResize = function () {
        this._width = undefined;
        this.onAfterResize(this.width);
    };
    /**
     * Internal API for the first time render of the web part. The purpose of this API is to enforce initialization steps
     * before the actual render is called. This API is called only once during the web part loading lifecycle.
     *
     * @returns The promise indicates the render loop is finished (success or fail).
     *
     * @internal
     */
    BaseClientSideWebPart.prototype._internalFirstTimeRender = function (scrollableParent, qosMonitor) {
        var _this = this;
        /* tslint:enable:no-unused-variable */
        if (this._renderPromiseResolver) {
            throw SPWebPartError.create(SPWebPartErrorCode.FirstTimeRenderCalledMoreThanOnce, this.context.webPartTag);
        }
        _TraceLogger.logVerboseData({
            source: this._logSource,
            message: Text.format(strings.StartedFirstTimeRender, this.context.webPartTag),
            serviceScope: this.context.serviceScope
        });
        return new Promise(function (resolve, reject) {
            // By this point in the lifecycle the web part should have a non-null property bag.
            if (!_this.properties && qosMonitor) {
                qosMonitor.writeUnexpectedFailure('PropertyBagNull');
                throw SPWebPartError.create(SPWebPartErrorCode.PropertyBagNull, _this.context.webPartTag);
            }
            // Ensure Web part occupy minimum space while loading, if specified
            var minHeight = _this._calculateMinimumHeight();
            if (minHeight) {
                _this.domElement.style.minHeight = minHeight + "px";
            }
            _this._renderPromiseResolver = resolve;
            _this._renderPromiseRejecter = reject;
            if (!_this.context.host.isViewportLoadingDisabled) {
                _PerformanceLogger.markComponent(_this.context.webPartTag, 'loadingDelayed');
                _this._internalDelayedRender(scrollableParent);
            }
            else {
                _this._onInViewport();
            }
        });
    };
    /**
     * @internal
     */
    BaseClientSideWebPart.prototype._internalSetDisplayMode = function (newDisplayMode) {
        if (this.displayMode !== newDisplayMode) {
            // Switch display mode will change the canvas width of web part. Clear the cache of width here.
            this._width = undefined;
            this._renderedFromPersistedData = true;
        }
        _super.prototype._internalSetDisplayMode.call(this, newDisplayMode);
    };
    /**
     * @internal
     * {@inheritDoc BaseWebPart._internalInitialize}
     */
    BaseClientSideWebPart.prototype._internalInitialize = function (webPartContext, addedFromPersistedData, mode) {
        _super.prototype._internalInitialize.call(this, webPartContext, addedFromPersistedData, mode);
        if (_SPFlight.isEnabled(1314 /* ViewportLoaderGeneralized */)) {
            this._viewportLoader = webPartContext.host.viewportLoader;
        }
        this._renderedOnce = false;
        this['__type'] = 'BaseClientSideWebPart'; // tslint:disable-line:no-string-literal
        // Bind the callbacks
        this.render = this.render.bind(this);
        this.onDispose = this.onDispose.bind(this);
        this.renderError = this.renderError.bind(this);
        this.clearError = this.clearError.bind(this);
        this.renderCompleted = this.renderCompleted.bind(this);
        if (!KillSwitches.bindAsyncRenderActivated()) {
            this._asyncRenderTimeout = this._asyncRenderTimeout.bind(this);
        }
    };
    /**
     * Calculates minimum height required for the web part to render with current width
     *
     * @internal @virtual
     */
    // This is a temporary workaround tracked by [VSO:SPPPlat] #378372
    BaseClientSideWebPart.prototype._calculateMinimumHeight = function () {
        if (this.context && this.context.manifest && this.context.manifest.isInternal) {
            _TraceLogger.logErrorData({
                source: this._logSource,
                error: new Error("Web part " + this.context.webPartTag + " should override _calculateMinimumHeight()"),
                serviceScope: this.context.serviceScope
            });
        }
        return undefined;
    };
    /**
     * This API should be called by web parts that perform Async rendering. Those web part are required to override
     * the isRenderAsync API and return true. One such example is web parts that render content in an IFrame. The
     * web part initiates the IFrame rendering in the `render()` API but the actual rendering is complete only after
     * the iframe loading completes.
     */
    BaseClientSideWebPart.prototype.renderCompleted = function () {
        this._renderCompleted();
    };
    /**
     * This event method is called when the display mode of a web part is changed.
     *
     * @remarks
     * The default implementation of this API calls
     * the web part render method to re-render the web part with the new display mode. If a web part developer does not
     * want a full re-render to happen on display mode change, they can override this API and perform specific updates
     * to the web part DOM to switch its display mode.
     *
     * @param oldDisplayMode - The old display mode.
     *
     * @virtual
     */
    BaseClientSideWebPart.prototype.onDisplayModeChanged = function (oldDisplayMode) {
        var _this = this;
        _super.prototype.onDisplayModeChanged.call(this, oldDisplayMode);
        if (oldDisplayMode === this.displayMode) {
            return;
        }
        // Note: this quirk has existed for a very long time now. Long enough that it can be considered
        // a part of the design :(. Consider the scenario when the page is loaded with "&Mode=Edit" query
        // string parameter. As per the original design, the host, say, the ModernPage in this case, should call
        // the ClientSideWebPartManager.loadWebPart API with "displayMode == Edit" value. But that is not
        // the case. The ModernPage calls loadWebPart with "displayMode == Read" and then calls
        // ClientSideWebPartManager.setDisplayMode(displayMode == Edit). This opens the door for race condition
        // bugs to occur. Especially as the web part loading lifecycle is becoming more complex. To avoid these
        // race conditions from happening we need to to make sure all the first time rendering promises are
        // resolved before this._renderWithAccessibleTitle can be called.
        if (!_SPKillSwitch.isActivated(Guid.parse('222961df-4439-412b-9e41-2e659ae18ab6'), '5/11/2018', 'FirstRenderPromises')) {
            Promise.all(this._firstTimeRenderPromises).then(function () { _this._renderWithAccessibleTitle(); });
        }
        else {
            this._renderWithAccessibleTitle();
        }
    };
    /**
     * This API should be used to refresh the contents of the PropertyPane.
     *
     * @remarks
     * This API is called at the end of the web part lifecycle on a page. It should be used to dispose any local
     * resources (i.e. DOM elements) that the web part is holding onto. This API is expected to be called in scenarios
     * like page navigation i.e. the host is transitioning from one page to another and disposes the page that is being
     * transitioned out.
     *
     * @virtual
     */
    BaseClientSideWebPart.prototype.onDispose = function () {
        if (!this.context.host.isViewportLoadingDisabled && !this._registeredInViewport) {
            // tslint:disable-next-line:no-any
            this._viewportLoaderInstance.unregister(this);
        }
    };
    /**
     * This API is invoked when the web part container dom element width is changed, e.g. when the browser
     * browser window is resized and when the property pane is toggled open/close.
     *
     * @remarks
     * Web parts should utilize this method to perform operations such as potentially re-rendering components
     * based on the new available width for the web part.
     *
     * @alpha @virtual
     */
    BaseClientSideWebPart.prototype.onAfterResize = function (newWidth) {
        /* EMPTY BLOCK */
    };
    /**
     * This API should be used to render an error message in the web part display area. Also logs the error message
     * using the trace logger.
     *
     * @param error - An error object containing the error message to render.
     */
    BaseClientSideWebPart.prototype.renderError = function (error) {
        this.context.statusRenderer.clearLoadingIndicator(this.domElement);
        this.context.statusRenderer.renderError(this.domElement, error);
        _TraceLogger.logError(this._logSource, error);
    };
    /**
     * This API should be used to clear the error message from the web part display area.
     */
    BaseClientSideWebPart.prototype.clearError = function () {
        this.context.statusRenderer.clearError(this.domElement);
    };
    /**
     * Internal API to trigger a refresh to the WebPart's visual rendition.
     * In this implementation of the BaseWebPart class we call the render API.
     *
     * @internal
     */
    BaseClientSideWebPart.prototype._refresh = function () {
        this._renderWithAccessibleTitle();
    };
    /**
     * Internal API triggered by a dynamic property's callback.
     * In this implementation of the BaseWebPart class we call the render API, only if rendered once.
     *
     * @internal
     */
    BaseClientSideWebPart.prototype._dynamicPropertyRefresh = function () {
        if (this.renderedOnce) {
            this.render();
        }
    };
    Object.defineProperty(BaseClientSideWebPart.prototype, "_viewportLoaderInstance", {
        /**
         * If the new ViewportLoader (V2) is available, use this.
         * Otherwise, return the singleton instance of the original ViewportLoader.
         *
         * @returns The appropriate viewport loader.
         */
        get: function () {
            return this._viewportLoader || ViewportLoader.deprecatedInstance;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @privateRemarks
     * This method is overridden in the sp-spm library.
     * @internal
     */
    BaseClientSideWebPart.prototype._internalDelayedRender = function (scrollableParent) {
        // tslint:disable-next-line:no-any
        this._viewportLoaderInstance.register(this, scrollableParent);
        if (!this._registeredInViewport) {
            _TraceLogger.logVerboseData({
                source: this._logSource,
                message: "Web part " + this.context.webPartTag + " is not in initial viewport, rendering delayed.",
                serviceScope: this.context.serviceScope
            });
        }
    };
    /**
     * The actual initialization and rendering of the Web part starts when it is close enough
     * to the Viewport
     */
    BaseClientSideWebPart.prototype._onInViewport = function () {
        var _this = this;
        if (!this.context.host.isViewportLoadingDisabled) {
            _PerformanceLogger.markComponent(this.context.webPartTag, 'inViewportLoading');
            _TraceLogger.logVerboseData({
                source: this._logSource,
                message: "Actually started first time render for web part " + this.context.webPartTag + ".",
                serviceScope: this.context.serviceScope
            });
        }
        // Render promise callback should be defined at this time.
        if (!this._renderPromiseResolver || !this._renderPromiseRejecter) {
            throw SPWebPartError.create(SPWebPartErrorCode.RenderPromiseUndefined, this.context.webPartTag);
        }
        // Perform web part initialization and then render the web part.
        var initPromise = this.onInit();
        if (!initPromise) {
            var error = SPWebPartError.create(SPWebPartErrorCode.OnInitReturnedNullPromise, this.context.webPartTag);
            this._renderPromiseRejecter(error);
            this._clearRenderPromises();
            return;
        }
        this._firstTimeRenderPromises.push(initPromise);
        initPromise
            .then(function () { return _this._yieldToEventLoop(); })
            .then(function () {
            _TraceLogger.logVerboseData({
                source: _this._logSource,
                message: Text.format(strings.OnInitCompleted, _this.context.webPartTag),
                serviceScope: _this.context.serviceScope
            });
            _PerformanceLogger.markComponent(_this.context.webPartTag, 'init');
            var getDataPromise = Promise.resolve();
            // Perform web part initialization and then render the web part.
            getDataPromise = _this._internalGetData();
            if (!getDataPromise) {
                throw SPWebPartError.create(SPWebPartErrorCode.GetDataReturnedNullPromise, _this.context.webPartTag);
            }
            _this._firstTimeRenderPromises.push(getDataPromise);
            getDataPromise
                .then(function () { return _this._yieldToEventLoop(); })
                .then(function () {
                _PerformanceLogger.markComponent(_this.context.webPartTag, 'getDataComplete');
                // Clear the loading indicator
                _this.context.statusRenderer.clearLoadingIndicator(_this.domElement);
                _this._renderWithAccessibleTitle();
                // Record the time framework has finished calling render(). By this time framework is accountable
                // for loading web part module through fasted CDN and loading web part data through appropriate
                // techniques like Web part cache and synchronous time to execute web part's render() method.
                _PerformanceLogger.markComponent(_this.context.webPartTag, 'syncRender');
                // If rendering happened synchronously, simply complete the rendering cycle.
                // Else, create a new promise and wait for it to be resolved. The resolution
                // can happen when the web part completes the promise or when the timeout fires.
                if (!_this.isRenderAsync) {
                    _this._tryToLogLoadFirstRenderDone();
                    _this._resolveOrRejectOnRenderPromise();
                }
                else {
                    _this._startAsyncRenderGuardTimer();
                }
            });
        }).catch(function (e) {
            if (_this._renderPromiseRejecter) {
                _this._renderPromiseRejecter(e);
                _this._clearRenderPromises();
            }
        });
    };
    /**
     * Wraps render to ensure any type of rendering has access to the latest context
     * to provide the most accurate accessible info to screen readers.
     */
    BaseClientSideWebPart.prototype._renderWithAccessibleTitle = function () {
        _PerformanceLogger.devMark("webpart(" + this.context.webPartTag + ")._renderWithAccessibleTitle");
        this.render();
        // The accessible label is only required in edit mode. It is also not required for mobile devices
        // which only provide view mode
        if (this.displayMode === DisplayMode.Edit) {
            // Render the accessible description after and associate by ID to avoid re-rendering the whole zone
            // when webpart updates contextual info.
            var accessibleContext = this.accessibleTitle || this._getDefaultAccessibleTitle();
            if (accessibleContext) {
                // Keep ID in sync with ControlZone.render
                var contextualLabelId = "cswpAccessibleLabelContextual_" + this.context.instanceId;
                var accessibleDiv = this.domElement.querySelector("#" + contextualLabelId);
                var isNewLabelElement = !accessibleDiv;
                if (isNewLabelElement) {
                    accessibleDiv = document.createElement('div');
                    accessibleDiv.id = contextualLabelId;
                    accessibleDiv.className = baseStyles.screenReaderOnly;
                    accessibleDiv.setAttribute('aria-hidden', 'true');
                }
                accessibleDiv.textContent = accessibleContext;
                if (isNewLabelElement) {
                    this.domElement.appendChild(accessibleDiv);
                }
            }
            // Perform classic page fixup. It should only be called in edit mode otherwise it will
            // make anchor elements not working in view mode.
            ClassicPageUtils.disableAutomaticPostbacks(this.domElement, Environment.type);
        }
        // Reset minHeight only if the KillSwitch is activated
        if (KillSwitches.isWebPartMinHeightResetKSActivated()) {
            // We are removing this statement as we are already resetting the minHeight post-render.
            // Also this is causing unnecessary resize, leading to janky rendering.
            this.domElement.style.minHeight = null; // tslint:disable-line:no-null-keyword
        }
    };
    /**
     * Start async guard timer. This timer is to help avoid losing performance markers for a web part
     * that renders asynchronously but does not call the `renderCompleted` API;
     */
    BaseClientSideWebPart.prototype._startAsyncRenderGuardTimer = function () {
        var _this = this;
        // Note: the timer is 25 seconds because after 30 seconds, the PerformanceLogger will auto expire
        // the log timer and we will lose data. This value needs to be smaller than that.
        this._clearAsyncRenderGuardTimer();
        this._asyncRenderGuardTimer = window.setTimeout(function () {
            _this._asyncRenderTimeout();
        }, 25000);
    };
    /**
     * Render completed.
     */
    BaseClientSideWebPart.prototype._renderCompleted = function () {
        if (this._asyncRenderGuardTimer) {
            this._tryToLogLoadFirstRenderDone();
            this._clearAsyncRenderGuardTimer();
            this._asyncRenderQosMonitor.writeSuccess({
                'alias': this.context.manifest.alias,
                'webPartId': this.context.manifest.id
            });
            this._resolveOrRejectOnRenderPromise();
        }
    };
    /**
     * Async render timed out. Log error information and
     */
    BaseClientSideWebPart.prototype._asyncRenderTimeout = function () {
        // There is a potential race condition when the async guard timer gets queued into the javascript
        // task queue right at the time when renderCompleted API gets called. Protect against that.
        if (this._asyncRenderGuardTimer) {
            this._clearAsyncRenderGuardTimer();
            // At this time we only log an error and fail the QOS monitor when the async guard timer fires.
            var error = SPWebPartError.create(SPWebPartErrorCode.RenderCompletedCallNotCalled, this.context.webPartTag);
            _TraceLogger.logErrorData({
                source: this._logSource,
                error: error,
                serviceScope: this.context.serviceScope
            });
            this._asyncRenderQosMonitor.writeUnexpectedFailure('Timeout', error, {
                'alias': this.context.manifest.alias,
                'webPartId': this.context.manifest.id,
                'instanceId': this.instanceId
            });
            this._resolveOrRejectOnRenderPromise(true);
        }
    };
    BaseClientSideWebPart.prototype._clearAsyncRenderGuardTimer = function () {
        if (this._asyncRenderGuardTimer) {
            window.clearTimeout(this._asyncRenderGuardTimer);
            this._asyncRenderGuardTimer = undefined;
        }
    };
    /**
     * This is called for every web part whether sync or async once rendering is completed.
     */
    BaseClientSideWebPart.prototype._resolveOrRejectOnRenderPromise = function (isReject) {
        this._renderedOnce = true;
        var message = Text.format(this.isRenderAsync ? strings.CompletedAsyncRender : strings.CompletedSyncRender, this.context.webPartTag);
        _TraceLogger.logVerboseData({
            source: this._logSource,
            message: message,
            serviceScope: this.context.serviceScope
        });
        _PerformanceLogger.devMark("webpart(" + this.context.webPartTag + ").complete");
        if (!KillSwitches.isLogWebPartLoadRenderDoneKillSwitchActivated() && isReject) {
            if (this._renderPromiseRejecter) {
                this._renderPromiseRejecter(SPWebPartError.create(SPWebPartErrorCode.RenderTimeout, this.context.webPartTag));
            }
        }
        else {
            if (this._renderPromiseResolver) {
                this._renderPromiseResolver();
            }
        }
        this._clearRenderPromises();
    };
    BaseClientSideWebPart.prototype._clearRenderPromises = function () {
        this._renderPromiseResolver = undefined;
        this._renderPromiseRejecter = undefined;
        // Reset minHeight
        this.domElement.style.minHeight = null; // tslint:disable-line:no-null-keyword
    };
    BaseClientSideWebPart.prototype._tryToLogLoadFirstRenderDone = function () {
        if (!KillSwitches.isLogWebPartLoadRenderDoneKillSwitchActivated() &&
            !this._renderedOnce &&
            !this._renderedFromPersistedData) {
            var logEntry = new _LogEntry('BaseClientSideWebPart', 'RenderDone', _LogType.Event, {
                alias: "WebPart." + this.manifest.alias + "." + this.manifest.id,
                isInternal: (!!this.manifest.isInternal).toString(),
                isAsyncRender: this.isRenderAsync.toString()
            });
            _EngagementLogger.logEventWithLogEntry(logEntry);
        }
    };
    BaseClientSideWebPart.prototype._isPaintStarvationEnabled = function () {
        return (!KillSwitches.isPaintStarvationKSActivated() &&
            Flights.isPaintStravationEnabled());
    };
    BaseClientSideWebPart.prototype._yieldToEventLoop = function (arg) {
        var useInvertedCheck = !KillSwitches.isCorrectedPainStarveKSActivated();
        var isPaintStarvationOptimized = this._isPaintStarvationEnabled();
        if ((useInvertedCheck && isPaintStarvationOptimized)
            ||
                (!useInvertedCheck && !isPaintStarvationOptimized)) {
            _TraceLogger.logVerbose(this._logSource, 'yielding execution to event loop');
            // tslint:disable-next-line no-string-based-set-timeout
            return new Promise(function (resolve) { return setTimeout(function () { return resolve(arg); }, 0); });
        }
        else {
            return Promise.resolve(arg);
        }
    };
    return BaseClientSideWebPart;
}(BaseWebPart));
export default BaseClientSideWebPart;
//# sourceMappingURL=BaseClientSideWebPart.js.map