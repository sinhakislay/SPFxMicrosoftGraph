/**
 * Server processed data type.
 *
 * @internal
 */
export declare const enum ServerProcessedDataType {
    /**
     * The date type is valid html string.
     */
    htmlString = 1,
    /**
     * The date type is a link to a resource.
     * The link can be a SharePoint content link or non-SharePoint link.
     */
    link = 2,
    /**
     * The date type is a link to a image.
     * The link can be a SharePoint content link or non-SharePoint link.
     */
    imageSource = 3,
    /**
     * The data type is a string that should be search indexed.
     */
    searchablePlainText = 4
}
/**
 * Contains collections of data that can be processed by server side services like search index and link fixup
 *
 * @public
 */
export interface ISerializedServerProcessedData {
    /**
     * A key-value map where keys are string identifiers and values are rich text with HTML format.
     *
     * @remarks
     * SharePoint servers treat the values as HTML content and run services like safety checks, search index
     * and link fixup on them.
     *
     * Example:
     * ```
     * {
     *   'myRichDescription': '<div>Some standard <b>HTML content</b><a href='http://somelink'>A Link</a></div>'
     *   'anotherRichText': <div class='aClass'><span style='color:red'>Some red text</div>
     * }
     * ```
     *
     */
    htmlStrings?: {
        [key: string]: string;
    };
    /**
     * A key-value map where keys are string identifiers and values are strings that should be search indexed.
     *
     * @remarks
     * The values are HTML-encoded before being sent to the server. The encoded values are visible to the search
     * indexer, but are not treated as valid HTML. So, other services such as link fixup will not run on them.
     *
     * Example:
     * ```
     * {
     *  'justSomeText': 'This is some plain text',
     *  'anotherText': 'Can have <any> characters here: "<>&\''
     * }
     * ```
     */
    searchablePlainTexts?: {
        [key: string]: string;
    };
    /**
     * A key-value map where keys are string identifiers and values are links.
     *
     * @remarks
     * SharePoint servers treat the values as links and run services like link fixup on them.
     *
     * Example:
     * ```
     * {
     *   'myWebURL': 'http://contoso.com'
     *   'myFileLink': 'https://res.contoso.com/file.docx'
     * }
     * ```
     */
    links?: {
        [key: string]: string;
    };
    /**
     * A key-value map where keys are string identifiers and values are image sources.
     *
     * @remarks
     * SharePoint servers treat the values as image sources and run services like search index and link fixup on them.
     *
     * Example:
     * ```
     * {
     *   'myImage1': 'http://res.contoso.com/path/to/file'
     *   'myImage2': 'https://res.contoso.com/someName.jpg'
     * }
     * ```
     */
    imageSources?: {
        [key: string]: string;
    };
    /**
     * A key-value map where keys are string identifiers and values are component ids.
     *
     * @remarks
     * SharePoint servers might decide to use this hint to preload the script for corresponding components for
     * performance boost.
     *
     * Example:
     * ```
     * {
     *   'layoutComponent': 'abfccb4d-fcbc-4720-8bcc-6183ce66c391',
     *   'dataComponent': 'f0baf432-de3f-4f0f-8444-d1280b2f8cc5'
     * }
     * ```
     * @alpha
     */
    componentDependencies?: {
        [key: string]: string;
    };
    /**
     * A key-value map where keys are string identifier and values are object of custom key-value pair
     *
     * @remarks
     *
     * SharePoint servers might treat custom medata values in context of the other properties like imageSources.
     * E.g. When the key of imageSources and customMetadata is same, custom metadata can be used to expand information
     * of image data.
     *
     * Example:
     * ```
     * ISerializedServerProcessedData {
     *   imageSources: {
     *    'myImage1': 'http://res.contoso.com/path/to/file',
     *    'myImage2': 'https://res.contoso.com/someName.jpg'
     *   },
     *
     *   customMetadata: {
     *     'myImage1': {'height': '100', 'width': '100'}
     *     'myImage2': {'height': '400', 'width': '600'}
     *   }
     * }
     * ```
     *
     * @privateRemarks
     *
     * We should find a way to associate type to this object before this API becomes available to 3rd
     * parties. (SPPPLAT VSO bug#504028) tracks that fix. For now, we are not doing that because that will require a
     * bigger public API change to exiting APIs. We do not want to change existing public APIs before we make this
     * feature available to third parties.
     *
     * @alpha
     */
    customMetadata?: {
        [key: string]: {
            [key: string]: {};
        };
    };
}
export default ISerializedServerProcessedData;
//# sourceMappingURL=ISerializedServerProcessedData.d.ts.map