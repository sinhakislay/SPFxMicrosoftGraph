import { IsolatedDynamicDataTransceiver } from './IsolatedDynamicDataTransceiver';
import { IsolatedDynamicDataMessageType } from './IsolatedDynamicDataMessageType';
import { _SPEventManager } from '@microsoft/sp-core-library';
import { DynamicDataEventNames } from '../common/DynamicDataEventNames';
import { _QosMonitor } from '@microsoft/sp-diagnostics';
var QOS_MONITOR_PREFIX = 'DynamicData.IsolatedProxyDynamicDataSource';
/**
 * A proxy dyanmic data source created in the isolated environment. This class is responsible
 * for adding proxy async apis on the source, which are responsible for making sending PostMessages
 * to the parent window and get the information back.
 *
 * @internal
 */
var IsolatedProxyDynamicDataSource = /** @class */ (function () {
    function IsolatedProxyDynamicDataSource(source) {
        /**
         * Added the below 3 dummy public properties to make this class extend ISPEventObserver.
         * @internal
         */
        this.instanceId = this.id + "-instanceId";
        this.componentId = this.id;
        this.isDisposed = false;
        // Property value variables
        this._propertyValueMap = new Map(); // tslint:disable-line:no-any
        // Annotated property value variables
        // tslint:disable-next-line:no-any
        this._annotatedPropertyValueMap = new Map();
        this._id = source.id;
        this._metadata = source.metadata;
        this._propertyDefinitions = new Array();
    }
    Object.defineProperty(IsolatedProxyDynamicDataSource.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IsolatedProxyDynamicDataSource.prototype, "metadata", {
        get: function () {
            return this._metadata;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns all the property definitions for dynamic data asynchronously.
     * This needs to be overriden by the implementation of the component.
     *
     * Note: Currently we throw when someone tries to call the api, while there's an outstanding
     * promise on the api. This shouldn't happen in a regular case. However, if we see this happening
     * regularly, then we should handle these scenarios properly, instead of just throwing.
     *
     * @virtual
     */
    IsolatedProxyDynamicDataSource.prototype.getPropertyDefinitionsAsync = function () {
        var _this = this;
        var qosMonitor = new _QosMonitor(QOS_MONITOR_PREFIX + '.getPropertyDefinitions');
        if (this._propertyDefinitions) {
            qosMonitor.writeSuccess();
            return Promise.resolve(this._propertyDefinitions);
        }
        if (this._propertyDefinitionsPromiseResolve) {
            var failureTag = "Calling 'getPropertyDefintions' is not allowed\n      while there's an outstanding promise on the api.";
            qosMonitor.writeUnexpectedFailure(failureTag);
            throw new Error(failureTag);
        }
        return new Promise(function (resolve, reject) {
            IsolatedDynamicDataTransceiver.sendMessage(IsolatedDynamicDataMessageType.GetPropertyDefinitions);
            _SPEventManager.instance.registerEvent(DynamicDataEventNames.getPropertyDefintionsEventName(_this.id), _this, function (data) { return _this.receivePropertyDefinitions(qosMonitor, data); });
            _this._propertyDefinitionsPromiseResolve = resolve;
            _this._propertyDefinitionsPromiseReject = reject;
        });
    };
    /**
     * Api to receive the requested property definitions from the parent window.
     *
     * @param qosMonitor - Qos monitor
     * @param propertyDefintions - List of property definitions.
     */
    IsolatedProxyDynamicDataSource.prototype.receivePropertyDefinitions = function (qosMonitor, data) {
        var _this = this;
        if (!data.errorMessage) {
            this._propertyDefinitions = data.propertyDefintions;
            if (this._propertyDefinitionsPromiseResolve) {
                qosMonitor.writeSuccess();
                this._propertyDefinitionsPromiseResolve(data.propertyDefintions);
            }
        }
        else {
            if (this._propertyDefinitionsPromiseReject) {
                var failureTag = 'Unable to retreive property definitions from the source id:' + this.id;
                qosMonitor.writeUnexpectedFailure(failureTag);
                this._propertyDefinitionsPromiseReject(new Error(failureTag));
            }
        }
        this._propertyDefinitionsPromiseResolve = undefined;
        this._propertyDefinitionsPromiseReject = undefined;
        _SPEventManager.instance.unregisterEvent(DynamicDataEventNames.getPropertyDefintionsEventName(this.id), this, function (pd) { return _this.receivePropertyDefinitions(qosMonitor, pd); });
    };
    /**
     * Given a property id, returns the value of the property asynchronously.
     * This needs to be overriden by the implementation of the component.
     *
     * Note: Currently we throw when someone tries to call the api, while there's an outstanding
     * promise on the api. This shouldn't happen in a regular case. However, if we see this happening
     * regularly, then we should handle these scenarios properly, instead of just throwing.
     *
     * @virtual
     */
    IsolatedProxyDynamicDataSource.prototype.getPropertyValueAsync = function (propertyId) {
        var _this = this;
        var qosMonitor = new _QosMonitor(QOS_MONITOR_PREFIX + '.getAllowedEvents');
        if (this._propertyValueMap.has(propertyId)) {
            qosMonitor.writeSuccess();
            return Promise.resolve(this._propertyValueMap.get(propertyId));
        }
        if (this._propertyValuePromiseResolve) {
            var failureTag = "Calling 'getPropertyValue' is not allowed\n      while there's an outstanding promise on the api.";
            qosMonitor.writeUnexpectedFailure(failureTag);
            throw new Error(failureTag);
        }
        return new Promise(function (// tslint:disable-line:no-any
        resolve, // tslint:disable-line:no-any
        reject) {
            IsolatedDynamicDataTransceiver.sendMessage(IsolatedDynamicDataMessageType.GetPropertyValue);
            _SPEventManager.instance.registerEvent(DynamicDataEventNames.getPropertyValueEventName(_this.id, propertyId), _this, function (message) { return _this.receivePropertyValue(qosMonitor, message); });
            _this._propertyValuePromiseResolve = resolve;
            _this._propertyValuePromiseReject = reject;
        });
    };
    /**
     * Api to receive the requested value for the property id from the source in the parent window.
     *
     * @param qosMonitor - Qos monitor.
     * @param propertyValue - Property value.
     */
    IsolatedProxyDynamicDataSource.prototype.receivePropertyValue = function (qosMonitor, message) {
        var _this = this;
        var data = message.data;
        if (!data.errorMessage) {
            this._propertyValueMap.set(data.propertyId, data.propertyValue);
            if (this._propertyValuePromiseResolve) {
                qosMonitor.writeSuccess();
                this._propertyValuePromiseResolve(data.propertyValue);
            }
        }
        else {
            if (this._propertyValuePromiseReject) {
                var failureTag = 'Unable to get the property value for the property id: ' + data.propertyId;
                qosMonitor.writeUnexpectedFailure(failureTag);
                this._propertyValuePromiseReject(new Error(failureTag));
            }
        }
        this._propertyValuePromiseResolve = undefined;
        this._propertyValuePromiseReject = undefined;
        _SPEventManager.instance.unregisterEvent(DynamicDataEventNames.getPropertyValueEventName(this.id, data.propertyId), this, function (msg) { return _this.receivePropertyValue(qosMonitor, msg); });
    };
    /**
     * Given a property id, returns its annotated value asynchronously.
     * If the source doesn't supply the annotated value, then it falls back to whatever
     * 'getPropertyValue' as the sample value and metadata would be undefined.
     *
     * @param propertyId - One of the property ids exposed from the dynamic data source.
     *
     * Note: Currently we throw when someone tries to call the api, while there's an outstanding
     * promise on the api. This shouldn't happen in a regular case. However, if we see this happening
     * regularly, then we should handle these scenarios properly, instead of just throwing.
     *
     * @virtual
     */
    IsolatedProxyDynamicDataSource.prototype.getAnnotatedPropertyValueAsync = function (propertyId) {
        var _this = this;
        var qosMonitor = new _QosMonitor(QOS_MONITOR_PREFIX + '.getAnnotatedPropertyValue');
        if (this._annotatedPropertyValueMap.has(propertyId)) {
            qosMonitor.writeSuccess();
            return Promise.resolve(this._annotatedPropertyValueMap.get(propertyId));
        }
        if (this._annotatedPropertyValuePromiseResolve) {
            var failureTag = "Calling 'getAnnotatedPropertyValue' is not allowed\n      while there's an outstanding promise on the api.";
            qosMonitor.writeUnexpectedFailure(failureTag);
            throw new Error(failureTag);
        }
        return new Promise(function (resolve, reject) {
            IsolatedDynamicDataTransceiver.sendMessage(IsolatedDynamicDataMessageType.GetAnnotatedPropertyValue);
            _SPEventManager.instance.registerEvent(DynamicDataEventNames.getPropertyValueEventName(_this.id, propertyId, true), _this, function (message) { return _this.receiveAnnoatedPropertyValue(qosMonitor, message); });
            _this._annotatedPropertyValuePromiseResolve = resolve;
            _this._annotatedPropertyValuePromiseReject = reject;
        });
    };
    /**
     * Api to receive the requested annotated value for the property id from the source in the parent window.
     *
     * @param qosMonitor - Qos monitor.
     * @param propertyValue - Property value.
     */
    IsolatedProxyDynamicDataSource.prototype.receiveAnnoatedPropertyValue = function (qosMonitor, message) {
        var _this = this;
        var data = message.data;
        if (!data.errorMessage) {
            this._annotatedPropertyValueMap.set(data.propertyId, data.propertyValue);
            if (this._annotatedPropertyValuePromiseResolve) {
                qosMonitor.writeSuccess();
                this._annotatedPropertyValuePromiseResolve(data.propertyValue);
            }
        }
        else {
            if (this._annotatedPropertyValuePromiseReject) {
                var failureTag = 'Unable to get the annotated property value for the proeprty id: ' + data.propertyId;
                qosMonitor.writeUnexpectedFailure(failureTag);
                this._annotatedPropertyValuePromiseReject(new Error(failureTag));
            }
        }
        this._annotatedPropertyValuePromiseResolve = undefined;
        this._annotatedPropertyValuePromiseReject = undefined;
        _SPEventManager.instance.unregisterEvent(DynamicDataEventNames.getPropertyValueEventName(this.id, data.propertyId, true), this, function (msg) { return _this.receiveAnnoatedPropertyValue(qosMonitor, msg); });
    };
    /**
     * Returns list of allowed events on the dynamic data source asynchronously.
     * When this api returns a non-empty result, then source must define 'sendData' api.
     *
     * If this api is not defined or returns an empty map, then no consumer will be able
     * to talk to this source.
     *
     * Note: Currently we throw when someone tries to call the api, while there's an outstanding
     * promise on the api. This shouldn't happen in a regular case. However, if we see this happening
     * regularly, then we should handle these scenarios properly, instead of just throwing.
     *
     * @virtual
     */
    IsolatedProxyDynamicDataSource.prototype.allowedEventsAsync = function () {
        var _this = this;
        var qosMonitor = new _QosMonitor(QOS_MONITOR_PREFIX + '.getAllowedEvents');
        if (this._allowedEvents) {
            qosMonitor.writeSuccess();
            return Promise.resolve(this._allowedEvents);
        }
        if (this._allowedEventsResolve) {
            var failureTag = "Calling 'getAllowedEvents' is not allowed\n      while there's an outstanding promise on the api.";
            qosMonitor.writeUnexpectedFailure(failureTag);
            throw new Error(failureTag);
        }
        return new Promise(function (resolve, reject) {
            IsolatedDynamicDataTransceiver.sendMessage(IsolatedDynamicDataMessageType.AllowedEvents);
            _SPEventManager.instance.registerEvent(DynamicDataEventNames.getAllowedEventsEventName(_this.id), _this, function (message) { return _this.receiveAllowedEvents(qosMonitor, message); });
            _this._allowedEventsResolve = resolve;
            _this._allowedEventsPromiseReject = reject;
        });
    };
    /**
     * Api to receive the requested allowed events from the source in the parent window.
     *
     * @param qosMonitor - Qos monitor.
     * @param allowedEvents - List of allowed events on the source.
     */
    IsolatedProxyDynamicDataSource.prototype.receiveAllowedEvents = function (qosMonitor, message) {
        var _this = this;
        var data = message.data;
        if (!data.errorMessage) {
            this._allowedEvents = data.allowedEvents;
            if (this._allowedEventsResolve) {
                qosMonitor.writeSuccess();
                this._allowedEventsResolve(data.allowedEvents);
            }
        }
        else {
            if (this._allowedEventsPromiseReject) {
                var failureTag = 'Unable to get the allowed events on the source id:' + this.id;
                qosMonitor.writeUnexpectedFailure(failureTag);
                this._allowedEventsPromiseReject(new Error(failureTag));
            }
        }
        this._allowedEventsResolve = undefined;
        this._allowedEventsPromiseReject = undefined;
        _SPEventManager.instance.unregisterEvent(DynamicDataEventNames.getAllowedEventsEventName(this.id), this, function (msg) { return _this.receiveAllowedEvents(qosMonitor, msg); });
    };
    /**
     * {@inheritdoc IDynamicDataSource.getPropertyDefinitions}
     */
    IsolatedProxyDynamicDataSource.prototype.getPropertyDefinitions = function () {
        return [];
    };
    /**
     * {@inheritdoc IDynamicDataSource.getPropertyValue}
     */
    IsolatedProxyDynamicDataSource.prototype.getPropertyValue = function (propertyId) {
        return undefined;
    };
    /**
     * {@inheritdoc IDynamicDataSource.getAnnotatedPropertyValue}
     */
    IsolatedProxyDynamicDataSource.prototype.getAnnotatedPropertyValue = function (propertyId) {
        return undefined;
    };
    IsolatedProxyDynamicDataSource.prototype.dispose = function () {
        this.isDisposed = true;
    };
    return IsolatedProxyDynamicDataSource;
}());
export { IsolatedProxyDynamicDataSource };
//# sourceMappingURL=IsolatedProxyDynamicDataSource.js.map