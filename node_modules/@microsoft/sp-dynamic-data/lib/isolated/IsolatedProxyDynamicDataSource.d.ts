import { IDynamicDataSource } from '../interfaces/IDynamicDataSource';
import { IDynamicDataSourceMetadata } from '../interfaces/IDynamicDataSourceMetadata';
import { IDynamicDataPropertyDefinition } from '../interfaces/IDynamicDataPropertyDefinition';
import { IIsolatedDynamicDataPropertyDefinitions } from './IIsolatedDynamicDataMessageData';
import { IDynamicDataAnnotatedPropertyValue } from '../interfaces/IDynamicDataAnnotatedPropertyValue';
import { IDynamicDataEventDefinition } from '../interfaces/IDynamicDataEventDefinition';
import { ISPEventObserver } from '@microsoft/sp-core-library';
import { IIsolatedDynamicDataMessage } from './IIsolatedDynamicDataMessage';
import { _QosMonitor } from '@microsoft/sp-diagnostics';
/**
 * A proxy dyanmic data source created in the isolated environment. This class is responsible
 * for adding proxy async apis on the source, which are responsible for making sending PostMessages
 * to the parent window and get the information back.
 *
 * @internal
 */
export declare class IsolatedProxyDynamicDataSource implements IDynamicDataSource, ISPEventObserver {
    /**
     * Added the below 3 dummy public properties to make this class extend ISPEventObserver.
     * @internal
     */
    instanceId: string;
    componentId: string;
    isDisposed: boolean;
    private _id;
    private _metadata;
    private _propertyDefinitions;
    private _propertyDefinitionsPromiseResolve;
    private _propertyDefinitionsPromiseReject;
    private _propertyValueMap;
    private _propertyValuePromiseResolve;
    private _propertyValuePromiseReject;
    private _annotatedPropertyValueMap;
    private _annotatedPropertyValuePromiseResolve;
    private _annotatedPropertyValuePromiseReject;
    private _allowedEvents;
    private _allowedEventsResolve;
    private _allowedEventsPromiseReject;
    constructor(source: IDynamicDataSource);
    readonly id: string;
    readonly metadata: IDynamicDataSourceMetadata;
    /**
     * Returns all the property definitions for dynamic data asynchronously.
     * This needs to be overriden by the implementation of the component.
     *
     * Note: Currently we throw when someone tries to call the api, while there's an outstanding
     * promise on the api. This shouldn't happen in a regular case. However, if we see this happening
     * regularly, then we should handle these scenarios properly, instead of just throwing.
     *
     * @virtual
     */
    getPropertyDefinitionsAsync(): Promise<ReadonlyArray<IDynamicDataPropertyDefinition>>;
    /**
     * Api to receive the requested property definitions from the parent window.
     *
     * @param qosMonitor - Qos monitor
     * @param propertyDefintions - List of property definitions.
     */
    receivePropertyDefinitions(qosMonitor: _QosMonitor, data: IIsolatedDynamicDataPropertyDefinitions): void;
    /**
     * Given a property id, returns the value of the property asynchronously.
     * This needs to be overriden by the implementation of the component.
     *
     * Note: Currently we throw when someone tries to call the api, while there's an outstanding
     * promise on the api. This shouldn't happen in a regular case. However, if we see this happening
     * regularly, then we should handle these scenarios properly, instead of just throwing.
     *
     * @virtual
     */
    getPropertyValueAsync(propertyId: string): Promise<any>;
    /**
     * Api to receive the requested value for the property id from the source in the parent window.
     *
     * @param qosMonitor - Qos monitor.
     * @param propertyValue - Property value.
     */
    receivePropertyValue(qosMonitor: _QosMonitor, message: IIsolatedDynamicDataMessage): void;
    /**
     * Given a property id, returns its annotated value asynchronously.
     * If the source doesn't supply the annotated value, then it falls back to whatever
     * 'getPropertyValue' as the sample value and metadata would be undefined.
     *
     * @param propertyId - One of the property ids exposed from the dynamic data source.
     *
     * Note: Currently we throw when someone tries to call the api, while there's an outstanding
     * promise on the api. This shouldn't happen in a regular case. However, if we see this happening
     * regularly, then we should handle these scenarios properly, instead of just throwing.
     *
     * @virtual
     */
    getAnnotatedPropertyValueAsync(propertyId: string): Promise<IDynamicDataAnnotatedPropertyValue>;
    /**
     * Api to receive the requested annotated value for the property id from the source in the parent window.
     *
     * @param qosMonitor - Qos monitor.
     * @param propertyValue - Property value.
     */
    receiveAnnoatedPropertyValue(qosMonitor: _QosMonitor, message: IIsolatedDynamicDataMessage): void;
    /**
     * Returns list of allowed events on the dynamic data source asynchronously.
     * When this api returns a non-empty result, then source must define 'sendData' api.
     *
     * If this api is not defined or returns an empty map, then no consumer will be able
     * to talk to this source.
     *
     * Note: Currently we throw when someone tries to call the api, while there's an outstanding
     * promise on the api. This shouldn't happen in a regular case. However, if we see this happening
     * regularly, then we should handle these scenarios properly, instead of just throwing.
     *
     * @virtual
     */
    allowedEventsAsync?(): Promise<ReadonlyArray<IDynamicDataEventDefinition>>;
    /**
     * Api to receive the requested allowed events from the source in the parent window.
     *
     * @param qosMonitor - Qos monitor.
     * @param allowedEvents - List of allowed events on the source.
     */
    receiveAllowedEvents(qosMonitor: _QosMonitor, message: IIsolatedDynamicDataMessage): void;
    /**
     * {@inheritdoc IDynamicDataSource.getPropertyDefinitions}
     */
    getPropertyDefinitions(): ReadonlyArray<IDynamicDataPropertyDefinition>;
    /**
     * {@inheritdoc IDynamicDataSource.getPropertyValue}
     */
    getPropertyValue(propertyId: string): any;
    /**
     * {@inheritdoc IDynamicDataSource.getAnnotatedPropertyValue}
     */
    getAnnotatedPropertyValue(propertyId: string): any;
    dispose(): void;
}
//# sourceMappingURL=IsolatedProxyDynamicDataSource.d.ts.map