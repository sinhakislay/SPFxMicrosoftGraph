import { SPEvent, Text, Validate, _SPEventManager } from '@microsoft/sp-core-library';
import { _LogSource, _TraceLogger, _QosMonitor } from '@microsoft/sp-diagnostics';
import strings from './loc/Strings.resx';
import { EVENT_NAME_SEPARATOR, SOURCES_CHANGED_EVENT_NAME } from './common/DynamicDataEventConstants';
import { DynamicDataEventNames } from './common/DynamicDataEventNames';
var QOS_MONITOR_PREFIX = 'DynamicData.DynamicDataManager';
var LOG_SOURCE = _LogSource.create('DynamicDataManager');
/**
 * Manager for Dynamic Data.
 * This holds a reference to all Dynamic Data Sources and uses the SPEventManager internally to handle
 * notifications for source updates.
 *
 * @remarks
 * Data sources can notify for changes within the data source or for a specific property.
 * Data consumers can register to both changes in a Dynamic Data source and a specific property within the source.
 * There are 3 events to handle this variety of situations:
 *
 * Notifying a change for a property triggers events for the specific propery and for "any" property
 * Notifying a change for the whole source triggers events for "any" property and "all" properties.
 *
 * Registering for changes in a property register to events for the specific property and "all" properties.
 * Registering for changes in the whole source register to events for "any" properties.
 *
 * This ensures that regardless of how sources and consumers are configured, events will trigger once and only once for
 * each update within the data source.
 *
 * @internal
 */
var DynamicDataManager = /** @class */ (function () {
    function DynamicDataManager(serviceScope) {
        this._sources = new Map();
        this._sourcesChangedEvent = new SPEvent(SOURCES_CHANGED_EVENT_NAME);
    }
    Object.defineProperty(DynamicDataManager.prototype, "sourcesChangedEvent", {
        /**
         * Event that gets raised when the list of Dynamic Data Sources gets updated.
         * @eventproperty
         */
        get: function () {
            return this._sourcesChangedEvent;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Raises an event to all listeners when a Dynamic Data Source has been updated.
     * @param sourceId - Id of the Dynamic Data Source that is being updated.
     */
    DynamicDataManager.prototype.notifySourceChanged = function (sourceId) {
        var qosMonitor = new _QosMonitor(QOS_MONITOR_PREFIX + '.notifySourceChanged');
        try {
            Validate.isNonemptyString(sourceId, 'sourceId');
            _SPEventManager.instance.raiseEvent(DynamicDataEventNames.getAllPropertiesChangedEventName(sourceId), {});
            _SPEventManager.instance.raiseEvent(DynamicDataEventNames.getAnyPropertyChangedEventName(sourceId), {});
            qosMonitor.writeSuccess();
        }
        catch (e) {
            qosMonitor.writeUnexpectedFailure(e);
            throw e;
        }
    };
    /**
     * Raises an event to all listeners when a property in a Dynamic Data Source has been updated.
     * @param sourceId - Id of the Dynamic Data Source whose property is being updated.
     * @param propertyId - Id of the property that is being updated.
     */
    DynamicDataManager.prototype.notifyPropertyChanged = function (sourceId, propertyId) {
        var qosMonitor = new _QosMonitor(QOS_MONITOR_PREFIX + '.notifyPropertyChanged');
        try {
            Validate.isNonemptyString(sourceId, 'sourceId');
            Validate.isNonemptyString(propertyId, 'propertyId');
            _SPEventManager.instance.raiseEvent(DynamicDataEventNames.getPropertyChangedEventName(sourceId, propertyId), {});
            _SPEventManager.instance.raiseEvent(DynamicDataEventNames.getAnyPropertyChangedEventName(sourceId), {});
            qosMonitor.writeSuccess();
        }
        catch (e) {
            qosMonitor.writeUnexpectedFailure(e);
            throw e;
        }
    };
    /**
     * Registers a listener for updates on a Dynamic Data Source.
     */
    DynamicDataManager.prototype.registerSourceChanged = function (sourceId, observer, callback) {
        var extraData = this._createQosExtraData(observer.manifest);
        var qosMonitor = new _QosMonitor(QOS_MONITOR_PREFIX + '.registerSourceChanged');
        try {
            Validate.isNonemptyString(sourceId, 'sourceId');
            Validate.isNotNullOrUndefined(observer, 'observer');
            Validate.isNotNullOrUndefined(callback, 'callback');
            if (!this._sources.has(sourceId)) {
                throw new Error(Text.format(strings.dynamicDataManagerSourceDoesntExist, sourceId));
            }
            // Registering to all properties changed event.
            _SPEventManager.instance.registerEvent(DynamicDataEventNames.getAllPropertiesChangedEventName(sourceId), observer, callback);
            // Registering to any property changed event, as it means that the source is changed.
            _SPEventManager.instance.registerEvent(DynamicDataEventNames.getAnyPropertyChangedEventName(sourceId), observer, callback);
            qosMonitor.writeSuccess(extraData);
        }
        catch (e) {
            qosMonitor.writeUnexpectedFailure('UnhandledRegisterSourceChange', e, extraData);
            throw e;
        }
    };
    /**
     * Unregisters a listener for updates on a Dynamic Data Source.
     */
    DynamicDataManager.prototype.unregisterSourceChanged = function (sourceId, observer, callback) {
        var extraData = this._createQosExtraData(observer.manifest);
        var qosMonitor = new _QosMonitor(QOS_MONITOR_PREFIX + '.unregisterSourceChanged');
        try {
            Validate.isNonemptyString(sourceId, 'sourceId');
            Validate.isNotNullOrUndefined(observer, 'observer');
            Validate.isNotNullOrUndefined(callback, 'callback');
            if (!this._sources.has(sourceId)) {
                throw new Error(Text.format(strings.dynamicDataManagerSourceDoesntExist, sourceId));
            }
            _SPEventManager.instance.unregisterEvent(DynamicDataEventNames.getAllPropertiesChangedEventName(sourceId), observer, callback);
            _SPEventManager.instance.unregisterEvent(DynamicDataEventNames.getAnyPropertyChangedEventName(sourceId), observer, callback);
            qosMonitor.writeSuccess(extraData);
        }
        catch (e) {
            qosMonitor.writeUnexpectedFailure('UnhandledUnregisterSourceChange', e, extraData);
            throw e;
        }
    };
    /**
     * Registers a listener for updates on a Dynamic Data Source.
     */
    DynamicDataManager.prototype.registerPropertyChanged = function (sourceId, propertyId, observer, callback) {
        var extraData = this._createQosExtraData(observer.manifest);
        var qosMonitor = new _QosMonitor(QOS_MONITOR_PREFIX + '.registerPropertyChanged');
        try {
            Validate.isNonemptyString(sourceId, 'sourceId');
            Validate.isNonemptyString(propertyId, 'propertyId');
            Validate.isNotNullOrUndefined(observer, 'observer');
            Validate.isNotNullOrUndefined(callback, 'callback');
            if (!this._sources.has(sourceId)) {
                throw new Error(Text.format(strings.dynamicDataManagerSourceDoesntExist, sourceId));
            }
            // Registering to the specific property
            _SPEventManager.instance.registerEvent(DynamicDataEventNames.getPropertyChangedEventName(sourceId, propertyId), observer, callback);
            // Registering to all properties changed event, as the specific property will also be changed.
            _SPEventManager.instance.registerEvent(DynamicDataEventNames.getAllPropertiesChangedEventName(sourceId), observer, callback);
            qosMonitor.writeSuccess(extraData);
        }
        catch (e) {
            qosMonitor.writeUnexpectedFailure('UnhandledRegisterPropertyChange', e, extraData);
            throw e;
        }
    };
    /**
     * Unregisters a listener for updates on a Dynamic Data Source.
     */
    DynamicDataManager.prototype.unregisterPropertyChanged = function (sourceId, propertyId, observer, callback) {
        var extraData = this._createQosExtraData(observer.manifest);
        var qosMonitor = new _QosMonitor(QOS_MONITOR_PREFIX + '.unregisterPropertyChanged');
        try {
            Validate.isNonemptyString(sourceId, 'sourceId');
            Validate.isNonemptyString(propertyId, 'propertyId');
            Validate.isNotNullOrUndefined(observer, 'observer');
            Validate.isNotNullOrUndefined(callback, 'callback');
            if (!this._sources.has(sourceId)) {
                throw new Error(Text.format(strings.dynamicDataManagerSourceDoesntExist, sourceId));
            }
            _SPEventManager.instance.unregisterEvent(DynamicDataEventNames.getPropertyChangedEventName(sourceId, propertyId), observer, callback);
            _SPEventManager.instance.unregisterEvent(DynamicDataEventNames.getAllPropertiesChangedEventName(sourceId), observer, callback);
            qosMonitor.writeSuccess(extraData);
        }
        catch (e) {
            qosMonitor.writeUnexpectedFailure('UnhandledUnregisterPropertyChange', e, extraData);
            throw e;
        }
    };
    /**
     * Returns a read-only array with all the existing Dynamic Data Sources.
     */
    DynamicDataManager.prototype.getSources = function () {
        var sources = [];
        this._sources.forEach(function (source) { return sources.push(source); });
        return sources;
    };
    /**
     * Returns a Dynamic Data Source based on its id.
     * Returns undefined if the source doesn't exist.
     * @param sourceId - Id of the Dynamic Data Source.
     */
    DynamicDataManager.prototype.tryGetSource = function (sourceId) {
        Validate.isNotNullOrUndefined(sourceId, 'sourceId');
        return this._sources.get(sourceId);
    };
    /**
     * Adds a new Dynamic Data Source to be managed.
     * Throws an error if the source can't be added.
     *
     * @param source - Dynamic Data Source to add.
     */
    DynamicDataManager.prototype.addSource = function (source) {
        var qosMonitor = new _QosMonitor(QOS_MONITOR_PREFIX + '.addSource');
        try {
            this._validateSource(source);
            if (this._sources.has(source.id)) {
                _TraceLogger.logVerbose(LOG_SOURCE, Text.format(strings.dynamicDataManagerSourceAlreadyExists, source.id));
            }
            this._sources.set(source.id, source);
            this._raiseSourcesChangedEvent();
            qosMonitor.writeSuccess();
        }
        catch (e) {
            qosMonitor.writeUnexpectedFailure(e);
            throw e;
        }
    };
    /**
     * Removes an existing Dynamic Data Source from the manager.
     * @param id - Id of the Dynamic Data Source.
     */
    DynamicDataManager.prototype.removeSource = function (sourceId) {
        var qosMonitor = new _QosMonitor(QOS_MONITOR_PREFIX + '.removeSource');
        try {
            Validate.isNonemptyString(sourceId, 'sourceId');
            if (this._sources.has(sourceId)) {
                _SPEventManager.instance.removeEvent(DynamicDataEventNames.getAllPropertiesChangedEventName(sourceId));
                _SPEventManager.instance.removeEvent(DynamicDataEventNames.getAnyPropertyChangedEventName(sourceId));
                _SPEventManager.instance.removeEventsByPrefix(DynamicDataEventNames.getPropertyChangedEventPrefix(sourceId));
                this._sources.delete(sourceId);
                this._raiseSourcesChangedEvent();
            }
            qosMonitor.writeSuccess();
        }
        catch (e) {
            qosMonitor.writeUnexpectedFailure(e);
            throw e;
        }
    };
    /**
     * Creates a new extra data object _IQosExtraData.
    */
    DynamicDataManager.prototype._createQosExtraData = function (manifest) {
        if (!manifest) {
            return undefined;
        }
        var qosExtraData = {
            alias: manifest.alias,
            isInternal: manifest.isInternal,
            manifestId: manifest.id
        };
        return qosExtraData;
    };
    DynamicDataManager.prototype._validateSource = function (source) {
        Validate.isNotNullOrUndefined(source, 'source');
        if (source.id.indexOf(EVENT_NAME_SEPARATOR) > -1) {
            throw new Error("Source id contains invalid characters, like \"" + EVENT_NAME_SEPARATOR + "\". Id: \"" + source.id + "\".");
        }
        var regex = /^[a-zA-Z0-9\-_]+$/;
        source.getPropertyDefinitions().forEach(function (def) {
            if (!regex.test(def.id)) {
                throw new Error("Source contains invalid property \"" + def.id + "\".");
            }
        });
    };
    /**
     * Raises an event when the Dynamic Data Sources gets updated.
     * @remarks
     * The event is sticky because sources can be updated before there is anyone listening. This way all clients
     * will get notified that sources have been updated. Further updates are notified in real-time.
     */
    DynamicDataManager.prototype._raiseSourcesChangedEvent = function () {
        _SPEventManager.instance.raiseStickyEvent(SOURCES_CHANGED_EVENT_NAME, {});
    };
    return DynamicDataManager;
}());
export default DynamicDataManager;
//# sourceMappingURL=DynamicDataManager.js.map