"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const os_1 = require("os");
const gulp_core_build_1 = require("@microsoft/gulp-core-build");
const load_themed_styles_1 = require("@microsoft/load-themed-styles");
const node_core_library_1 = require("@microsoft/node-core-library");
const glob = require("glob");
const nodeSass = require("node-sass");
const postcss = require("postcss");
const CleanCss = require("clean-css");
const autoprefixer = require("autoprefixer");
const CSSModules_1 = require("./CSSModules");
class SassTask extends gulp_core_build_1.GulpTask {
    constructor() {
        super('sass', {
            preamble: '/* tslint:disable */',
            postamble: '/* tslint:enable */',
            sassMatch: [
                'src/**/*.scss',
                'src/**/*.sass'
            ],
            useCSSModules: false,
            warnOnCssInvalidPropertyName: true,
            dropCssFiles: false,
            warnOnNonCSSModules: false
        });
        this.cleanMatch = [
            'src/**/*.sass.ts',
            'src/**/*.scss.ts'
        ];
        this._postCSSPlugins = [
            autoprefixer({ browsers: ['> 1%', 'last 2 versions', 'ie >= 10'] })
        ];
    }
    loadSchema() {
        return node_core_library_1.JsonFile.load(path.join(__dirname, 'sass.schema.json'));
    }
    executeTask(gulp) {
        if (!this.taskConfig.sassMatch) {
            return Promise.reject(new Error('taskConfig.sassMatch must be defined'));
        }
        return this._globAll(...this.taskConfig.sassMatch).then((matches) => {
            return Promise.all(matches.map((match) => this._processFile(match)));
        }).then(() => { });
    }
    _processFile(filePath) {
        // Ignore files that start with underscores
        if (path.basename(filePath).match(/^\_/)) {
            return Promise.resolve();
        }
        const isFileModuleCss = !!filePath.match(/\.module\.s(a|c)ss/);
        const processAsModuleCss = isFileModuleCss || !!this.taskConfig.useCSSModules;
        const cssModules = new CSSModules_1.default(this.buildConfig.rootPath);
        if (!processAsModuleCss && this.taskConfig.warnOnNonCSSModules) {
            const relativeFilePath = path.relative(this.buildConfig.rootPath, filePath);
            this.logWarning(`${relativeFilePath}: filename should end with module.sass or module.scss`);
        }
        let cssOutputPath = undefined;
        let cssOutputPathAbsolute = undefined;
        if (this.taskConfig.dropCssFiles) {
            const srcRelativePath = path.relative(path.join(this.buildConfig.rootPath, this.buildConfig.srcFolder), filePath);
            cssOutputPath = path.join(this.buildConfig.libFolder, srcRelativePath);
            cssOutputPath = cssOutputPath.replace(/\.s(c|a)ss$/, '.css');
            cssOutputPathAbsolute = path.join(this.buildConfig.rootPath, cssOutputPath);
        }
        return node_core_library_1.LegacyAdapters.convertCallbackToPromise(nodeSass.render, {
            file: filePath,
            importer: (url) => ({ file: this._patchSassUrl(url) }),
            sourceMap: this.taskConfig.dropCssFiles,
            sourceMapContents: true,
            omitSourceMapUrl: true,
            outFile: cssOutputPath
        }).catch((error) => {
            this.fileError(filePath, error.line, error.column, error.name, error.message);
            throw new Error(error.message);
        }).then((result) => {
            const options = {
                from: filePath
            };
            if (result.map && !this.buildConfig.production) {
                options.map = {
                    prev: result.map.toString() // Pass the source map through to postcss
                };
            }
            const plugins = [...this._postCSSPlugins];
            if (processAsModuleCss) {
                plugins.push(cssModules.getPlugin());
            }
            return postcss(plugins).process(result.css.toString(), options);
        }).then((result) => {
            let cleanCssOptions = { level: 1, returnPromise: true };
            if (!!this.taskConfig.cleanCssOptions) {
                cleanCssOptions = Object.assign({}, this.taskConfig.cleanCssOptions, { returnPromise: true });
            }
            cleanCssOptions.sourceMap = !!result.map;
            const cleanCss = new CleanCss(cleanCssOptions);
            return cleanCss.minify(result.css.toString(), result.map ? result.map.toString() : undefined);
        }).then((result) => {
            if (cssOutputPathAbsolute) {
                const generatedFileLines = [
                    result.styles.toString()
                ];
                if (result.sourceMap && !this.buildConfig.production) {
                    const encodedSourceMap = Buffer.from(result.sourceMap.toString()).toString('base64');
                    generatedFileLines.push(`/*# sourceMappingURL=data:application/json;base64,${encodedSourceMap} */`);
                }
                node_core_library_1.FileSystem.writeFile(cssOutputPathAbsolute, generatedFileLines.join(os_1.EOL), { ensureFolderExists: true });
            }
            const scssTsOutputPath = `${filePath}.ts`;
            const classMap = cssModules.getClassMap();
            const stylesExportString = this._getStylesExportString(classMap);
            const content = result.styles;
            let lines = [];
            lines.push(this.taskConfig.preamble || '');
            if (cssOutputPathAbsolute) {
                lines = lines.concat([
                    `require(${JSON.stringify(`./${path.basename(cssOutputPathAbsolute)}`)});`,
                    stylesExportString
                ]);
            }
            else if (!!content) {
                lines = lines.concat([
                    'import { loadStyles } from \'@microsoft/load-themed-styles\';',
                    '',
                    stylesExportString,
                    '',
                    `loadStyles(${JSON.stringify(load_themed_styles_1.splitStyles(content))});`
                ]);
            }
            lines.push(this.taskConfig.postamble || '');
            const generatedTsFile = (lines
                .join(os_1.EOL)
                .replace(new RegExp(`(${os_1.EOL}){3,}`, 'g'), `${os_1.EOL}${os_1.EOL}`)
                .replace(new RegExp(`(${os_1.EOL})+$`, 'm'), os_1.EOL));
            node_core_library_1.FileSystem.writeFile(scssTsOutputPath, generatedTsFile);
        });
    }
    _globAll(...patterns) {
        return Promise.all(patterns.map((pattern) => node_core_library_1.LegacyAdapters.convertCallbackToPromise(glob, path.isAbsolute(pattern) ? pattern : path.join(this.buildConfig.rootPath, pattern)))).then((matchSets) => {
            const result = {};
            for (const matchSet of matchSets) {
                for (const match of matchSet) {
                    const normalizedMatch = path.resolve(match);
                    result[normalizedMatch] = true;
                }
            }
            return Object.keys(result);
        });
    }
    _patchSassUrl(url) {
        if (url[0] === '~') {
            url = 'node_modules/' + url.substr(1);
        }
        else if (url === 'stdin') {
            url = '';
        }
        return url;
    }
    _getStylesExportString(classMap) {
        const classKeys = Object.keys(classMap);
        const styleLines = [];
        classKeys.forEach((key) => {
            const value = classMap[key];
            if (key.indexOf('-') !== -1) {
                const message = `The local CSS class '${key}' is not ` +
                    `camelCase and will not be type-safe.`;
                if (this.taskConfig.warnOnCssInvalidPropertyName) {
                    this.logWarning(message);
                }
                else {
                    this.logVerbose(message);
                }
                key = `'${key}'`;
            }
            styleLines.push(`  ${key}: '${value}'`);
        });
        let exportString = 'export default styles;';
        if (this.taskConfig.moduleExportName === '') {
            exportString = 'export = styles;';
        }
        else if (!!this.taskConfig.moduleExportName) {
            // exportString = `export const ${this.taskConfig.moduleExportName} = styles;`;
        }
        return [
            'const styles = {',
            styleLines.join(`,${os_1.EOL}`),
            '};',
            '',
            exportString
        ].join(os_1.EOL);
    }
}
exports.SassTask = SassTask;
//# sourceMappingURL=SassTask.js.map