import { Validate } from '@microsoft/sp-core-library';
import PlaceholderContent from './PlaceholderContent';
import PlaceholderName from './PlaceholderName';
import { _ComponentBaseKillSwitches } from '@microsoft/sp-component-base';
/**
 * Represents the placeholder div provided by the application
 *
 * @internal
 */
var Placeholder = /** @class */ (function () {
    function Placeholder(definition, manager) {
        // This array is kept ordered by sequence number
        this._entries = [];
        Validate.isNotNullOrUndefined(definition, 'definition');
        Validate.isNotNullOrUndefined(definition.domElement, 'definition.domElement');
        Validate.isNotNullOrUndefined(manager, 'manager');
        this._name = definition.name;
        this._domElement = definition.domElement;
        this._applicationDomElement = undefined;
    }
    Object.defineProperty(Placeholder.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create a new placeholder content for this placeholder
     */
    Placeholder.prototype.createPlaceholderContent = function (sequence, options) {
        // Create a separate browser DOM node to host the third-party placeholder.
        // We found that, if we use a node from the ReactJS virtual DOM tree,
        // and in the child DOM tree the placeholder tries to load a different
        // version of ReactJS, that can break due to compatibility issues between
        // the two different verions of ReactJS.
        var contentDiv = document.createElement('div');
        if (!_ComponentBaseKillSwitches.isAddSpecificityToLegacyWebPartKSActivated()) {
            // We will add legacy css style for all 3rd extensions.
            contentDiv.classList.add('ms-SPLegacyFabricBlock');
        }
        var position = this._addContentDiv(contentDiv, sequence);
        var placeholderContent = new PlaceholderContent({
            placeholder: this,
            sequence: sequence,
            domElement: contentDiv,
            options: options
        });
        this._entries.splice(position, 0, { placeholderContent: placeholderContent, sequence: sequence });
        return placeholderContent;
    };
    Placeholder.prototype.removePlaceholderContent = function (placeholderContent) {
        for (var i = 0; i < this._entries.length; i++) {
            if (this._entries[i].placeholderContent === placeholderContent) {
                this._domElement.removeChild(this._entries[i].placeholderContent.domElement);
                this._entries.splice(i, 1);
                i--; // Because the current element was removed we should keep looking at the same index
            }
        }
    };
    Placeholder.prototype.attachToApplication = function (applicationDomElement) {
        this._applicationDomElement = applicationDomElement;
        this._applicationDomElement.appendChild(this._domElement);
    };
    Placeholder.prototype.detachFromApplication = function () {
        if (this._applicationDomElement) {
            this._applicationDomElement.appendChild(this._domElement);
            this._applicationDomElement = undefined;
        }
    };
    /**
     * Adds the DOM element of a placeholder content in the placeholder DIV element.
     * Returns the position inside of the placeholder where the content was placed.
     *
     * @param domElement - DOM element of the placeholder content
     * @param sequence - Sequence number of the placeholder content
     */
    Placeholder.prototype._addContentDiv = function (domElement, sequence) {
        // Keep the entries ordered by sequence number.
        // Bottom Placeholder is sorted by sequence number
        // in reverse order.
        var i;
        if (this.name === PlaceholderName.Bottom) {
            i = this._entries.length;
            while (i > 0 && sequence > this._entries[i - 1].sequence) {
                i--;
            }
        }
        else {
            i = 0;
            while (i < this._entries.length && sequence >= this._entries[i].sequence) {
                i++;
            }
        }
        if (i < this._entries.length) {
            var nextDiv = this._entries[i].placeholderContent.domElement;
            this._domElement.insertBefore(domElement, nextDiv);
        }
        else {
            this._domElement.appendChild(domElement);
        }
        return i;
    };
    return Placeholder;
}());
export default Placeholder;
//# sourceMappingURL=Placeholder.js.map