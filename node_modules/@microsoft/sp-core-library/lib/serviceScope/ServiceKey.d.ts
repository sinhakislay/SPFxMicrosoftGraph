import ServiceScope from './ServiceScope';
/**
 * This is a callback that is used by ServiceKey.createCustom().
 * @public
 */
export declare type ServiceCreator<T> = (serviceScope: ServiceScope) => T;
/**
 * The ServiceKey is a lookup key that is used when calling {@link ServiceScope.consume}
 * to fetch a dependency.
 *
 * @remarks
 * Every service key also provides a default implementation of the dependency, which will
 * be automatically created in the root scope if the dependency is not found.  Providing a default
 * implementation ensures that new dependencies can be safely introduced without inadvertently
 * breaking components that are loaded by an older host that does not provide the new dependency.
 *
 * @public
 */
export default class ServiceKey<T> {
    /**
     * A unique identifier for this service key.
     *
     * @remarks
     * This identifier is an automatically generated string that will be unique for the lifetime
     * of the page.  Callers should not make assumptions about the formatting of this string.  It is
     * currently based on a global counter, but this may change in the future.
     *
     * The ServiceScope uses this identifier internally as a dictionary key for finding services.
     * The ServiceKey is meant to be unique, even if multiple instances of the same library are
     * loaded on the same page, even if the same name was passed to ServiceKey.create().
     * This is because each call to ServiceKey.create() could potentially provide a different
     * defaultCreator implementation, whereas one of the design goals of ServiceScope is that
     * the order in which libraries are loaded should never affect the resulting tree of scopes.
     */
    readonly id: string;
    /**
     * The name of the service.
     *
     * @remarks
     * This name is used for logging and diagnostic purposes only.  To make it unique, the
     * recommended convention is the package name, followed by a period, followed by the
     * class or interface name.
     *
     * The system does not assume that this string is unique.  Instead, the {@link ServiceKey.id}
     * is used wherever a lookup key is needed.
     */
    readonly name: string;
    /**
     * A callback function that constructs the default instance of this service.
     */
    readonly defaultCreator: ServiceCreator<T>;
    /**
     * Constructs a new ServiceKey whose default implementation will be a new instance of
     * a TypeScript class that accepts the standard constructor parameter.
     *
     * @remarks
     * If you want to specify custom constructor parameters, use {@link ServiceKey.createCustom}
     * instead.
     *
     * @param name - A name such as "my-package.IMyService" which should be unique across packages.
     * @param serviceClass - the TypeScript class that implements the service.
     * @returns the newly created ServiceKey
     */
    static create<TKey>(name: string, serviceClass: {
        new (serviceScope: ServiceScope): TKey;
    }): ServiceKey<TKey>;
    /**
     * Constructs a new ServiceKey whose default implementation will be obtained
     * by invoking the specified callback.
     *
     * @param name - A name such as "my-package.IMyService" which should be unique across packages.
     * @param defaultCreator - a callback that returns an object that implements the T interface
     * @returns the newly created service key
     */
    static createCustom<TKey>(name: string, defaultCreator: ServiceCreator<TKey>): ServiceKey<TKey>;
    private constructor();
}
//# sourceMappingURL=ServiceKey.d.ts.map