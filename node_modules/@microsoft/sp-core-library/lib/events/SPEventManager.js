import Validate from '../Validate';
import Text from '../Text';
import Log from '../log/Log';
/**
 * Manager for the eventing system.
 *
 * Allows to register/unregister event handlers to events, and raises those events.
 * The events are identified by its name as a string, and it doesn't provide type safety for the event arguments.
 *
 * There are two types of events: regular and sticky.
 * Sticky events are events that once raised, every listener that subscribed to the event will be automatically
 * executed as if the event was raised.
 * Sticky events are useful for framework-level notification, like when a system is initialized (every listener will
 * know the system is initialized).
 *
 * This is an internal architecture underlying the SPEvent class, which provides a handy way to register and unregister
 * events, and provides the type safety. This class should not be exposed to third-parties directly.
 *
 * @internal
 */
var SPEventManager = /** @class */ (function () {
    function SPEventManager() {
        this._listeners = new Map();
        this._raisedEvents = new Map();
    }
    Object.defineProperty(SPEventManager, "instance", {
        /**
         * Instance of the SPEventManager.
         */
        get: function () {
            if (!this._instance) {
                this._instance = new SPEventManager();
            }
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Raises an event.
     *
     * After this is called, all components registered under the event will execute their callback.
     * @param eventName - Name of the event
     * @param eventArgs - Arguments of the event
     * @alpha
     */
    SPEventManager.prototype.raiseEvent = function (eventName, eventArgs) {
        Validate.isNonemptyString(eventName, 'eventName');
        Validate.isNotNullOrUndefined(eventArgs, 'eventArgs');
        return this._raiseEventInternal(eventName, eventArgs);
    };
    /**
     * Raises a sticky event.
     * Sticky events are stored, so when new listeners are added to the event, they will be immediately notified.
     *
     * After this is called, all components registered under the event will execute their callback.
     * @param eventName - Name of the event
     * @param eventArgs - Arguments of the event
     * @alpha
     */
    SPEventManager.prototype.raiseStickyEvent = function (eventName, eventArgs) {
        Validate.isNonemptyString(eventName, 'eventName');
        Validate.isNotNullOrUndefined(eventArgs, 'eventArgs');
        // Save the last event raised for each event name
        this._raisedEvents.set(eventName, eventArgs);
        return this._raiseEventInternal(eventName, eventArgs);
    };
    /**
     * Registers an event handler for an event.
     * @param eventName - Name of the event to register to.
     * @param observer - Component that is registering the event.
     * @param eventHandler - Function to handle the event.
     */
    SPEventManager.prototype.registerEvent = function (eventName, observer, eventHandler) {
        Validate.isNonemptyString(eventName, 'eventName');
        Validate.isNotNullOrUndefined(observer, 'observer');
        Validate.isNotNullOrUndefined(eventHandler, 'eventHandler');
        if (!this._listeners.has(eventName)) {
            this._listeners.set(eventName, []);
        }
        this._listeners.get(eventName).push({ observer: observer, eventHandler: eventHandler });
        // If an event has been raised and an observer registers later, it will execute the handler
        // This is to support cases when a component gets loaded after the page loads, so they can know
        // the page had a navigation, and potentially placeholders were already set up.
        if (this._raisedEvents.has(eventName)) {
            eventHandler.call(observer, this._raisedEvents.get(eventName));
        }
    };
    /**
     * Removes an event handler from the event listeners list.
     * The event handler passed as input must be the first one that was used to register to the event.
     *
     * @remarks
     * If this is requested without adding an event handler first, it logs an error.
     *
     * @param eventName - Name of the event to remove the event handler from.
     * @param observer - Component that is deregistering from the event.
     * @param eventHandler - Function to handle the event. Used to remove it from the list of listeners.
     */
    SPEventManager.prototype.unregisterEvent = function (eventName, observer, eventHandler) {
        Validate.isNonemptyString(eventName, 'eventName');
        Validate.isNotNullOrUndefined(observer, 'observer');
        Validate.isNotNullOrUndefined(eventHandler, 'eventHandler');
        if (!this._listeners.has(eventName)) {
            return;
        }
        var listeners = this._listeners.get(eventName);
        var filteredListeners = listeners.filter(function (el) { return el.observer !== observer || el.eventHandler !== eventHandler; });
        if (filteredListeners.length === listeners.length) {
            var errorMessage = Text.format(
            // TODO VSO:#394928 Localize error messages
            'Failed to remove event handler for component "{0}". Event handler was not registered.', observer.componentId);
            Log.error(SPEventManager._logSource, new Error(errorMessage));
        }
        this._listeners.set(eventName, filteredListeners);
    };
    /**
     * Removes all information from an event from the Event Manager, including all listeners.
     *
     * @param eventName - Name of the event to remove.
     */
    SPEventManager.prototype.removeEvent = function (eventName) {
        Validate.isNonemptyString(eventName, 'eventName');
        this._listeners.delete(eventName);
    };
    /**
     * Removes all information for all events whose id starts with the provided prefix from the Event Manager.
     * This removes all listeners for all events that match.
     *
     * @param eventNamePrefix - Prefix for the event names.
     */
    SPEventManager.prototype.removeEventsByPrefix = function (eventNamePrefix) {
        var _this = this;
        Validate.isNonemptyString(eventNamePrefix, 'eventNamePrefix');
        var matchedKeys = [];
        this._listeners.forEach(function (value, key) {
            if (key.indexOf(eventNamePrefix) === 0) {
                matchedKeys.push(key);
            }
        });
        matchedKeys.forEach(function (key) { return _this._listeners.delete(key); });
    };
    /**
     * Returns the number of listeners for a particular event
     *
     * @internal
     */
    SPEventManager.prototype._listenerCount = function (eventName) {
        if (!this._listeners.has(eventName)) {
            return 0;
        }
        return this._listeners.get(eventName).length;
    };
    /**
     * Private function to raise an event.
     * This include the shared functionality between raising sticky and regular events.
     *
     * After this is called, all components registered under the event will execute their callback.
     * @param eventName - Name of the event
     * @param eventArgs - Arguments of the event
     */
    SPEventManager.prototype._raiseEventInternal = function (eventName, eventArgs) {
        var _this = this;
        if (!this._listeners.has(eventName)) {
            return;
        }
        this._listeners.get(eventName).forEach(function (listener) {
            if (listener.observer.isDisposed) {
                _this.unregisterEvent(eventName, listener.observer, listener.eventHandler);
            }
            else {
                try {
                    listener.eventHandler.call(listener.observer, eventArgs);
                }
                catch (e) {
                    var errorMessage = Text.format(
                    // TODO VSO:#394928 Localize error messages
                    'Failed to execute event handler for component "{0}"', listener.observer.componentId);
                    Log.error(SPEventManager._logSource, new Error(errorMessage));
                }
            }
        });
    };
    SPEventManager._logSource = 'SPEventManager';
    return SPEventManager;
}());
export default SPEventManager;
//# sourceMappingURL=SPEventManager.js.map