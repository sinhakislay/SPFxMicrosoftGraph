define(["require", "exports", "tslib", "react", "@uifabric/merge-styles", "./customizations/Customizations", "./customizations/CustomizerContext"], function (require, exports, tslib_1, React, merge_styles_1, Customizations_1, CustomizerContext_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DefaultFields = ['theme', 'styles'];
    /**
     * The styled HOC wrapper allows you to create a functional wrapper around a given component which will resolve
     * getStyles functional props, and mix customized props passed in using concatStyleSets.
     *
     * @example
     * ```tsx
     * export const Toggle = styled(
     *   ToggleBase,
     *   props => ({ root: { background: 'red' }})
     * );
     * ```
     * @param Component - The unstyled base component to render, which receives styles.
     * @param baseStyles - The styles which should be curried with the component.
     * @param getProps - A helper which provides default props.
     * @param customizable - An object which defines which props can be customized using the Customizer.
     * @param pure - A boolean indicating if the component should avoid re-rendering when props haven't changed.
     * Note that pure should not be used on components which allow children, or take in complex objects or
     * arrays as props which could mutate on every render.
     */
    function styled(Component, baseStyles, getProps, customizable, pure) {
        customizable = customizable || { scope: '', fields: undefined };
        var scope = customizable.scope, _a = customizable.fields, fields = _a === void 0 ? DefaultFields : _a;
        var ParentComponent = pure ? React.PureComponent : React.Component;
        var Wrapped = /** @class */ (function (_super) {
            tslib_1.__extends(Wrapped, _super);
            function Wrapped() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._inCustomizerContext = false;
                _this._renderContent = function (context) {
                    _this._inCustomizerContext = !!context.customizations.inCustomizerContext;
                    var settings = Customizations_1.Customizations.getSettings(fields, scope, context.customizations);
                    var customizedStyles = settings.styles, dir = settings.dir, rest = tslib_1.__rest(settings, ["styles", "dir"]);
                    var additionalProps = getProps ? getProps(_this.props) : undefined;
                    _this._updateStyles(customizedStyles);
                    return React.createElement(Component, tslib_1.__assign({}, rest, additionalProps, _this.props, { styles: _this._styles }));
                };
                _this._onSettingsChanged = function () { return _this.forceUpdate(); };
                return _this;
            }
            Wrapped.prototype.render = function () {
                return React.createElement(CustomizerContext_1.CustomizerContext.Consumer, null, this._renderContent);
            };
            Wrapped.prototype.componentDidMount = function () {
                if (!this._inCustomizerContext) {
                    Customizations_1.Customizations.observe(this._onSettingsChanged);
                }
            };
            Wrapped.prototype.componentWillUnmount = function () {
                if (!this._inCustomizerContext) {
                    Customizations_1.Customizations.unobserve(this._onSettingsChanged);
                }
            };
            Wrapped.prototype._updateStyles = function (customizedStyles) {
                var _this = this;
                // tslint:disable-next-line:no-any
                if (!this._styles || customizedStyles !== this._styles.__cachedInputs__[1] || !!this.props.styles) {
                    // Cache the customized styles.
                    // this._customizedStyles = customizedStyles;
                    // Using styled components as the Component arg will result in nested styling arrays.
                    this._styles = function (styleProps) { return merge_styles_1.concatStyleSetsWithProps(styleProps, baseStyles, customizedStyles, _this.props.styles); };
                    // The __cachedInputs__ array is attached to the function and consumed by the
                    // classNamesFunction as a list of keys to include for memoizing classnames.
                    // tslint:disable-next-line:no-any
                    this._styles.__cachedInputs__ = [baseStyles, customizedStyles, this.props.styles];
                }
            };
            // Function.prototype.name is an ES6 feature, so the cast to any is required until we're
            // able to drop IE 11 support and compile with ES6 libs
            // tslint:disable-next-line:no-any
            Wrapped.displayName = "Styled" + (Component.displayName || Component.name);
            return Wrapped;
        }(ParentComponent));
        // This preserves backwards compatibility.
        // tslint:disable-next-line:no-any
        return Wrapped;
    }
    exports.styled = styled;
});
//# sourceMappingURL=styled.js.map