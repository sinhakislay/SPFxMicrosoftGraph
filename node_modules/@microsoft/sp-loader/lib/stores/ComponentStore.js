/**
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * @file ComponentStore.ts
 */
import { Validate } from '@microsoft/sp-core-library';
import { _TraceLogger } from '@microsoft/sp-diagnostics';
import { componentStoreLogSource as logSource } from './../utilities/telemetryConstants';
import normalizeComponentId from './../utilities/normalizeComponentId';
import { Text } from '@microsoft/sp-core-library';
import strings from './Stores.resx';
/**
 * Stores component modules by id and version.
 * Used by the component loader to retrieve already loaded components.
 */
var ComponentStore = /** @class */ (function () {
    function ComponentStore() {
        this._componentMap = new Map(); // tslint:disable-line:no-any
        /**
         * References to the resolved value of the promises in the _componentMap.
         */
        this._componentReferenceMap = new Map(); // tslint:disable-line:no-any
    }
    Object.defineProperty(ComponentStore, "instance", {
        get: function () {
            if (!ComponentStore._instance) {
                ComponentStore._instance = new ComponentStore();
            }
            return ComponentStore._instance;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a promise of the component module by id and version.
     *
     * If the component is not found, returns undefined.
     */
    ComponentStore.prototype.tryGetComponent = function (id, version) {
        Validate.isNonemptyString(id, 'id');
        Validate.isNonemptyString(version, 'version');
        return this._componentMap.get(this._getKey(id, version));
    };
    /**
     * Try and get a reference to a loaded component module by id and version.
     *
     * @param id - The component manifest id.
     * @param version - The component manifest version.
     * @returns A reference to a component module by id and version or, if it does not exist, undefined.
     */
    ComponentStore.prototype.tryGetComponentReference = function (id, version) {
        Validate.isNonemptyString(id, 'id');
        Validate.isNonemptyString(version, 'version');
        return this._componentReferenceMap.get(this._getKey(id, version));
    };
    /**
     * Returns the maps with all the loaded component.
     *
     * @remarks
     * This is not meant to be used as the regular behavior of ComponentStore as it's exposing its internals.
     * This exists only to ensure the SystemJS side-loader knows about all components loaded by RequireJS.
     */
    ComponentStore.prototype.getAllComponentReferences = function () {
        return this._componentReferenceMap;
    };
    /**
     * Returns a promise of the component module by id.
     *
     * If a component is not found, returns undefined.
     * If there are too many components for the id, returns undefined.
     *
     * Don't use this method, use getComponent() instead.
     * This method is only used by the DeveloperToolsLoader for react and office-ui-fabric-react
     * when those haven't been loaded yet, as the version might not be known at the time.
     */
    ComponentStore.prototype.tryGetComponentById = function (id, shouldLog) {
        if (shouldLog === void 0) { shouldLog = true; }
        try {
            return this._getComponentById(id, shouldLog);
        }
        catch (e) {
            return undefined;
        }
    };
    /**
     * Returns a promise of the component module by id.
     *
     * If a component is not found, throws an error.
     * If there are too many components for the id, throws an error.
     *
     * Don't use this method, use getComponent() instead.
     * This method is only used by the DeveloperToolsLoader for react and office-ui-fabric-react
     * when those haven't been loaded yet, as the version might not be known at the time.
     */
    ComponentStore.prototype.getComponentById = function (id) {
        return this._getComponentById(id, true);
    };
    /**
     * Stores a component module.
     *
     * @param id - Component id
     * @param version - Component version
     * @param modulePromise - Promise of the component module, as it might have been not fully loaded yet.
     */
    ComponentStore.prototype.storeComponent = function (id, version, modulePromise) {
        var _this = this;
        Validate.isNonemptyString(id, 'id');
        Validate.isNonemptyString(version, 'version');
        Validate.isNotNullOrUndefined(modulePromise, 'modulePromise');
        var key = this._getKey(id, version);
        if (!this._componentMap.has(key)) {
            // tslint:disable-next-line:no-floating-promises - this can't throw
            modulePromise.then(function (mod) {
                // If deleteComponent has been invoked before this promise could resolve, skip adding the reference
                if (_this._componentMap.has(key)) {
                    _this._componentReferenceMap.set(key, mod);
                }
            });
            this._componentMap.set(key, modulePromise);
        }
    };
    /**
     * Stores an already loaded component module.
     *
     * @param id - Component id
     * @param version - Component version
     * @param modulePromise - Promise of the component module, as it might have been not fully loaded yet.
     */
    ComponentStore.prototype.storeLoadedComponent = function (id, version, module) {
        Validate.isNonemptyString(id, 'id');
        Validate.isNonemptyString(version, 'version');
        Validate.isNotNullOrUndefined(module, 'module');
        var key = this._getKey(id, version);
        if (!this._componentMap.has(key)) {
            this._componentMap.set(key, Promise.resolve(module));
            this._componentReferenceMap.set(key, module);
        }
    };
    /**
     * Deletes a component from the store, if it exists.
     *
     * @param id - Component id
     * @param version - Component version
     */
    ComponentStore.prototype.deleteComponent = function (id, version) {
        var key = this._getKey(id, version);
        if (this._componentMap.has(key)) {
            _TraceLogger.logVerbose(logSource, Text.format(strings.deleteComponentLog, id, version));
            this._componentMap.delete(key);
        }
        if (this._componentReferenceMap.has(key)) {
            this._componentReferenceMap.delete(key);
        }
    };
    /**
     * Internal implementation of `getManifest` that toggles whether failures should be logged or not.
     */
    ComponentStore.prototype._getComponentById = function (id, shouldLog) {
        Validate.isNonemptyString(id, 'id');
        var returnValue = undefined;
        this._componentMap.forEach(function (value, index) {
            // Check whether the index string is prefixed with the Guid that we are looking for
            if (index.indexOf(id) === 0) {
                if (!returnValue) {
                    returnValue = value;
                }
                else {
                    var error = new Error(Text.format(strings.tooManyComponentsError, id));
                    if (shouldLog) {
                        _TraceLogger.logError(logSource, error);
                    }
                    throw error;
                }
            }
        });
        if (!returnValue) {
            var error = new Error(Text.format(strings.noComponentFoundError, id));
            if (shouldLog) {
                _TraceLogger.logError(logSource, error);
            }
            throw error;
        }
        return returnValue;
    };
    ComponentStore.prototype._getKey = function (id, version) {
        return normalizeComponentId(id, version);
    };
    return ComponentStore;
}());
export default ComponentStore;
//# sourceMappingURL=ComponentStore.js.map