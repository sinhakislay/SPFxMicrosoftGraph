/**
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * @file ManifestStore.ts
 */
import { _TraceLogger } from '@microsoft/sp-diagnostics';
import { Validate, Version, Text, _SPFlight } from '@microsoft/sp-core-library';
import { manifestStoreLogSource as logSource } from './../utilities/telemetryConstants';
import { peekDebugAllowed } from './../debug/confirmDebugAllowed';
import normalizeComponentId from './../utilities/normalizeComponentId';
import { reactComponentId, reactDomComponentId } from '../utilities/componentConstants';
import strings from './Stores.resx';
import commonStrings from '../loc/Common.resx';
/**
 * This class maintains a cache of the manifests on the current page.
 *
 * @internal
 */
var ManifestStore = /** @class */ (function () {
    function ManifestStore() {
        /**
         * Map from component id to array of manifest store indexes.
         * This allows to store manifests for different versions of the same component.
         *
         * @remarks
         * Example: `'d1d91016-032f-456d-98a4-721247c305e8' -->[ Version(1.0.0), Version(2.0.0) ]`
         */
        this._manifestVersions = new Map();
        /**
         * Map from manifest store index string to manifest store entry.
         * Manifest store index is generated through logic in utilities/normalizeComponentId (`<id>_<version>`)
         * e.g. `'d1d91016-032f-456d-98a4-721247c305e8_1.0.0' --> { ManifestStoreEntry }`
         */
        this._manifests = new Map();
        /**
         * Set of all the component ids that have their manifest pinned.
         * If a component id has its manifest pinned, no other manifest can be added for that component id,
         * regardless of version or debug manifest.
         *
         * @remarks
         *
         * Example: `{ '1c6c9123-7aac-41f3-a376-3caea41ed83f', '7263c7d0-1d6a-45ec-8d85-d4d1d234171b' }`
         */
        this._pinnedManifests = new Set();
    }
    Object.defineProperty(ManifestStore, "instance", {
        get: function () {
            if (!this._instance) {
                this._instance = new ManifestStore();
            }
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Register the preloaded manifests on the manifest store.
     *
     * @param preloadedData - The preloaded data
     */
    ManifestStore.prototype.registerPreloadedManifests = function (preloadedData) {
        if (preloadedData && preloadedData.manifests && preloadedData.manifests.length) {
            this.registerManifests(preloadedData.manifests, true);
        }
        /* tslint:disable-next-line:no-any */
        var globalManifests = window.g_webPartManifests;
        if (globalManifests && globalManifests.length) {
            this.registerManifests(globalManifests, true);
        }
    };
    /**
     * Register debug manifests on the manifest store.
     *
     * @param manifests - A dictionary of debug manifests.
     */
    ManifestStore.prototype.registerDebugManifests = function (manifests) {
        if (manifests) {
            for (var _i = 0, manifests_1 = manifests; _i < manifests_1.length; _i++) {
                var manifest = manifests_1[_i];
                this._addDebugManifest(manifest);
            }
        }
    };
    /**
     * Return a manifest by its component id and version.
     *
     * @remarks
     * If version is not provided, it will return the only available version. If more than
     * one version is available and version is not provided, returns undefined.
     *
     * Only return a debug manifest is debug is allowed. If a manifest isn't found by
     * the provided id, return undefined.
     *
     * @param id        - The component id of the manifest to retrieve.
     * @param version   - The version of the component of the manifest to retrieve.
     * @param shouldLog - True if failures should be logged. Defaults to true.
     * @returns           The retrieved manifest, or undefined if one could not be found.
     */
    ManifestStore.prototype.tryGetManifest = function (id, version, shouldLog) {
        if (shouldLog === void 0) { shouldLog = true; }
        try {
            return this._getManifest(id, version, shouldLog);
        }
        catch (e) {
            return undefined;
        }
    };
    /**
     * Return a manifest by its component id and version.
     *
     * @remarks
     * If version is not provided, it will return the only available version. If more than
     * one version is available and version is not provided, the function throws.
     *
     * Only return a debug manifest is debug is allowed. If a manifest isn't found by
     * the provided id, the function throws.
     *
     * @param id      - The component id of the manifest to retrieve.
     * @param version - The version of the component of the manifest to retrieve.
     * @returns         The retrieved manifest, or undefined if one could not be found.
     */
    ManifestStore.prototype.getManifest = function (id, version) {
        return this._getManifest(id, version, true);
    };
    /**
     * Get all registered manifests.
     *
     * @returns The registered manifests.
     */
    ManifestStore.prototype.getRegisteredManifests = function () {
        var _this = this;
        var result = [];
        this._manifests.forEach(function (manifestEntry) {
            var manifest = _this._getManifestFromStoreEntry(manifestEntry);
            if (manifest) {
                result.push(manifest);
            }
        });
        return result;
    };
    /**
     * Removes all manifests that are not considered essential, and registers all the manifests passed as input.
     * Essential manifests are assembly-related manifest, and debug manifests.
     *
     * @param manifests - Manifests to add.
     */
    ManifestStore.prototype.replaceManifests = function (manifests) {
        this._removeAllManifests();
        this.registerManifests(manifests, false);
    };
    /**
     * Returns a map of manifest IDs to manifests.
     *
     * @returns A map of manifest IDs to manifests.
     */
    ManifestStore.prototype._getManifestMap = function () {
        return this._manifests;
    };
    /**
     * Loads additional manifests into the manifest store, updating existing manifests.
     *
     * @param manifests - The manifests to load into the store.
     */
    ManifestStore.prototype.registerManifests = function (manifests, overwriteExisting) {
        var _this = this;
        manifests.forEach(function (manifest) { return _this._addManifest(manifest, overwriteExisting); });
    };
    /**
     * Pins the manifest for a specific component id.
     * That means that no other manifest can be added for the specified component id.
     *
     * @remarks
     * This is used by assemblies to ensure that debug manifests are not replacing components already in use.
     *
     * @param componentId - Component id with only one manifest, which will be pinned.
     */
    ManifestStore.prototype._pinManifest = function (componentId) {
        Validate.isNonemptyString(componentId, 'componentId');
        this._pinnedManifests.add(componentId);
    };
    /**
     * Given a component id and version, requests its manifest (and all its dependencies) to SharePoint
     * through a REST API.
     * @param id - Id of the requested component
     * @param version - Optional. Version of the requested component
     * @returns Promise with the requested manifest. Rejects the promise if the manifest was not found.
     */
    ManifestStore.prototype.requestManifest = function (id, version) {
        var _this = this;
        Validate.isNotNullOrUndefined(this._manifestProvider, 'manifestProvider');
        _TraceLogger.logVerbose(logSource, "Requesting manifest with id: \"" + id + "\" and version: \"" + version + "\"");
        return this._manifestProvider.tryGetManifest(id, version).then(function (manifests) {
            _this.registerManifests(manifests, false);
            // This will reject the promise if the manifest is not present
            return _this.getManifest(id, version);
        }).catch(function (error) {
            throw new Error(_this._getManifestNotFoundErrorMessage(id, version));
        });
    };
    /**
     * Given a component id and version, requests its manifest (and all its dependencies) to SharePoint
     * through a REST API.
     * @param ids - List of ids and (optionally) versions of the manifests to request.
     * @returns Promise with the requested manifests. Rejects the promise if the manifest was not found.
     */
    ManifestStore.prototype.requestManifests = function (ids) {
        var _this = this;
        var retVal = [];
        Validate.isNotNullOrUndefined(this._manifestProvider, 'manifestProvider');
        return this._manifestProvider.tryGetManifests(ids).then(function (manifests) {
            _this.registerManifests(manifests, false);
            // This will reject the promise if any of the manifests is not present
            ids.forEach(function (id) {
                retVal.push(_this.getManifest(id.id, id.version));
            });
            return retVal;
        });
    };
    /**
     * Sets the manifest provider.
     * This is used to request manifests in the server if they are not found in the manifest store.
     *
     * @remarks
     * This must be set once by SPApplicationLoader. If it is called more than once it does nothing.
     */
    ManifestStore.prototype._setManifestProvider = function (manifestProvider) {
        if (!this._manifestProvider) {
            this._manifestProvider = manifestProvider;
        }
    };
    ManifestStore.prototype._isManifestPinned = function (componentId) {
        return this._pinnedManifests.has(componentId);
    };
    ManifestStore.prototype._removeAllManifests = function () {
        var _this = this;
        this._manifests.forEach(function (manifestEntry) { return _this._removeManifest(manifestEntry.id, manifestEntry.version); });
    };
    /**
     * Removes a manifest from the manifest store based on its id.
     * If it's a pinned manifest or a debug manifest it will skip it.
     *
     * @param id - Id of the manifest to remove.
     * @param version - Version of the manifest to remove.
     * @returns true if the manifest was removed.
     */
    ManifestStore.prototype._removeManifest = function (id, version) {
        if (this._pinnedManifests.has(id)) {
            return false;
        } // If it's a pinned manifest, it should not be removed
        // React 16 Rollout - NavigationOrchestrator.navigate replaces all manifests. The use case with React 15/16 breaks
        // because React 15 *may* not come from the server preloaded data
        if (id === reactComponentId || id === reactDomComponentId) {
            return false;
        }
        var versionObj = Version.parse(version);
        var index = this._createIndex(id, versionObj);
        var entry = this._manifests.get(index);
        if (!entry) {
            return false;
        } // If there is no entry, nothing gets removed
        if (entry.debugManifest) {
            return false;
        } // If this is a debug manifest, don't remove it
        this._manifests.delete(index);
        if (this._manifestVersions.get(id).length === 1) { // Only one version. Remove the reference to the id.
            this._manifestVersions.delete(id);
        }
        else { // More than one version. Remove only the specific version.
            this._manifestVersions.set(id, this._manifestVersions.get(id).filter(function (v) { return !v.equals(versionObj); }));
        }
        return true;
    };
    /**
     * Internal implementation of `getManifest` that toggles whether failures should be logged or not.
     */
    ManifestStore.prototype._getManifest = function (id, version, shouldLog) {
        Validate.isNonemptyString(id, 'id');
        var index = this._getExistingIndex(id, version);
        if (!index) {
            var errorMessage = this._getManifestNotFoundErrorMessage(id, version);
            if (shouldLog) {
                _TraceLogger.logVerbose(logSource, errorMessage);
            }
            throw new Error(errorMessage);
        }
        // after here, the compiler will assume index != undefined
        var manifestEntry = this._manifests.get(index);
        if (manifestEntry) {
            var manifest = this._getManifestFromStoreEntry(manifestEntry);
            if (manifest) {
                return manifest;
            }
        }
        throw new Error(this._getManifestNotFoundErrorMessage(id, version));
    };
    ManifestStore.prototype._getManifestNotFoundErrorMessage = function (id, version) {
        if (!version) {
            return Text.format(strings.manifestNotFoundByIdError, id);
        }
        else {
            return Text.format(commonStrings.manifestNotFoundError, id, version);
        }
    };
    ManifestStore.prototype._getManifestFromStoreEntry = function (manifestEntry) {
        var allowDebug = peekDebugAllowed({ manifestsRequested: true, loaderRequested: false });
        if (manifestEntry) {
            if (allowDebug && manifestEntry.debugManifest) {
                return manifestEntry.debugManifest;
            }
            else {
                return manifestEntry.manifest;
            }
        }
        else {
            return undefined;
        }
    };
    ManifestStore.prototype._addManifest = function (manifest, overwriteExisting) {
        this._internalAddManifest(manifest, false, overwriteExisting);
    };
    ManifestStore.prototype._addDebugManifest = function (manifest) {
        this._internalAddManifest(manifest, true);
    };
    ManifestStore.prototype._internalAddManifest = function (manifest, isDebug, overwriteExisting) {
        // If a manifest is pinned, no other manifest for the same component id can be added
        if (this._isManifestPinned(manifest.id)) {
            return;
        }
        // Pin all internal manifests so third parties cannot override them.
        // This behavior is disabled when the debugging flight is enabled, for internal development.
        if (!_SPFlight.isDebugFlightEnabled && manifest.isInternal
            // React has an internal manifest but it can have multiple versions at the same time
            && manifest.id !== reactComponentId && manifest.id !== reactDomComponentId) {
            this._pinManifest(manifest.id);
        }
        if (isDebug) {
            manifest._isDebug = true;
        }
        var index = this._getExistingIndex(manifest.id, manifest.version);
        var existingEntry = index ? this._manifests.get(index) : undefined;
        if (existingEntry) {
            if (isDebug) {
                existingEntry.debugManifest = manifest;
            }
            else {
                if (overwriteExisting || !existingEntry.manifest) {
                    existingEntry.manifest = manifest;
                }
            }
        }
        else {
            this._addManifestToVersionsMap(manifest);
            var newIndex = this._createIndexFromManifest(manifest);
            this._manifests.set(newIndex, {
                id: manifest.id,
                version: manifest.version,
                manifest: isDebug ? undefined : manifest,
                debugManifest: isDebug ? manifest : undefined
            });
        }
    };
    /**
     * Adds the manifest to the versions map.
     *
     * If the component id is not present in the map, adds a new entry in the map.
     * If the id and version are already present, it does nothing.
     */
    ManifestStore.prototype._addManifestToVersionsMap = function (manifest) {
        var version = Version.parse(manifest.version);
        if (!this._manifestVersions.has(manifest.id)) {
            this._manifestVersions.set(manifest.id, [version]);
        }
        else {
            var versions = this._manifestVersions.get(manifest.id);
            for (var _i = 0, versions_1 = versions; _i < versions_1.length; _i++) {
                var existingVersion = versions_1[_i];
                if (existingVersion.equals(version)) {
                    return; // early return
                }
            }
            this._manifestVersions.set(manifest.id, versions.concat(version));
        }
    };
    /**
     * Returns the index for a component id and version.
     * The index might not be for the same version, but a compatible one.
     *
     * If an index is not found, returns undefined.
     * If an index is request without a version, and there are multiple versions,
     * returns an error.
     * If more than one compatible version is found, an error is logged and
     * returns the highest compatible version.
     */
    ManifestStore.prototype._getExistingIndex = function (id, versionString) {
        if (!versionString) {
            return this._getUniqueManifestStoreIndex(id);
        }
        if (this._manifestVersions.has(id)) {
            var versions = this._manifestVersions.get(id);
            var version_1 = Version.parse(versionString);
            var validVersions = versions.filter(function (currentVersion) { return currentVersion.satisfies(version_1); });
            if (!validVersions || validVersions.length < 1) {
                return undefined;
            }
            else if (validVersions.length === 1) {
                return this._createIndex(id, validVersions[0]);
            }
            else { // if (validVersions.length > 1)
                // If there is a debug manifest, use that one. Otherwise log error.
                var debugIndex = this._findDebugIndex(id, validVersions);
                if (debugIndex) {
                    return debugIndex;
                }
                else {
                    var error = new Error(Text.format(strings.tooManyCompatibleVersionsError, validVersions.length, validVersions.join(', '), id, versionString));
                    _TraceLogger.logError(logSource, error);
                    // Sort by greatest version first, and return the first version
                    var returnVersion = validVersions.sort(function (version1, version2) {
                        return -1 * Version.compare(version1, version2);
                    })[0];
                    return this._createIndex(id, returnVersion);
                }
            }
        }
        return undefined;
    };
    /**
     * Gets the manifest store index for a component id without version.
     *
     * If no version is found for the id, returns undefined.
     * If there are too many manifests for the component id, logs an error and returns undefined.
     */
    ManifestStore.prototype._getUniqueManifestStoreIndex = function (id) {
        var versions = this._manifestVersions.get(id);
        if (!versions || versions.length < 1) {
            return undefined;
        }
        else if (versions.length === 1) {
            return this._createIndex(id, versions[0]);
        }
        else { // if (versions.length > 1)
            // If there is a debug manifest, use that one. Otherwise log error.
            var debugIndex = this._findDebugIndex(id, versions);
            if (debugIndex) {
                return debugIndex;
            }
            else {
                var error = new Error(Text.format(strings.tooManyManifestsError, versions.length, versions.join(', '), id));
                _TraceLogger.logError(logSource, error);
                return undefined;
            }
        }
    };
    ManifestStore.prototype._createIndexFromManifest = function (manifest) {
        return this._createIndex(manifest.id, Version.parse(manifest.version));
    };
    ManifestStore.prototype._createIndex = function (id, version) {
        return normalizeComponentId(id, version.toString());
    };
    ManifestStore.prototype._findDebugIndex = function (id, versions) {
        var _this = this;
        return versions.reduce(function (previous, validVersion) {
            var index = _this._createIndex(id, validVersion);
            var manifestStoreEntry = _this._manifests.get(index);
            if (manifestStoreEntry && manifestStoreEntry.debugManifest) {
                return index;
            }
            else {
                return previous;
            }
        }, undefined);
    };
    return ManifestStore;
}());
export default ManifestStore;
//# sourceMappingURL=ManifestStore.js.map