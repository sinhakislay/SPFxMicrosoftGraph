// Copyright (c) Microsoft. All rights reserved.
/// <reference path="./requirejs.d.ts" />
import { ServiceKey, Guid, Version, Log, _SPFlight, _SPKillSwitch } from '@microsoft/sp-core-library';
import { _TraceLogger } from '@microsoft/sp-diagnostics';
import ManifestStore from '../stores/ManifestStore';
import AddressStore from '../stores/AddressStore';
import resolveAddress from '../utilities/resolveAddress';
import isCorsEnabled from '../utilities/isCorsEnabled';
import normalizeName, { normalizeFailoverPathName } from './normalizeName';
import ErrorBuilder from '../error/ErrorBuilder';
import * as telemetryConstants from '../utilities/telemetryConstants';
import SPLoaderFlights from '../utilities/SPLoaderFlights';
var REQUIREJS_LOAD_TIMEOUT_IN_SECONDS = 90;
/**
 * Loader for RequireJS.
 * Provides the instance of RequireJS and allows methods for configuration.
 */
var RequireJsLoader = /** @class */ (function () {
    function RequireJsLoader(serviceScope) {
        this._configuredFailoverPaths = [];
        /**
         * Map to track duplicate module names, in the form { newModuleName -> originalModuleName }
         * There are case where 2 different components have different ids, but are pointing to the same script.
         * RequireJS doesn't accept that, so before calling require([modules], callback) it gets the original
         * module name, so it will load the right component.
         */
        this._duplicateModuleNames = new Map();
        this._checkDependencies = this._checkDependencies.bind(this);
        this._initialize();
    }
    Object.defineProperty(RequireJsLoader.prototype, "loadEntryPointErrorProcessors", {
        get: function () {
            return [this._checkDependencies];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RequireJsLoader.prototype, "loadComponentDependencyErrorProcessors", {
        get: function () {
            return [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RequireJsLoader.prototype, "loadPathDependencyErrorProcessors", {
        get: function () {
            return [this._checkDependencies];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Ensures that the module is present in RequireJS for the component manifest.
     * In order to do so, it removes any pre-existing module that was already loaded.
     */
    RequireJsLoader.prototype.ensure = function (manifest, module) {
        var name = normalizeName(manifest);
        return this._ensure(name, module);
    };
    /**
     * Calls actual RequireJS config()
     */
    RequireJsLoader.prototype.requireConfig = function (config) {
        this._requirejs.config(config);
    };
    RequireJsLoader.prototype.load = function (manifest, name, globalName) {
        return this.requireLoad(normalizeName(manifest, name), globalName)
            .then(function (module) {
            if (!name && manifest.loaderConfig.exportName) { // Only do this for the entry point, that has no name
                return module[manifest.loaderConfig.exportName];
            }
            else {
                return module;
            }
        });
    };
    RequireJsLoader.prototype.loadFromFailoverPath = function (name) {
        return this.requireLoad(normalizeFailoverPathName(name));
    };
    /**
     * Calls RequireJS require()
     * Catches exceptions and returns a rejected promise with the error from RequireJS
     */
    RequireJsLoader.prototype.requireLoad = function (name, globalName) {
        var _this = this;
        // Check if the module name points to a duplicate script
        if (this._duplicateModuleNames.has(name)) {
            name = this._duplicateModuleNames.get(name);
        }
        try {
            return this._requirePromise(name).then(function (module) {
                return _this._ensureProperModuleLoaded(name, module, globalName);
            }).catch(function (error) {
                return _this._handleRequireJsError(name, error, globalName);
            });
        }
        catch (error) {
            _TraceLogger.logError(telemetryConstants.loadComponentLogSource, error, RequireJsLoader._requireEventName);
            return Promise.reject(error);
        }
    };
    RequireJsLoader.prototype.delete = function (manifest) {
        return this.requireDelete(manifest);
    };
    /**
     * Calls RequireJS undef() with the name matching the input manifest.
     * Also removes the script tag from the head, so RequireJS will request the script again.
     */
    RequireJsLoader.prototype.requireDelete = function (manifest) {
        var normalizedName = normalizeName(manifest);
        this._requirejs.undef(normalizedName);
        var scriptTags = document.getElementsByTagName('script');
        for (var i = 0; i < scriptTags.length; i++) {
            var scriptTag = scriptTags[i];
            if (normalizedName === scriptTag.getAttribute('data-requiremodule')) {
                scriptTag.parentNode.removeChild(scriptTag);
                break;
            }
        }
    };
    /**
     * For a module name, returns the URL that RequireJS is configured with.
     * @param name - Module name to request the URL from.
     */
    RequireJsLoader.prototype.getConfiguredUrl = function (name) {
        return this.requireContext.config.paths[name];
    };
    /**
     * Sets the config for RequireJS. Handles global exports, renames the dependencies.
     * Also sets AddressStore with the right mapping between script and URL.
     */
    RequireJsLoader.prototype.configure = function (manifest) {
        var resources = manifest.loaderConfig.scriptResources;
        var pathConfig = {};
        var currentMapConfig = {};
        var shimConfig = {};
        for (var name_1 in resources) {
            if (resources.hasOwnProperty(name_1)) {
                this._configureResource(name_1, resources[name_1], manifest, pathConfig, currentMapConfig, shimConfig);
            }
        }
        var normalizedName = normalizeName(manifest);
        var mapConfig = {};
        mapConfig[normalizedName] = currentMapConfig;
        this.requireConfig({
            paths: pathConfig,
            map: mapConfig,
            shim: shimConfig
        });
        // There's a global __spfxPreloadedModules that may host the define arguments for preloaded components.
        // This ensures that RequireJS will automatically load them if they are present.
        if (RequireJsLoader._window.define &&
            RequireJsLoader._window.__spfxPreloadedModules &&
            RequireJsLoader._window.__spfxPreloadedModules.hasOwnProperty(normalizedName)) {
            var args = RequireJsLoader._window.__spfxPreloadedModules[normalizedName];
            RequireJsLoader._window.define(args.id, args.deps, args.f);
            delete RequireJsLoader._window.__spfxPreloadedModules[normalizedName];
        }
    };
    /**
       * Gets an array of missing dependencies hat failed to load.
       */
    RequireJsLoader.prototype.getMissingDependencies = function (moduleName) {
        var registryEntry = this.requireContext.registry[moduleName];
        var missingDependencies = [];
        if (registryEntry) {
            for (var _i = 0, _a = registryEntry.depMaps; _i < _a.length; _i++) {
                var dependency = _a[_i];
                if (this.requireContext.defined.hasOwnProperty(dependency.id) &&
                    this.requireContext.defined[dependency.id] === undefined) {
                    _TraceLogger.logError(telemetryConstants.loadComponentLogSource, new Error("Dependency \"" + dependency.id + "\" not found for module \"" + moduleName + "\""), RequireJsLoader._requireEventName);
                    missingDependencies.push(dependency.id);
                }
            }
        }
        return missingDependencies;
    };
    /**
     * Ensures that the module is present in RequireJS with the defined name.
     * In order to do so, it removes any pre-existing module that was already loaded.
     */
    RequireJsLoader.prototype._ensure = function (name, module) {
        this._requirejs.undef(name);
        this._define(name, [], function () { return module; });
        this._requirejs([name]);
    };
    RequireJsLoader.prototype._configureResource = function (name, resource, manifest, pathConfig, mapConfig, shimConfig) {
        if (resource.type === 'component') {
            var componentResource = resource;
            this._configureComponentResource(name, componentResource, manifest, pathConfig, mapConfig, shimConfig);
        }
        else { // path or localizedPath
            this._configurePathResource(name, resource, manifest, pathConfig, mapConfig, shimConfig);
        }
    };
    RequireJsLoader.prototype._configurePathResource = function (name, resource, manifest, pathConfig, mapConfig, shimConfig) {
        // Step 1: Set map configuration with the normalized name.
        // The normalized name of the entry point is the name of the component (i.e. <id>_<version>)
        // Other path dependencies have the resource name appended (i.e. <id>_<version>/<name>)
        var normalizedName;
        if (name === manifest.loaderConfig.entryModuleId) { // the entry point of the module
            normalizedName = normalizeName(manifest);
        }
        else {
            normalizedName = normalizeName(manifest, name);
            mapConfig[name] = normalizedName;
        }
        // Step 2: Set path configuration with the URL of the resource.
        // If the URL for the resource is already used by another manifest, we re-use that normalized name.
        var address = this._resolveAddress(manifest, name);
        var existingNormalizedNameForAddress = AddressStore.instance.getNormalizedName(address);
        if (existingNormalizedNameForAddress) {
            mapConfig[name] = existingNormalizedNameForAddress;
            this._duplicateModuleNames.set(normalizedName, existingNormalizedNameForAddress);
        }
        else {
            pathConfig[normalizedName] = address;
            AddressStore.instance.set(normalizedName, address);
        }
        // Step 3: Set shim configuration with global names and dependencies, if applicable.
        // Only path configurations (not localized path configurations) support it.
        var pathResource = resource;
        if (pathResource) {
            // There are some issues with JQuery and Yammer using RequireJS that we can self-recover.
            // This does nothing if JQuery or Yammer are not dependencies of the component.
            this._fixUpJQueryKnownIssues(name, manifest, pathResource, manifest.loaderConfig.scriptResources);
            this._fixUpYammerKnownIssues(name, manifest, pathResource);
            if (pathResource.globalName) {
                shimConfig[normalizedName] = {
                    exports: pathResource.globalName,
                    deps: pathResource.globalDependencies
                };
            }
        }
    };
    RequireJsLoader.prototype._configureComponentResource = function (name, moduleConfiguration, manifest, pathConfig, mapConfig, shimConfig) {
        // Map the dependency to the normalized name of the component.
        var resourceManifest = ManifestStore.instance.tryGetManifest(moduleConfiguration.id, moduleConfiguration.version);
        if (resourceManifest) {
            mapConfig[name] = normalizeName(resourceManifest);
        }
        if (moduleConfiguration.failoverPath) {
            // Multiple components can have the same dependencies with failover paths. Configure only once.
            if (this._configuredFailoverPaths.indexOf(name) === -1) {
                var normalizedName = normalizeFailoverPathName(name);
                // Store the address both in RequireJS and the AddressStore for the SPFx loader.
                pathConfig[normalizedName] = this._resolveAddress(manifest, name);
                AddressStore.instance.set(normalizedName, this._resolveAddress(manifest, name));
                this._configuredFailoverPaths.push(name);
            }
        }
    };
    RequireJsLoader.prototype._fixUpJQueryKnownIssues = function (name, manifest, resource, resources) {
        var jqueryString = 'jquery';
        var jQueryString = 'jQuery';
        var jqueryuiString = 'jqueryui';
        // Fix-up: Some customers declared jQuery dependency without explicitly declaring a global name in the manifest
        // Fix-up: Some customers declared the global as 'jquery' instead of 'jQuery'
        // RequireJS doesn't work properly in either of those cases
        this._fixWrongGlobalName(name, jqueryString, jqueryString, jQueryString, manifest, resource);
        // Fix-up: Some customers declare JQuery UI without the dependency on JQuery
        if (name.toLowerCase() === jqueryuiString &&
            (!resource.globalDependencies || resource.globalDependencies.length === 0)) {
            _TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, "Fixing up JQueryUI path dependency for component \"" + manifest.id + "\" (" + manifest.alias + ")");
            if (resources[jqueryString]) {
                resource.globalDependencies = [jqueryString];
            }
            else if (resources[jQueryString]) {
                resource.globalDependencies = [jQueryString];
            }
            else {
                _TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, "Didn't find JQuery path dependency in \"" + manifest.id + "\" (" + manifest.alias + ") to fix JQuery UI");
            }
        }
    };
    RequireJsLoader.prototype._fixUpYammerKnownIssues = function (name, manifest, resource) {
        // Fix-up: Some customers declared yammer dependency without explicitly declaring a global name in the manifest
        // Fix-up: Some customers declared the global as 'yammer' instead of 'yam'
        var yammerString = 'yammer';
        var yamString = 'yam';
        this._fixWrongGlobalName(name, yammerString, yammerString, yamString, manifest, resource);
    };
    RequireJsLoader.prototype._fixWrongGlobalName = function (name, expectedName, knownBadName, expectedGlobalName, manifest, resource) {
        if ((name.toLowerCase() === expectedName && !resource.globalName)
            || resource.globalName === knownBadName) {
            _TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, "Fixing up wrong \"" + name + "\" path dependency for component \"" + manifest.id + "\" (" + manifest.alias + ")");
            resource.globalName = expectedGlobalName;
        }
    };
    Object.defineProperty(RequireJsLoader.prototype, "requireContext", {
        get: function () {
            return this._requirejs.s.contexts._; // tslint:disable-line:no-any
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Executes require([moduleName]) with the provided module name, returning a promise instead of callbacks.
     * @param moduleName - Name of the module to load with require()
     */
    RequireJsLoader.prototype._requirePromise = function (moduleName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._requirejs([moduleName], function (module) { return resolve(module); }, function (error) { return reject(error); });
        });
    };
    /**
     * If RequireJS is not loaded already, it will load it.
     * If it's loaded, it just takes the necessary variables from the window.
     */
    RequireJsLoader.prototype._initialize = function () {
        if (!this._isRequireJsLoaded()) {
            this._loadRequireJs();
        }
        else {
            this._setRequireJsLocalVariables();
        }
        var config = { waitSeconds: REQUIREJS_LOAD_TIMEOUT_IN_SECONDS };
        // <script crossorigin="anonymous"> enables scripts be transparent to service workers
        if (_SPFlight.isEnabled(1106 /* AkamaiCrossOrigin */)) {
            config.onNodeCreated = function (node, c, moduleName, url) {
                if (isCorsEnabled(url)) {
                    node.setAttribute('crossorigin', 'anonymous');
                }
            };
        }
        // Ensure that the wait time for load is enough
        this.requireConfig(config);
    };
    RequireJsLoader.prototype._loadRequireJs = function () {
        if (!SPLoaderFlights._loadRequireJSOnWindow()) {
            // Load RequireJS
            var requirejs_1 = DEPRECATED_UNIT_TEST
                ? require('./test/RequireJsMock')
                : require('exports-loader?requirejs,require,define!../../blobs/requirejs/2.1.20/require.min');
            // Set the output in the window, for compatibility
            RequireJsLoader._window.requirejs = requirejs_1.requirejs;
            RequireJsLoader._window.require = requirejs_1.require;
            RequireJsLoader._window.define = requirejs_1.define;
        }
        else {
            // using raw-loader ensures the module is loaded with the correct global (window) context
            DEPRECATED_UNIT_TEST
                ? require('./test/RequireJsMock')
                : eval.call(window, require('!!raw-loader!../../blobs/requirejs/2.1.20/require.min'));
        }
        // Provide a base configuration for RequireJS
        var requireJsConfig = {
            baseUrl: RequireJsLoader._invalidBaseUrl
        };
        this._setRequireJsLocalVariables();
        this.requireConfig(requireJsConfig);
    };
    /**
     * Returns true if RequireJS has been loaded and is in the window variable
     */
    RequireJsLoader.prototype._isRequireJsLoaded = function () {
        return (RequireJsLoader._window.requirejs !== undefined &&
            RequireJsLoader._window.require !== undefined &&
            RequireJsLoader._window.define !== undefined);
    };
    /**
     * Sets the needed RequireJS variables in the RequireJsLoader to avoid going to the window
     * variable every time.
     */
    RequireJsLoader.prototype._setRequireJsLocalVariables = function () {
        this._requirejs = RequireJsLoader._window.requirejs;
        this._define = RequireJsLoader._window.define;
    };
    /**
     * Helper method for RequireJS loader.
     * RequireJS takes addresses without the js extension, so this calls the real resolveAddress and removes that
     */
    RequireJsLoader.prototype._resolveAddress = function (manifest, resourceName) {
        var address = resolveAddress(manifest, resourceName);
        // Remove .js extension in the end
        address = address.replace(/.js$/, '');
        return address;
    };
    /**
     * Resolves with the correct loaded module, when applicable.
     *
     * If the module is defined by a global variable, it returns the object in the global variable.
     * If the module has been loaded correctly, it returns the loaded module.
     * If the module failed to load and it's an SPFx component, we try to load a different version of the same component.
     *
     * This happens because if the version in the manifest and the version in the module name don't match,
     * RequireJS has a weird behavior where it loads the component but doesn't return it.
     */
    // tslint:disable-next-line:no-any
    RequireJsLoader.prototype._ensureProperModuleLoaded = function (moduleName, module, globalName) {
        if (globalName) {
            if (window.hasOwnProperty(globalName)) {
                var returnValue = window[globalName]; // tslint:disable-line:no-any
                this._ensure(moduleName, returnValue);
                return Promise.resolve(returnValue);
            }
            else {
                // Current customers may load path dependencies with the wrong global name.
                // If the global variable is not found, return an empty object to "succeed" the load.
                var error = ErrorBuilder.buildScriptFailedToCreateGlobalError(globalName, this.getConfiguredUrl(moduleName));
                _TraceLogger.logError(telemetryConstants.loadComponentLogSource, error);
                // Public warning to advertise the configuration mistake, without failing the load.
                Log.warn(telemetryConstants.loadComponentLogSource.id, error.message);
                return Promise.resolve({});
            }
        }
        else if (module === undefined && this._isSpfxComponent(moduleName)) {
            return this._requireLoadForDifferentModuleId(moduleName);
        }
        else {
            return Promise.resolve(module);
        }
    };
    /**
     * When RequireJS rejects the load with an error, it can be due to different root causes.
     * If the module is set in the global, the load may fail but the module be correctly loaded in the global scope,
     * in that case we fix up RequireJS internals and return the global object.
     *
     * If there is a version mismatch between the version in the manifest and the version in the JS code,
     * RequireJS may fail.
     * In that case we try to load a different version of the same component.
     *
     * Otherwise, it rejects with the original error.
     */
    RequireJsLoader.prototype._handleRequireJsError = function (moduleName, error, globalName) {
        if (globalName && window.hasOwnProperty(globalName)) {
            var returnValue = window[globalName]; // tslint:disable-line:no-any
            this._ensure(moduleName, returnValue);
            return Promise.resolve(returnValue);
        }
        else if (this._isOrphanedVersionLoaded(moduleName)) {
            return this._requireLoadForDifferentModuleId(moduleName, error);
        }
        else {
            return Promise.reject(error);
        }
    };
    /**
     * Returns true if RequireJS loaded a module that matches the component id with a different version.
     * This only applies to to mismatches between manifest and bundle, not between 2 different manifest versions.
     */
    RequireJsLoader.prototype._isOrphanedVersionLoaded = function (moduleName) {
        var _this = this;
        var componentId = this._extractComponentIdFromModuleName(moduleName);
        // tslint:disable-next-line:no-any
        var registry = this.requireContext.registry;
        var registryIds = Object.keys(registry);
        // The loaded module doesn't match the requested one, but it's the same component's entry point
        return registryIds
            .map(function (id) { return moduleName !== id && id.indexOf(componentId) === 0 && _this._isSpfxComponent(id); })
            .reduce(function (prev, curr) { return prev || curr; }, false);
    };
    /**
     * Returns true if the module name corresponds to an SPFx component.
     * SPFx components have module name in the form of "<componentId>_<version>"
     */
    RequireJsLoader.prototype._isSpfxComponent = function (moduleName) {
        if (moduleName.split('/').length > 1) {
            return false; // This is a path dependency, not a component itself
        }
        var substrings = moduleName.split('_');
        return substrings.length === 2 && Guid.isValid(substrings[0]) && Version.isValid(substrings[1]);
    };
    /**
     * Returns the component id out of the module name.
     * Module names are generated based on "<componentId>_<version>"
     */
    RequireJsLoader.prototype._extractComponentIdFromModuleName = function (moduleName) {
        return moduleName.split('_')[0];
    };
    /**
     * Looks at the path to see if it is a provider hosted app.  If it is, it modifies the existing
     * module name to match the provider hosted app js module name and then loads the component.  If
     * its not that case it looks at the registry of RequireJS to find another version of the same
     * component as moduleName, if found, it configures RequireJS with the same dependency resolution
     * (that comes from the manifest) and ensuring that the path points only to the found version,
     * and it loads the component.
     */
    RequireJsLoader.prototype._requireLoadForDifferentModuleId = function (moduleName, error) {
        // tslint:disable-next-line:no-any
        var registry = this.requireContext.registry;
        var requirejsInternalConfig = this.requireContext.config;
        var requestedComponentId = this._extractComponentIdFromModuleName(moduleName);
        var requestedPath = requirejsInternalConfig.paths[moduleName];
        if (!_SPKillSwitch.isActivated(Guid.parse('5A521104-FCA6-4265-97B7-F3D955EE9923'), '04/25/2019', 'Loading SaaS solutions with RequireJS') &&
            requestedPath.indexOf('/sp-provider-hosted-web-part') !== -1) {
            // The provider hosted web part has js files with a fixed guid (given below), but
            // each instance of a webpart gets it's own unique guid which doesn't match the JS.
            // Therefore when we see this we replace it automatically and retry
            var loadedModuleName = '4fca678e-55b6-46c8-b823-dd875dfdb951_1.0.0';
            this._replaceModuleInConfig(requirejsInternalConfig, loadedModuleName, moduleName, requestedPath);
            // Load the right component
            return this._requirePromise(loadedModuleName);
        }
        else {
            for (var _i = 0, _a = Object.keys(registry); _i < _a.length; _i++) {
                var loadedModuleName = _a[_i];
                var loadedComponentId = this._extractComponentIdFromModuleName(loadedModuleName);
                if (requestedComponentId === loadedComponentId && moduleName !== loadedModuleName) {
                    this._replaceModuleInConfig(requirejsInternalConfig, loadedModuleName, moduleName, requirejsInternalConfig.paths[moduleName]);
                    // Load the right component
                    return this._requirePromise(loadedModuleName);
                }
            }
        }
        // if no component found
        return Promise.reject(error ? error : new Error("Unknown error when loading module \"" + moduleName + "\""));
    };
    RequireJsLoader.prototype._replaceModuleInConfig = function (requirejsInternalConfig, existingModuleName, moduleName, modulePath) {
        // Create a RequireJS configuration for the other version of the component
        var map = {}; // Definition from requirejs.d.ts
        map[existingModuleName] = requirejsInternalConfig.map[moduleName];
        var paths = {};
        paths[existingModuleName] = modulePath;
        this._requirejs.config({
            map: map,
            paths: paths
        });
        // Remove the definition (including the <script> tag) of any previously load of the same component
        // Otherwise RequireJS can't load the module again
        this._requirejs.undef(moduleName);
        this._requirejs.undef(existingModuleName);
        // Avoid two path entries going to the same path
        requirejsInternalConfig.paths[moduleName] = "SPFx: Use " + existingModuleName + " instead";
    };
    /**
     * Checks the that all dependencies for a module are found.
     * If the response is not successful, it throws the appropriate error.
     * @param manifest - Manifest where the resource is defined
     * @param name - Name of the resource to check
     */
    RequireJsLoader.prototype._checkDependencies = function (manifest, name) {
        var moduleName = normalizeName(manifest, name);
        var missingDependencies = this.getMissingDependencies(moduleName);
        if (missingDependencies.length > 0) {
            return Promise.reject(ErrorBuilder.buildModuleHasFailedDependencyError(moduleName, missingDependencies.join(', ')));
        }
        return Promise.resolve();
    };
    RequireJsLoader.serviceKey = ServiceKey.create('sp-loader:RequireJsLoader', RequireJsLoader);
    RequireJsLoader._requireEventName = 'RequireJS.require';
    /**
     * This is the configured base URL for RequireJS.
     * When a user tries to call RequireJS with a relative path, an error will show this as the base URL.
     *
     * Example:
     * require("myModule") => Error: https://relative-path.invalid/myModule not found
     */
    RequireJsLoader._invalidBaseUrl = 'https://relative-path.invalid/';
    RequireJsLoader._window = window;
    return RequireJsLoader;
}());
export default RequireJsLoader;
//# sourceMappingURL=RequireJsLoader.js.map