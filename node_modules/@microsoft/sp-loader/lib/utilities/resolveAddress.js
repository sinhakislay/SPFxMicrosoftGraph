import { Text, Validate } from '@microsoft/sp-core-library';
import { _TraceLogger } from '@microsoft/sp-diagnostics';
import LocaleStore from '../stores/LocaleStore';
import * as telemetryConstants from './telemetryConstants';
import strings from './Utilities.resx';
/**
 * Given a manifest and a resource name returns the URL to the resource.
 *
 * For path or localizedPath dependencies, it returns the full URL to the resource.
 * For component dependencies, it returns the full URL to the failover path,
 * or returns an empty string if it doesn't exist.
 *
 * If the resource name is not present in the loader config, it throws an error.
 */
export default function resolveAddress(manifest, resourceName) {
    Validate.isNotNullOrUndefined(manifest, 'manifest');
    Validate.isNonemptyString(resourceName, 'resourceName');
    if (!manifest.loaderConfig.scriptResources.hasOwnProperty(resourceName)) {
        var error = new Error(Text.format(strings.resourceNotFoundError, resourceName, manifest.id, manifest.alias));
        _TraceLogger.logError(telemetryConstants.resolveAddressLogSource, error);
        throw error;
    }
    var moduleConfiguration = manifest.loaderConfig.scriptResources[resourceName];
    var address = resolveModuleConfiguration(resourceName, moduleConfiguration);
    // Prepend the base URL if this isn't a fully-qualified URL.
    if (!address.match(/^https?\:\/\//i)) {
        // Replace this with shared URL concatenation logic. VSO#249681
        var moduleBaseUrl = manifest.loaderConfig.internalModuleBaseUrls[0].replace(/\/+$/, '');
        address = moduleBaseUrl + "/" + address;
    }
    return address;
}
/**
 * Resolves a IModuleConfiguration to a URL
 *
 * Take a look at the IModuleConfiguration documentation for more information.
 */
function resolveModuleConfiguration(moduleName, moduleConfiguration) {
    if (moduleConfiguration) {
        switch (moduleConfiguration.type) {
            case 'component':
                var failoverPath = moduleConfiguration.failoverPath;
                if (!failoverPath) {
                    throw new Error(strings.noFailoverPathError);
                }
                return resolvePath(failoverPath);
            case 'path':
                return resolvePath(moduleConfiguration.path);
            case 'localizedPath':
                return resolvePath(resolveLocalizedModuleConfiguration(moduleConfiguration));
            case null: // tslint:disable-line:no-null-keyword
            case undefined:
            default: // tslint:disable-line:no-switch-case-fall-through
                return moduleName;
        }
    }
    else {
        return moduleName;
    }
}
/**
 * Resolves a path to the default or debug version of a script.
 *
 * If a debug version is present, it uses that. Otherwise uses the default one.
 * If the path is a string, it returns it unchanged.
 */
export function resolvePath(path) {
    if (typeof path === 'string') {
        return path;
    }
    else {
        if (path.debug) {
            return path.debug;
        }
        else {
            return path.default;
        }
    }
}
/**
 * Resolves a localized module config to a path.
 */
function resolveLocalizedModuleConfiguration(moduleConfiguration) {
    // Workaround for temporary issue in SPOREL. VSO#279843
    var currentLocale = LocaleStore.getLocale();
    if (moduleConfiguration.paths) {
        // This only applies when testing production manifests without the server
        if (currentLocale) {
            for (var locale in moduleConfiguration.paths) {
                if (locale && locale.toUpperCase() === currentLocale.toUpperCase() && moduleConfiguration.paths[locale]) {
                    return moduleConfiguration.paths[locale];
                }
            }
        }
    }
    return moduleConfiguration.defaultPath;
}
//# sourceMappingURL=resolveAddress.js.map