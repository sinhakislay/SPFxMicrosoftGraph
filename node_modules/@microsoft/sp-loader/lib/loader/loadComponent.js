import { Text } from '@microsoft/sp-core-library';
import { _QosMonitor, _TraceLogger } from '@microsoft/sp-diagnostics';
import { isEmpty } from '@microsoft/sp-lodash-subset';
import ErrorBuilder from '../error/ErrorBuilder';
import ComponentStore from '../stores/ComponentStore';
import ManifestStore from '../stores/ManifestStore';
import { resolvePath } from '../utilities/resolveAddress';
import ResourceUrlChecker from '../utilities/ResourceUrlChecker';
import * as telemetryConstants from '../utilities/telemetryConstants';
import strings from './Loader.resx';
import commonStrings from '../loc/Common.resx';
var FIRST_RETRY = 1;
var MAX_NUMBER_RETRIES = 3;
var LOAD_COMPONENT_IMPL_EVENT_NAME = 'loadComponentImpl';
/**
 * Loads a component from a manifest.
 *
 * @param manifest - Manifest of the module to load.
 * @returns          A promise containing the loaded module.
 */
export default function loadComponent(manifest, moduleLoader) {
    if (!manifest) {
        return Promise.reject(new Error(Text.format(strings.isUndefinedValidateError, 'manifest')));
    }
    // If the module has already been cached, return the cached value. Might not have been resolved yet
    var cachedModule = ComponentStore.instance.tryGetComponent(manifest.id, manifest.version);
    if (cachedModule) {
        return cachedModule;
    }
    var componentPromise = _loadComponentRetryStrategy(manifest, FIRST_RETRY, MAX_NUMBER_RETRIES, moduleLoader).catch(function (error) {
        // If it fails to load, the caller can then call loadComponent() again and not hit the cache
        ComponentStore.instance.deleteComponent(manifest.id, manifest.version);
        throw error;
    });
    // Synchronously store the component in the Component Store
    // This allows other callers to use the cached execution when trying to load it as a dependency.
    // If the execution failed, it would asynchronously delete it from the Component Store so it can be requested again.
    ComponentStore.instance.storeComponent(manifest.id, manifest.version, componentPromise);
    return componentPromise;
}
function _loadComponentRetryStrategy(manifest, currentRetryNumber, maxNumberRetries, moduleLoader) {
    if (currentRetryNumber === 1) {
        _TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, Text.format(strings.loadComponentLog, manifest.id, manifest.alias, manifest.version));
    }
    else {
        _TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, Text.format(strings.loadComponentRetryLog, manifest.id, manifest.alias, currentRetryNumber, maxNumberRetries));
    }
    return _loadComponentImpl(manifest, moduleLoader)
        .then(function (component) {
        _TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, Text.format(strings.loadComponentEndLog, manifest.id, manifest.alias, manifest.version));
        return component;
    })
        .catch(function (error) {
        // If the attempt to load fails, the module loader deletes the module to try to load it again
        // Otherwise, the retry will get the module from the cache, thus failing again.
        moduleLoader.delete(manifest);
        if (currentRetryNumber < maxNumberRetries) {
            return _loadComponentRetryStrategy(manifest, currentRetryNumber + 1, maxNumberRetries, moduleLoader);
        }
        else {
            // All retries failed, so the user behavior will be affected. Log error instead of verbose
            _TraceLogger.logError(telemetryConstants.loadComponentLogSource, new Error(Text.format(commonStrings.loadComponentMaxRetriesError, manifest.id, manifest.alias, maxNumberRetries)));
            throw error;
        }
    });
}
/**
 * Private method to load component.
 * Assumes that the manifest is not undefined, and the component hasn't been loaded yet.
 *
 * Configures the module loader for this component, loads the dependencies and the entry point,
 * and in case of failure it rejects the promise.
 */
function _loadComponentImpl(manifest, moduleLoader) {
    try {
        moduleLoader.configure(manifest);
    }
    catch (error) {
        _TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message, LOAD_COMPONENT_IMPL_EVENT_NAME);
        return Promise.reject(error);
    }
    var componentDeps = [];
    var pathDeps = [];
    try {
        componentDeps = _loadComponentDependencies(manifest, moduleLoader);
    }
    catch (error) {
        _TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message, LOAD_COMPONENT_IMPL_EVENT_NAME);
        return Promise.reject(error);
    }
    try {
        pathDeps = _loadPathDependencies(manifest, moduleLoader);
    }
    catch (error) {
        _TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, error.message, LOAD_COMPONENT_IMPL_EVENT_NAME);
        return Promise.reject(error);
    }
    // If any dependency fails, the result for the entry point is not reliable, so the load fails
    return Promise.all(componentDeps.concat(pathDeps)).then(function (components) {
        // If the component doesn't have an entryModuleId, we can return an empty object
        // This is used for component that only load dependencies but have no code, like JSOM
        if (!manifest.loaderConfig.entryModuleId) {
            moduleLoader.ensure(manifest, {});
            return {};
        }
        return _loadEntryPoint(manifest, moduleLoader).then(function (entryPoint) {
            _validateComponentIsNotEmptyOrThrow(entryPoint, manifest);
            return entryPoint;
        });
    }).catch(function (e) {
        throw ErrorBuilder.buildLoadComponentError(manifest, e);
    });
}
/**
 * Checks if the component is not empty (or does not have a default properties that is empty).
 * If either case happens, it throws an error
 */
function _validateComponentIsNotEmptyOrThrow(component, manifest) {
    if (isEmpty(component)) {
        throw ErrorBuilder.buildLoadComponentReturnsEmptyError(manifest);
    }
    var defaultObject = component.default; // tslint:disable-line:no-any
    if (defaultObject && isEmpty(defaultObject) && !defaultObject.prototype) {
        throw ErrorBuilder.buildLoadComponentReturnsDefaultEmptyError(manifest);
    }
}
/**
 * Loads all component dependencies for a component.
 * If the dependency can't be found and it has a failover path, it will load it
 * from the path.
 *
 * Returns an array with the promises for all the component dependencies
 */
function _loadComponentDependencies(manifest, moduleLoader) {
    var depPromises = [];
    var resources = manifest.loaderConfig.scriptResources;
    var _loop_1 = function (name_1) {
        if (resources[name_1].type === 'component' && !resources[name_1].shouldNotPreload) {
            var moduleConfiguration_1 = resources[name_1];
            var resourceManifest = ManifestStore.instance.tryGetManifest(moduleConfiguration_1.id, moduleConfiguration_1.version);
            if (resourceManifest) {
                var dep = loadComponent(resourceManifest, moduleLoader).catch(function (e) {
                    throw ErrorBuilder.buildLoadComponentDependencyError(manifest, e);
                });
                depPromises.push(dep);
            }
            else { // if (!resourceManifest)
                if (moduleConfiguration_1.failoverPath) {
                    var dep = moduleLoader.loadFromFailoverPath(name_1)
                        .catch(function (e) {
                        return _processLoadErrors(manifest, name_1, [ResourceUrlChecker.checkResourceUrl].concat(moduleLoader.loadComponentDependencyErrorProcessors), function () { return ErrorBuilder.buildLoadComponentDependencyFailoverPathError(manifest, name_1, resolvePath(moduleConfiguration_1.failoverPath), e); });
                    });
                    depPromises.push(dep);
                }
                else { // if (!moduleConfiguration.failoverPath)
                    var dep = ManifestStore.instance.requestManifest(moduleConfiguration_1.id, moduleConfiguration_1.version)
                        .then(function (m) { return loadComponent(m, moduleLoader); })
                        .catch(function (e) { return Promise.reject(ErrorBuilder.buildManifestNotFoundError(moduleConfiguration_1)); });
                    depPromises.push(dep);
                }
            }
        }
    };
    for (var name_1 in resources) {
        _loop_1(name_1);
    }
    return depPromises;
}
/**
 * Loads all paths dependencies for a component, excluding the entry point.
 * If a path dependency is marked as shouldNotPreload, it is skipped
 */
function _loadPathDependencies(manifest, moduleLoader) {
    var resources = manifest.loaderConfig.scriptResources;
    var loadedPathDependencies = new Map();
    for (var name_2 in resources) {
        if ((resources[name_2].type === 'path' || resources[name_2].type === 'localizedPath')
            && !resources[name_2].shouldNotPreload) {
            if (name_2 !== manifest.loaderConfig.entryModuleId) {
                // tslint:disable-next-line:no-floating-promises - This is partially handled, but should be refactored
                _loadPathDependency(manifest, name_2, loadedPathDependencies, moduleLoader);
            }
        }
    }
    var loadedPathDependenciesValues = [];
    loadedPathDependencies.forEach(function (value) {
        loadedPathDependenciesValues.push(value);
    });
    return loadedPathDependenciesValues;
}
/**
 * Loads a single path dependency.
 * If there are any global dependencies, the requested path dependency will be loaded after its dependencies
 * in a serial way.
 * If the path dependency is requested more than once, it just returns the original promise.
 */
function _loadPathDependency(manifest, name, loadedPathDependencies, moduleLoader) {
    // If already requested, return the existing promise
    var loadedPathDependency = loadedPathDependencies.get(name);
    if (loadedPathDependency) {
        return loadedPathDependency;
    }
    var qosMonitor = new _QosMonitor(telemetryConstants.loadPathDependencyQosScenarioName);
    var qosExtraData = {
        name: name,
        manifestId: manifest.id,
        version: manifest.version,
        alias: manifest.alias,
        isInternal: manifest.isInternal
    };
    _TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, Text.format(strings.loadPathDependencyLog, name, manifest.id, manifest.alias));
    var resources = manifest.loaderConfig.scriptResources;
    var pathConfig = resources[name];
    if (!pathConfig) {
        return Promise.reject(ErrorBuilder.buildMissingPathDependencyError(manifest, name));
    }
    var loadPromise;
    if (pathConfig.globalDependencies) {
        var depPromises = pathConfig.globalDependencies
            .map(function (dep) { return _loadPathDependency(manifest, dep, loadedPathDependencies, moduleLoader); });
        loadPromise = Promise.all(depPromises).then(function () {
            return _moduleLoaderLoadPathDependency(manifest, name, moduleLoader);
        }, function () {
            throw ErrorBuilder.buildLoadPathDependencyBlockedError(manifest, name);
        });
    }
    else {
        loadPromise = _moduleLoaderLoadPathDependency(manifest, name, moduleLoader);
    }
    loadedPathDependencies.set(name, loadPromise);
    return loadPromise.then(function (load) {
        qosMonitor.writeSuccess(qosExtraData);
        return load;
    }, function (error) {
        qosMonitor.writeUnexpectedFailure(undefined, error, qosExtraData);
        throw error;
    });
}
/**
 * Auxiliary method to call the module loader on a path dependency.
 * Used only inside _loadPathDependency
 */
function _moduleLoaderLoadPathDependency(manifest, name, moduleLoader) {
    var globalName = manifest.loaderConfig.scriptResources[name].globalName;
    return moduleLoader.load(manifest, name, globalName)
        .catch(function (e) {
        return _processLoadErrors(manifest, name, [ResourceUrlChecker.checkResourceUrl].concat(moduleLoader.loadPathDependencyErrorProcessors), function () { return ErrorBuilder.buildLoadPathDependencyError(manifest, name, e); });
    });
}
/**
 * Loads the entry point for a component.
 * If it fails, it tries to identify the root cause of the error.
 */
function _loadEntryPoint(manifest, moduleLoader) {
    return moduleLoader.load(manifest).catch(function (e) {
        return _processLoadErrors(manifest, manifest.loaderConfig.entryModuleId, [ResourceUrlChecker.checkResourceUrl].concat(moduleLoader.loadEntryPointErrorProcessors), function () { return ErrorBuilder.buildLoadEntryPointError(manifest, e); });
    });
}
function _processLoadErrors(manifest, name, errorProcessors, buildDefaultError) {
    return Promise.all(errorProcessors.map(function (errorProcessor) { return errorProcessor(manifest, name); }))
        .then(
    // Default error handling
    function () {
        throw buildDefaultError();
    }, function (e) { throw e; });
}
//# sourceMappingURL=loadComponent.js.map