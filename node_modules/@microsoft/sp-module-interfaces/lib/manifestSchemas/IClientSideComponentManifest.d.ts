import { IClientSideComponentLoaderConfiguration } from './IClientSideComponentLoaderConfiguration';
import { IClientSideManifestBase } from './IClientSideManifestBase';
/**
 * A set of localized strings.
 *
 * @remarks

 * Supported values:
 *
 * - An Id referring to a localized resource. In this case it requires an 'id' key.
 *
 * - A dictionary of locale keys to strings. In this case it requires a 'default' key.
 *
 * ```
 * Example 1: "My Application"
 *          {
 *            "id": "$myStrings:myStrings.MyApplication;"
 *          }
 * Example 2: "My Application"
 *          {
 *            "default": "My Application"
 *            "en-us": "My Application",
 *            "fr-fr": "Ma demande",
 *            "zh": "我的應用程式"
 *          }
 * ```
 *
 * Notes on string ids:
 *
 * - Ids have the following structure: `$<resourceName>:<expression>;`
 *
 * - `resourceName` needs to be a `localizedResource` in the config.json.
 *
 * - `expression` is an expression that will be evaluated to access the string from the resource module.
 *
 * If your resource is a dictionary, access it through `"$resource:resource.MyString;"`
 * or `"$resource:resource[\"MyString\"];"`
 *
 * For more complex cases, run an appropriate expression to access your resource and return the string.
 *
 * @public
 */
export interface ILocalizedString {
    default?: string;
    id?: string;
    [locale: string]: string | undefined;
}
/**
 * Type of client-side component.
 * @public
 */
export declare type ComponentType = 'Application' | 'WebPart' | 'Library' | 'Extension';
/**
 * All client-side components built on the SharePoint framework need a valid component manifest. This interface
 * represents properties that are required by all types of client-side components like Applications and Web Parts.
 * Component specific manifests will extend this interface to add properties required by that component type.
 *
 * @remarks
 *
 * The schema of this manifest is owned and versioned by Microsoft. Following rules should be followed while changing
 * this schema. This set of rules can also be called the "manifest upgrade rules".
 *
 * - For minor changes, new properties can be added to this schema in a backwards-compatible way. i.e. the code
 *   that processes the manifest should be able to handle the absence of those new properties.
 *
 * - Try to model your changes as minor SemVer increments.  Major version changes should be avoided because they
 *   impose a migration cost on developers.
 *
 * - The `'manifestVersion'` should be bumped for all small or big changes.
 *
 * @privateRemarks
 *
 * This schema should be at all times kept in sync with the server-side code file
 * SPClientSideComponentManifest.cs.
 *
 * @public
 */
export interface IClientSideComponentManifest extends IClientSideManifestBase {
    /**
     * Type of client-side component. Components with the "Application" type are defined by the
     * "IClientSideApplicationManifest" interface. Components with the "WebPart" type are defined by the
     * "IClientSideWebPartManifest" interface. Components with the "Library" type are defined by the
     * "IClientSideLibraryManifest" interface.
     *
     * @remarks
     *
     * Usage: To help bundling, loading, enumeration, and initialization of components based on their contents.
     *
     * Supported values: `"Application"`, `"WebPart"`, `"Library"`, `"Extension"`
     */
    componentType: ComponentType;
    /**
     * A short name usually given by developer. It does not need to be localized and is expected to stay
     * the same through the lifetime of the component. If an application overrides the `ClientSideApplication.alias`
     * property, `ClientSideApplication.alias` is given precedence over the value provided in the manifest.
     *
     * @remarks
     *
     * Usage: A short name to identify a client-side component by developer.
     *
     * Supported values: Allowed characters are a-z, A-Z, and '-'. Not longer than 40 characters.
     *
     * Example: `"NewFeed"`
     *
     * @privateRemarks
     * telemetry data is categorized based on alias. If alias changes, new telemetry date for this
     * component will be put in a new category. It breaks history data if alias changes.
     */
    alias: string;
    /**
     * An auto-generated value for internal use. Do not add or use it.
     *
     * @remarks
     *
     * Usage: Not to be used by third-party developers.
     *
     * @privateRemarks
     *
     * this property indicates whether the component is first-party or third-party. IsInternal is true
     * for first-party, false for third-party. The value is controlled by server side code. It is used when framework
     * needs to differentiate between behaviors for first-party components and third-party, like in telemetry.
     *
     * @internal
     */
    isInternal?: boolean;
    /**
     * An auto-generated value for internal use. Do not add or use it.
     *
     * @remarks
     *
     * Usage: Not to be used by third-party developers.
     *
     * @privateRemarks
     * this property is true when the manifest comes from the debug query param.
     *
     * @internal
     */
    _isDebug?: boolean;
    /**
     * Client-side component version. The value of this field is expected to be controlled by the developer
     * of the client-side component.
     *
     * @remarks
     *
     * The purpose of this field is to help client-side component developers upgrade their client-side components
     * in a managed way. This helps the consumers of the client-side component make decisions about when and how
     * to upgrade the client-side component. As the developer evolves the code for their client-side
     * component, they can decide to bump the MAJOR, MINOR or PATCH version of the component.
     *
     * All incompatible API changes should result in a MAJOR version bump. Backwards compatible functionality
     * changes should result in a MINOR version bump, and backwards compatible bug fixes should result in a
     * PATCH version bump. Please see {@link http://semver.org} for more details on how to manage the version
     * of your components.
     *
     * Usage: Versioning and evolving a client-side component safely in a controlled way.
     *
     * Supported values: string representing a {@link http://semver.org | semantic version} i.e. MAJOR.MINOR.PATCH
     *
     * Example: `"1.0.0"`
     */
    version: string;
    /**
     * A list of component manifests that must be preloaded alongside this component.
     * These may include external resources that are needed during initial render, or components that should
     * be loaded only on demand.
     *
     * @remarks
     *
     * Supported values: an array of manifest IDs
     *
     * Example: `[ "66665f5e-307f-41cf-9fec-17c5ea20f0ca", "2d02eafb-eb82-47d2-98ac-dcac4aa63969" ]`
     *
     * @alpha
     */
    preloadComponents?: string[];
    /**
     * This property is used to keep older components that don't explicitly use fabric CSS.
     * For the most part, webparts build after using spfx 1.1 don't need this.
     */
    loadLegacyFabricCss?: boolean;
    /**
     * This property is provided for backwards compatibility.  It no longer has any effect.
     *
     * @deprecated Use requiresCustomScript instead of safeWithCustomScriptDisabled.
     */
    safeWithCustomScriptDisabled?: boolean;
    /**
     * If true, the component can only be installed on sites where Custom Script is enabled.
     * This should be set to true if the component allows authors to execute arbitrary scripts on the page.
     *
     * @remarks
     * Defaults to false.  See
     * https://support.office.com/en-us/article/Turn-scripting-capabilities-on-or-off-1f2c515f-5d7e-448a-9fd7-835da935584f
     * for more information.
     *
     * Usage: Requires Custom Script to be allowed in order for this component to be installed and run.
     */
    requiresCustomScript?: boolean;
    /**
     * This portion of the configuration describes how the component is to be loaded and initialized by a
     * client.  It contains an enumeration of scripts that the component requires along with a single
     * entry point script.
     *
     * @remarks
     * Usage: Loading a component.
     *
     * See `IClientSideComponentLoaderConfiguration` for more information and examples.
     *
     * @beta
     */
    loaderConfig: IClientSideComponentLoaderConfiguration;
    /**
     * The domain that the component should run on.
     *
     * @remarks
     *
     * Example: `'PrepSPO-appFEEAB5CE1CB0421FB1AAE5D09E0A8AAA.spgrid.com'`
     *
     * @alpha
     */
    isolatedDomain?: string;
    /**
     * Property bag for the component manifest.
     *
     * @remarks
     *
     * Usage: Provide a set of properties for the component, that doesn't change across instances.
     *
     * Supported values: Key-value pairs with a string key.
     *
     * @internal
     */
    properties?: {
        [key: string]: any;
    };
}
//# sourceMappingURL=IClientSideComponentManifest.d.ts.map